[
  
  {
    "title": "Qu’est-ce que Python ?",
    "content": "Le langage de programmation Python a été créé en 1989 par Guido van Rossum, aux Pays-Bas. Le nom Python\nvient d’un hommage à la série télévisée Monty Python’s Flying Circus dont G. van Rossum est fan. La première version\npublique de ce langage a été publiée en 1991.\nLa dernière version de Python est la version 3. Plus précisément, la version 3.11 a été publiée en octobre 2022. La\nversion 2 de Python est obsolète et n’est plus maintenue, évitez de l’utiliser.\n1\nLa Python Software Foundation est l’association qui organise le développement de Python et anime la communauté\nde développeurs et d’utilisateurs.\nCe langage de programmation présente de nombreuses caractéristiques intéressantes :\n•\nIl est multiplateforme. C’est-à-dire qu’il fonctionne sur de nombreux systèmes d’exploitation : Windows, Mac OS\nX, Linux, Android, iOS, depuis les mini-ordinateurs Raspberry Pi jusqu’aux supercalculateurs.\n•\nIl est gratuit. Vous pouvez l’installer sur autant d’ordinateurs que vous voulez (même sur votre téléphone !).\n•\nC’est un langage de haut niveau. Il demande relativement peu de connaissance sur le fonctionnement d’un ordinateur\npour être utilisé.\n•\nC’est un langage interprété. Un script Python n’a pas besoin d’être compilé pour être exécuté, contrairement à des\nlangages comme le C ou le C++.\n•\nIl est orienté objet. C’est-à-dire qu’il est possible de concevoir en Python des entités qui miment celles du monde\nréel (une molécule d’ADN, une protéine, un atome, etc.) avec un certain nombre de règles de fonctionnement et\nd’interactions.\n•\n2\nIl est relativement simple à prendre en main .\n• 3 4\nC’est le langage de programmation le plus utilisé au monde (voir les classements TIOBE et IEEE Spectrum ).\n•\nEnfin, il est très utilisé en bioinformatique, chimie-informatique et plus généralement en analyse de données.\nToutes ces caractéristiques font que Python est désormais enseigné dans de nombreuses formations, du lycée à\nl’enseignement supérieur.\n1.\nhttps://www.python.org/psf/\n2. Nous sommes d’accord, cette notion est très relative.\n3.\nhttps://www.tiobe.com/tiobe-index/\n4. https://spectrum.ieee.org/the-top-programming-languages-2023\n10\n1.2. Conseils pour l’apprentissage de Python Chapitre 1. Introduction"
  },
  {
    "title": "Conseils pour l’apprentissage de Python",
    "content": "Comme tout apprentissage, apprendre la programmation Python prend du temps et nécessite de pratiquer. Contrai-\nrement à d’autres activités scientifiques expérimentales (biologie moléculaire, chimie organique, électronique, etc.), pro-\ngrammer en Python ne nécessite pas de matériel coûteux, juste un ordinateur et éventuellement une connexion internet.\nPar ailleurs, Python est un programme informatique qui par définition ne se fatigue pas, est patient et toujours disponible.\nN’hésitez donc pas à pratiquer, pratiquer et pratiquer encore."
  },
  {
    "title": "Conseils pour installer et configurer Python",
    "content": "Pour pratiquer la programmation Python, il est préférable que Python soit installé sur votre ordinateur. La bonne\nnouvelle est que vous pouvez installer gratuitement Python sur votre machine, que ce soit sous Windows, Mac OS X ou\nLinux. Nous donnons ici un résumé des points importants concernant cette installation. La marche à suivre pas-à-pas est\ndétaillée à l’adresse https://python.sdv.u-paris.fr/ dans la rubrique B. Installation de Python.\n1.3.1 Python 2 ou Python 3 ?\nCe cours est basé sur la version 3 de Python, qui est désormais le standard.\nSi, néanmoins, vous deviez un jour travailler sur un ancien programme écrit en Python 2, sachez qu’il existe quelques\ndifférences importantes entre Python 2 et Python 3. Le chapitre 26 Remarques complémentaires (en ligne) vous apportera\nplus de précisions.\n1.3.2 Miniconda\n5\nNous vous conseillons d’installer Miniconda , logiciel gratuit, disponible pour Windows, Mac OS X et Linux, et qui\ninstallera pour vous Python 3.\nAvec le gestionnaire de paquets conda, fourni avec Miniconda, vous pourrez installer des modules supplémentaires\nqui sont très utiles en bioinformatique (NumPy, scipy, matplotlib, pandas, Biopython), mais également Jupyter Lab qui\n6\nvous permettra d’éditer des notebooks Jupyter. Vous trouverez en ligne une documentation pas-à-pas pour installer\nMiniconda, Python 3 et les modules supplémentaires qui seront utilisés dans ce cours.\n1.3.3 Éditeur de texte\nL’apprentissage d’un langage informatique comme Python va nécessiter d’écrire des lignes de codes à l’aide d’un\néditeur de texte. Si vous êtes débutants, on vous conseille d’utiliser notepad++ sous Windows, BBEdit ou CotEditor\nsous Mac OS X et gedit sous Linux. La configuration de ces éditeurs de texte est détaillée dans la rubrique Installation de\nPython disponible en ligne. Bien sûr, si vous préférez d’autres éditeurs comme Visual Studio Code, Sublime Text, emacs,\nvim, geany… utilisez-les !\nÀ toute fin utile, on rappelle que les logiciels Microsoft Word, WordPad et LibreOﬀice Writer ne sont pas des\néditeurs de texte, ce sont des traitements de texte qui ne peuvent pas et ne doivent pas être utilisés pour écrire du code\ninformatique."
  },
  {
    "title": "Notations utilisées",
    "content": "Dans cet ouvrage, les commandes, les instructions Python, les résultats et les contenus de fichiers sont indiqués avec\npour les éléments ponctuels ou\ncette police\n1\nsous cette forme,\n2 sur plusieurs lignes,\n3 pour les éléments les plus longs.\nPour ces derniers, le numéro à gauche indique le numéro de la ligne et sera utilisé pour faire référence à une instruction\nparticulière. Ce numéro n’est bien sûr là qu’à titre indicatif.\nPar ailleurs, dans le cas de programmes, de contenus de fichiers ou de résultats trop longs pour être inclus dans leur\nintégralité, la notation indique une coupure arbitraire de plusieurs caractères ou lignes.\n[...]\n5.\nhttps://conda.io/miniconda.html\n6. https://python.sdv.u-paris.fr/livre-dunod\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 11\nChapitre 1. Introduction 1.5. Introduction au shell"
  },
  {
    "title": "Introduction au shell",
    "content": "Un shell est un interpréteur de commandes interactif permettant d’interagir avec l’ordinateur. On utilisera le shell\npour lancer l’interpréteur Python.\nPour approfondir la notion de shell, vous pouvez consulter les pages Wikipedia :\n•\n7\ndu shell Unix fonctionnant sous Mac OS X et Linux ;\n• 8\ndu shell PowerShell fonctionnant sous Windows.\nUn shell possède toujours une invite de commande, c’est-à-dire un message qui s’aﬀiche avant l’endroit où on entre\ndes commandes. Dans tout cet ouvrage, cette invite est représentée par convention par le symbole dollar (qui n’a rien\n$\nà avoir ici avec la monnaie), et ce quel que soit le système d’exploitation.\nPar exemple, si on vous demande de lancer l’instruction suivante :\n$ python\nil faudra taper seulement sans le ni l’espace après le .\npython $ $"
  },
  {
    "title": "Premier contact avec Python",
    "content": "Python est un langage interprété, c’est-à-dire que chaque ligne de code est lue puis interprétée afin d’être exécutée\npar l’ordinateur. Pour vous en rendre compte, ouvrez un shell puis lancez la commande :\npython\nLa commande précédente va lancer l’interpréteur Python. Vous devriez obtenir quelque chose de ce style pour\nWindows :\nPS C:\\Users\\pierre>python\nPython 3.12.2 | packaged by Anaconda, Inc. | (main, Feb 27 2024, 17:28:07) [MSC v.1916 64 bit (AMD64)] on\nwin32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\npour Mac OS X :\niMac-de-pierre:Downloads$ python\nPython 3.12.2 | packaged by Anaconda, Inc. | (main, Feb 27 2024, 12:57:28) [Clang 14.0.6 ] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\nou pour Linux :\npierre@jeera:~$ python\nPython 3.12.2 | packaged by conda-forge | (main, Feb 16 2024, 20:50:58) [GCC 12.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\nLes blocs\n•\npour Windows,\nPS C:\\Users\\pierre>\n•\npour Mac OS X,\niMac-de-pierre:Downloads$\n•\npour Linux.\npierre@jeera:~$\nreprésentent l’invite de commande de votre shell. Il se peut que vous ayez aussi le mot qui indique que vous\n(base)\navez un environnement conda activé. Par la suite, cette invite de commande sera représentée simplement par le caractère\n, que vous soyez sous Windows, Mac OS X ou Linux.\n$\nLe triple chevron est l’invite de commande (prompt en anglais) de l’interpréteur Python. Ici, Python attend une\n>>>\ncommande que vous devez saisir au clavier. Tapez par exemple l’instruction :\nprint(\"Hello world!\")\npuis, validez cette commande en appuyant sur la touche Entrée.\nPython a exécuté la commande directement et a aﬀiché le texte . Il attend ensuite une nouvelle\nHello world!\ninstruction en aﬀichant l’invite de l’interpréteur Python ( ). En résumé, voici ce qui a dû apparaître sur votre écran :\n>>>\n7.\nhttps://fr.wikipedia.org/wiki/Shell_Unix\n8. https://fr.wikipedia.org/wiki/Windows_PowerShell\n12 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n1.7. Premier programme Chapitre 1. Introduction\n1\n>>> print(\"Hello world!\")\n2 Hello world!\n3\n>>>\nVous pouvez refaire un nouvel essai en vous servant cette fois de l’interpréteur comme d’une calculatrice :\n1 >>> 1+1\n2\n2\n3 >>> 6*3\n4\n18\nÀ ce stade, vous pouvez entrer une autre commande ou bien quitter l’interpréteur Python, soit en tapant la commande\npuis en validant en appuyant sur la touche Entrée, soit en pressant simultanément les touches Ctrl et D sous\nexit()\nLinux et Mac OS X ou Ctrl et Z puis Entrée sous Windows.\nEn résumant, l’interpréteur fonctionne sur le modèle :\n1 >>> instruction python\n2\nrésultat\noù le triple chevron correspond à l’entrée (input) que l’utilisateur tape au clavier, et l’absence de chevron en début\nde ligne correspond à la sortie (output) générée par Python. Une exception se présente toutefois : lorsqu’on a une longue\nligne de code, on peut la couper en deux avec le caractère (backslash) pour des raisons de lisibilité :\n\\\n1\n>>> Voici une longue ligne de code \\\n2 ... décrite sur deux lignes\n3\nrésultat\nEn ligne 1 on a rentré la première partie de la ligne de code. On termine par un , ainsi Python sait que la ligne de\n\\\ncode n’est pas finie. L’interpréteur nous l’indique avec les trois points . En ligne 2, on rentre la fin de la ligne de code\n...\npuis on appuie sur Entrée. À ce moment, Python nous génère le résultat. Si la ligne de code est vraiment très longue, il\nest même possible de la découper en trois voire plus :\n1 >>> Voici une ligne de code qui \\\n2\n... est vraiment très longue car \\\n3 ... elle est découpée sur trois lignes\n4\nrésultat\nL’interpréteur Python est donc un système interactif dans lequel vous pouvez entrer des commandes, que Python\nexécutera sous vos yeux (au moment où vous validerez la commande en appuyant sur la touche Entrée).\n9 10\nIl existe de nombreux autres langages interprétés comme Perl ou R . Le gros avantage de ce type de langage est\nqu’on peut immédiatement tester une commande à l’aide de l’interpréteur, ce qui est très utile pour débugger (c’est-à-dire\ntrouver et corriger les éventuelles erreurs d’un programme). Gardez bien en mémoire cette propriété de Python qui pourra\nparfois vous faire gagner un temps précieux !"
  },
  {
    "title": "Premier programme",
    "content": "Bien sûr, l’interpréteur présente vite des limites dès lors que l’on veut exécuter une suite d’instructions plus complexe.\nComme tout langage informatique, on peut enregistrer ces instructions dans un fichier, que l’on appelle communément\nun script (ou programme) Python.\nPour reprendre l’exemple précédent, ouvrez un éditeur de texte (pour choisir et configurer un éditeur de texte,\n11\nreportez-vous si nécessaire à la rubrique Installation de Python en ligne ) et entrez le code suivant :\nprint(\"Hello world!\")\nEnsuite, enregistrez votre fichier sous le nom , puis quittez l’éditeur de texte.\ntest.py\nRemarque\nL’extension de fichier standard des scripts Python est .\n.py\n9. http://www.perl.org\n10.\nhttp://www.r-project.org\n11. https://python.sdv.u-paris.fr/livre-dunod\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 13\nChapitre 1. Introduction 1.8. Commentaires\nPour exécuter votre script, ouvrez un shell et entrez la commande :\npython test.py\nVous devriez obtenir un résultat similaire à ceci :\n$ python test.py\nHello world!\nSi c’est bien le cas, bravo ! Vous avez exécuté votre premier programme Python."
  },
  {
    "title": "Commentaires",
    "content": "Dans un script, tout ce qui suit le caractère est ignoré par Python jusqu’à la fin de la ligne et est considéré comme\n#\nun commentaire.\nLes commentaires doivent expliquer votre code dans un langage humain. L’utilisation des commentaires est rediscutée\ndans le chapitre 16 Bonnes pratiques en programmation Python.\nVoici un exemple :\n1 # Votre premier commentaire en Python.\n2 print(\"Hello world!\")\n3\n4 # D'autres commandes plus utiles pourraient suivre.\nRemarque\n12\nOn appelle souvent à tort le caractère « dièse ». On devrait plutôt parler de « croisillon ».\n#"
  },
  {
    "title": "Notion de bloc d’instructions et d’indentation",
    "content": "En programmation, il est courant de répéter un certain nombre de choses (avec les boucles, voir le chapitre 5 Boucles\net comparaisons) ou d’exécuter plusieurs instructions si une condition est vraie (avec les tests, voir le chapitre 6 Tests).\nPar exemple, imaginons que nous souhaitions aﬀicher chacune des bases d’une séquence d’ADN, les compter puis\naﬀicher le nombre total de bases à la fin. Nous pourrions utiliser l’algorithme présenté en pseudo-code dans la figure 1.1.\nFigure 1.1 – Notion d’indentation et de bloc d’instructions.\nPour chaque base de la séquence ATCCGACTG, nous souhaitons effectuer deux actions : d’abord aﬀicher la base\npuis compter une base de plus. Pour indiquer cela, on décalera vers la droite ces deux instructions par rapport à la\nligne précédente ( ). Ce décalage est appelé indentation et l’ensemble des lignes indentées\npour chaque base [...]\nconstitue un bloc d’instructions.\nUne fois qu’on aura réalisé ces deux actions sur chaque base, on pourra passer à la suite, c’est-à-dire aﬀicher la taille\nde la séquence. Pour bien préciser que cet aﬀichage se fait à la fin, donc une fois l’aﬀichage puis le comptage de chaque\nbase terminés, la ligne correspondante n’est pas indentée (c’est-à-dire qu’elle n’est pas décalée vers la droite).\n12. https://fr.wikipedia.org/wiki/Croisillon_(signe)\n14 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n1.10. Autres ressources Chapitre 1. Introduction\nPratiquement, l’indentation en Python doit être homogène (soit des espaces, soit des tabulations, mais pas un mélange\ndes deux). Une indentation avec 4 espaces est le style d’indentation recommandé (voir le chapitre 16 Bonnes pratiques\nen programmation Python).\nSi tout cela semble un peu complexe, ne vous inquiétez pas. Vous allez comprendre tous ces détails chapitre après\nchapitre."
  },
  {
    "title": "Autres ressources",
    "content": "Pour compléter votre apprentissage de Python, n’hésitez pas à consulter d’autres ressources complémentaires à cet\nouvrage. D’autres auteurs abordent l’apprentissage de Python d’une autre manière. Nous vous conseillons les ressources\nsuivantes en langue française :\n•\nLe livre Apprendre à programmer avec Python 3 de Gérard Swinnen. Cet ouvrage est téléchargeable gratuitement\n13\nsur le site de Gérard Swinnen . Les éditions Eyrolles proposent également la version papier de cet ouvrage.\n•\nLe livre Apprendre à programmer en Python avec PyZo et Jupyter Notebook de Bob Cordeau et Laurent Pointal,\npublié aux éditions Dunod. Une partie de cet ouvrage est téléchargeable gratuitement sur le site de Laurent\n14\nPointal .\n• 15\nLe livre Apprenez à programmer en Python de Vincent Legoff que vous trouverez sur le site Openclassroms.\nEt pour terminer, une ressource incontournable en langue anglaise :\n• 16\nLe site www.python.org . Il contient énormément d’informations et de liens sur Python. La page d’index des\n17\nmodules est particulièrement utile (et traduite en français).\n13. http://www.inforef.be/swi/python.htm\n14.\nhttps://perso.limsi.fr/pointal/python:courspython3\n15. https://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python\n16.\nhttp://www.python.org\n17. https://docs.python.org/fr/3/py-modindex.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 15"
  },
  {
    "title": "Définition et création",
    "content": "Définition\nUne variable est une zone de la mémoire de l’ordinateur dans laquelle une valeur est stockée. Aux yeux du program-\nmeur, cette variable est définie par un nom, alors que pour l’ordinateur, il s’agit en fait d’une adresse, c’est-à-dire d’une\nzone particulière de la mémoire.\nEn Python, la déclaration d’une variable et son initialisation (c’est-à-dire la première valeur que l’on va stocker\ndedans) se font en même temps. Pour vous en convaincre, testez les instructions suivantes après avoir lancé l’interpréteur :\n1 >>> x = 2\n2\n>>> x\n3 2\nLigne 1. Dans cet exemple, nous avons déclaré, puis initialisé la variable avec la valeur 2. Notez bien qu’en réalité,\nx\nil s’est passé plusieurs choses :\n•\nPython a « deviné » que la variable était un entier. On dit que Python est un langage au typage dynamique.\n•\nPython a alloué (réservé) l’espace en mémoire pour y accueillir un entier. Chaque type de variable prend plus ou\nmoins d’espace en mémoire. Python a aussi fait en sorte qu’on puisse retrouver la variable sous le nom .\nx\n•\nEnfin, Python a assigné la valeur 2 à la variable .\nx\nDans d’autres langages (en C par exemple), il faut coder ces différentes étapes une par une. Python étant un langage\ndit de haut niveau, la simple instruction a suﬀi à réaliser les trois étapes en une fois !\nx = 2\nLignes 2 et 3. L’interpréteur nous a permis de connaître le contenu de la variable juste en tapant son nom. Retenez\nceci, car c’est une spécificité de l’interpréteur Python, très pratique pour chasser (debugger) les erreurs dans un\nprogramme. En revanche, la ligne d’un script Python qui contient seulement le nom d’une variable (sans aucune autre\nindication) n’aﬀichera pas la valeur de la variable à l’écran lors de l’exécution (pour autant, cette instruction reste valide\net ne générera pas d’erreur).\nDepuis la version 3.10, l’interpréteur Python a amélioré ses messages d’erreur. Il est ainsi capable de suggérer des\nnoms de variables existants lorsqu’on fait une faute de frappe :\n16\n2.2. Les types de variables Chapitre 2. Variables\n1\n>>> voyelles = \"aeiouy\"\n2 >>> voyelle\n3\nTraceback (most recent call last):\n4 File \"<stdin>\", line 1, in <module>\n5\nNameError: name 'voyelle' is not defined. Did you mean: 'voyelles'?\nSi le mot qu’on tape n’est pas très éloigné, cela fonctionne également lorsqu’on se trompe à différents endroits du\nmot !\n1 pharmacie = \"vente de médicaments\"\n2\n>>> farmacia\n3 Traceback (most recent call last):\n4 File \"<stdin>\", line 1, in <module>\n5 NameError: name 'farmacia' is not defined. Did you mean: 'pharmacie'?\nRevenons sur le signe ci-dessus.\n=\nDéfinition\nLe symbole est appelé opérateur d’affectation. Il permet d’assigner une valeur à une variable en Python. Cet\n=\nopérateur s’utilise toujours de la droite vers la gauche. Par exemple, dans l’instruction ci-dessus, Python attribue\nx = 2\nla valeur située à droite (ici, ) à la variable située à gauche (ici, ). D’autres langages de programmation comme R\n2 x\nutilisent les symboles pour rendre l’affectation d’une variable plus explicite, par exemple .\n<- x <- 2\nVoici d’autres cas de figures que vous rencontrerez avec l’opérateur :\n=\n1\n>>> x = 2\n2 >>> y = x\n3\n>>> y\n4 2\n5\n>>> x = 5 - 2\n6 >>> x\n7\n3\nLigne 2. Ici on a un nom de variable à gauche et à droite de l’opérateur . Dans ce cas, on garde la règle d’aller\n=\ntoujours de la droite vers la gauche. C’est donc le contenu de la variable qui est affecté à la variable .\ny x\nLigne 5. Comme on le verra plus bas, si on a à droite de l’opérateur une expression, ici la soustraction , celle-ci\n= 4 - 2\nest d’abord évaluée et c’est le résultat de cette opération qui sera affecté à la variable . On pourra noter également que\nx\nla valeur de précédente (2) a été écrasée.\nx\nAttention\nL’opérateur d’affectation écrase systématiquement la valeur de la variable située à sa gauche si celle-ci existe déjà.\n="
  },
  {
    "title": "Les types de variables",
    "content": "Définition\nLe type d’une variable correspond à la nature de celle-ci. Les trois principaux types dont nous aurons besoin dans\nun premier temps sont les entiers (integer ou int), les nombres décimaux que nous appellerons floats et les chaînes de\ncaractères (string ou str).\nBien sûr, il existe de nombreux autres types (par exemple, les booléens, les nombres complexes, etc.). Si vous n’êtes\n1\npas effrayés, vous pouvez vous en rendre compte ici .\n1. https://docs.python.org/fr/3.12/library/stdtypes.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 17\nChapitre 2. Variables 2.3. Nommage\nDans l’exemple précédent, nous avons stocké un nombre entier (int) dans la variable , mais il est tout à fait possible\nx\nde stocker des floats, des chaînes de caractères (string ou str) ou de nombreux autres types de variables que nous verrons\npar la suite :\n1 >>> y = 3.14\n2\n>>> y\n3 3.14\n4\n>>> a = \"bonjour\"\n5 >>> a\n6\n'bonjour'\n7 >>> b = 'salut'\n8\n>>> b\n9 'salut'\n10\n>>> c = \"\"\"girafe\"\"\"\n11 >>> c\n12 'girafe'\n13 >>> d = '''lion'''\n14 >>> d\n15\n'lion'\nRemarque\nPython reconnaît certains types de variables automatiquement (entier, float). Par contre, pour une chaîne de carac-\ntères, il faut l’entourer de guillemets (doubles, simples, voire trois guillemets successifs doubles ou simples) afin d’indiquer\nà Python le début et la fin de la chaîne de caractères.\nDans l’interpréteur, l’aﬀichage direct du contenu d’une chaîne de caractères se fait avec des guillemets simples, quel\nque soit le type de guillemets utilisé pour définir la chaîne de caractères.\nEn Python, comme dans la plupart des langages de programmation, c’est le point qui est utilisé comme séparateur\ndécimal. Ainsi, est un nombre reconnu comme un float en Python alors que ce n’est pas le cas de .\n3.14 3,14\n2\nIl existe également des variables de type booléen. Un booléen est une variable qui ne prend que deux valeurs : Vrai\nou Faux. En python, on utilise pour cela les deux mots réservés et :\nTrue False\n1\n>>> var = True\n2 >>> var2 = False\n3\n>>> var\n4 True\n5 >>> var2\n6\nFalse\nNous verrons l’utilité des booléens dans les chapitres 5 Boucles et 6 Tests."
  },
  {
    "title": "Nommage",
    "content": "Le nom des variables en Python peut être constitué de lettres minuscules ( à ), de lettres majuscules ( à ), de\na z A Z\nnombres ( à ) ou du caractère souligné ( ). Vous ne pouvez pas utiliser d’espace dans un nom de variable.\n0 9 _\nPar ailleurs, un nom de variable ne doit pas débuter par un chiffre et il n’est pas recommandé de le faire débuter par\nle caractère (sauf cas très particuliers).\n_\nDe plus, il faut absolument éviter d’utiliser un mot « réservé » par Python comme nom de variable (par exemple :\n, , , , etc.).\nprint range for from\nDans la mesure du possible, il est conseillé de mettre des noms de variables explicites. Sauf dans de rares cas que\nnous expliquerons plus tard dans le cours, évitez les noms de variables à une lettre.\nEnfin, Python est sensible à la casse, ce qui signifie que les variables , et sont différentes.\nTesT test TEST"
  },
  {
    "title": "Écriture scientifique",
    "content": "On peut écrire des nombres très grands ou très petits avec des puissances de 10 en utilisant le symbole :\ne\n2. https://fr.wikipedia.org/wiki/Bool%C3%A9en\n18 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n2.5. Opérations Chapitre 2. Variables\n1\n>>> 1e6\n2 1000000.0\n3\n>>> 3.12e-3\n4 0.00312\nOn appelle cela écriture ou notation scientifique. On pourra noter deux choses importantes :\n−\n• × ×\n6 3\nou n’implique pas l’utilisation du nombre exponentiel e, mais signifie 1 10 ou 3.12 10 respec-\n1e6 3.12e-3\ntivement ;\n•\nmême si on ne met que des entiers à gauche et à droite du symbole (comme dans ), Python génère systéma-\ne 1e6\ntiquement un float.\nEnfin, vous avez sans doute constaté qu’il est parfois pénible d’écrire des nombres composés de beaucoup de chiffres,\n× 23 3\npar exemple le nombre d’Avogradro 6.02214076 10 ou le nombre d’humains sur Terre 8094752749 au 5 mars 2024\nà 19h34. Pour s’y retrouver, Python autorise l’utilisation du caractère « souligné » (ou underscore) pour séparer des\n_\ngroupes de chiffres. Par exemple :\n1\n>>> avogadro_number = 6.022_140_76e23\n2 >>> print(avogadro_number)\n3 6.02214076e+23\n4\n>>> humans_on_earth = 8_094_752_749\n5 >>> print(humans_on_earth)\n6\n8094752749\nDans ces exemples, le caractère (underscore ou « souligné ») est utilisé pour séparer des groupes de trois chiffres,\n_\nmais on peut faire ce qu’on veut :\n1\n>>> print(80_94_7527_49)\n2 8094752749"
  },
  {
    "title": "Opérations",
    "content": "2.5.1 Opérations sur les types numériques\nLes quatre opérations arithmétiques de base se font de manière simple sur les types numériques (nombres entiers et\nfloats) :\n1 >>> x = 45\n2\n>>> x + 2\n3 47\n4\n>>> x - 2\n5 43\n6\n>>> x * 3\n7 135\n8\n>>> y = 2.5\n9 >>> x - y\n10 42.5\n11\n>>> (x * 10) + y\n12 452.5\nRemarquez toutefois que si vous mélangez les types entiers et floats, le résultat est renvoyé comme un float (car ce\ntype est plus général). Par ailleurs, l’utilisation de parenthèses permet de gérer les priorités.\nL’opérateur effectue une division. Contrairement aux opérateurs , et , celui-ci renvoie systématiquement un\n/ + - *\nfloat :\n1\n>>> 3 / 4\n2 0.75\n3 >>> 2.5 / 2\n4\n1.25\n5 >>> 6 / 3\n6\n2.0\n7 >>> 10 / 2\n8\n5.0\n3. https://thepopulationproject.org/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 19\nChapitre 2. Variables 2.5. Opérations\nL’opérateur puissance utilise les symboles :\n**\n1 >>> 2**3\n2\n8\n3 >>> 2**4\n4\n16\n4\nPour obtenir le quotient et le reste d’une division entière (voir ici pour un petit rappel sur la division entière), on\nutilise respectivement les symboles et modulo :\n// %\n1 >>> 5 // 4\n2\n1\n3 >>> 5 % 4\n4\n1\n5 >>> 8 // 4\n6\n2\n7 >>> 8 % 4\n8 0\nLes symboles , , , , , et sont appelés opérateurs, car ils réalisent des opérations sur les variables.\n+ - * / ** // %\nEnfin, il existe des opérateurs « combinés » qui effectue une opération et une affectation en une seule étape :\n1 >>> i = 0\n2 >>> i = i + 1\n3 >>> i\n4 1\n5\n>>> i += 1\n6 >>> i\n7\n2\n8 >>> i += 2\n9\n>>> i\n10 4\nL’opérateur effectue une addition puis affecte le résultat à la même variable. Cette opération s’appelle une «\n+=\nincrémentation ».\nLes opérateurs , et se comportent de manière similaire pour la soustraction, la multiplication et la division.\n-= *= /=\n2.5.2 Opérations sur les chaînes de caractères\nPour les chaînes de caractères, deux opérations sont possibles, l’addition et la multiplication :\n1\n>>> chaine = \"Salut\"\n2 >>> chaine\n3\n'Salut'\n4 >>> chaine + \" Python\"\n5 'Salut Python'\n6 >>> chaine * 3\n7 'SalutSalutSalut'\nL’opérateur d’addition concatène (assemble) deux chaînes de caractères. On parle de concaténation.\n+\nL’opérateur de multiplication entre un nombre entier et une chaîne de caractères duplique (répète) plusieurs fois\n*\nune chaîne de caractères. On parle de duplication.\nAttention\nVous observez que les opérateurs et se comportent différemment s’il s’agit d’entiers ou de chaînes de caractères.\n+ *\nAinsi, l’opération est une addition alors que l’opération est une concaténation. On appelle ce compor-\n2 + 2 \"2\" + \"2\"\ntement redéfinition des opérateurs. Nous serons amenés à revoir cette notion dans le chapitre 24 Avoir plus la classe\navec les objets (en ligne).\n4. https://fr.wikipedia.org/wiki/Division_euclidienne\n20 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n2.6. La fonction Chapitre 2. Variables\ntype()\n2.5.3 Opérations illicites\nAttention à ne pas faire d’opération illicite, car vous obtiendriez un message d’erreur :\n1\n>>> \"toto\" * 1.3\n2 Traceback (most recent call last):\n3\nFile \"<stdin>\", line 1, in <module>\n4 TypeError: can't multiply sequence by non-int of type 'float'\n5 >>> \"toto\" + 2\n6\nTraceback (most recent call last):\n7 File \"<stdin>\", line 1, in <module>\n8\nTypeError: can only concatenate str (not \"int\") to str\nNotez que Python vous donne des informations dans son message d’erreur. Dans le second exemple, il indique que\nvous devez utiliser une variable de type str, c’est-à-dire une chaîne de caractères et pas un int, c’est-à-dire un entier."
  },
  {
    "title": "type()",
    "content": "Si vous ne vous souvenez plus du type d’une variable, utilisez la fonction qui vous le rappellera.\ntype()\n1 >>> x = 2\n2\n>>> type(x)\n3 <class 'int'>\n4\n>>> y = 2.0\n5 >>> type(y)\n6\n<class 'float'>\n7 >>> z = '2'\n8\n>>> type(z)\n9 <class 'str'>\n10 >>> type(True)\n11 <class 'bool'>\nNous verrons plus tard ce que signifie le mot class.\nAttention\nPour Python, la valeur (nombre entier) est différente de (float) et est aussi différente de (chaîne de\n2 2.0 '2'\ncaractères)."
  },
  {
    "title": "Conversion de types",
    "content": "En programmation, on est souvent amené à convertir les types, c’est-à-dire passer d’un type numérique à une chaîne\nde caractères ou vice-versa. En Python, rien de plus simple avec les fonctions , et . Pour vous en\nint() float() str()\nconvaincre, regardez ces exemples :\n1 >>> i = 3\n2\n>>> str(i)\n3 '3'\n4\n>>> i = '456'\n5 >>> int(i)\n6\n456\n7 >>> float(i)\n8 456.0\n9\n>>> i = '3.1416'\n10 >>> float(i)\n11\n3.1416\nOn verra au chapitre 7 Fichiers que ces conversions sont essentielles. En effet, lorsqu’on lit ou écrit des nombres dans\nun fichier, ils sont considérés comme du texte, donc des chaînes de caractères.\nToute conversion d’une variable d’un type en un autre est appelé casting en anglais, il se peut que vous croisiez ce\nterme si vous consultez d’autres ressources.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 21\nChapitre 2. Variables 2.8. Note sur le vocabulaire et la syntaxe"
  },
  {
    "title": "Note sur le vocabulaire et la syntaxe",
    "content": "Nous avons vu dans ce chapitre la notion de variable qui est commune à tous les langages de programmation.\nToutefois, Python est un langage dit « orienté objet », il se peut que dans la suite du cours, nous employions le mot\nobjet pour désigner une variable. Par exemple, « une variable de type entier » sera pour nous équivalent à « un objet de\ntype entier ». Nous verrons dans le chapitre 23 Avoir la classe avec les objets (en ligne) ce que le mot « objet » signifie\nréellement (tout comme le mot « classe »).\nPar ailleurs, nous avons rencontré plusieurs fois des fonctions dans ce chapitre, notamment avec , ,\ntype() int()\net . Dans le chapitre 1 Introduction, nous avons également vu la fonction . On reconnaît qu’il\nfloat() str() print()\ns’agit d’une fonction, car son nom est suivi de parenthèses (par exemple, ). En Python, la syntaxe générale est\ntype()\n.\nfonction()\nCe qui se trouve entre les parenthèses d’une fonction est appelé argument et c’est ce que l’on « passe » à la fonction.\nDans l’instruction , c’est l’entier qui est l’argument passé à la fonction . Pour l’instant, on retiendra\ntype(2) 2 type()\nqu’une fonction est une sorte de boîte à qui on passe un (ou plusieurs) argument(s), qui effectue une action et qui peut\nrenvoyer un résultat ou plus généralement un objet. Par exemple, la fonction renvoie le type de la variable qu’on\ntype()\nlui a passé en argument.\nSi ces notions vous semblent obscures, ne vous inquiétez pas, au fur et à mesure que vous avancerez dans le cours,\ntout deviendra limpide."
  },
  {
    "title": "Minimum et maximum",
    "content": "Python propose les fonctions et qui renvoient respectivement le minimum et le maximum de plusieurs\nmin() max()\nentiers ou floats :\n1\n>>> min(1, -2, 4)\n2 -2\n3\n>>> pi = 3.14\n4 >>> e = 2.71\n5\n>>> max(e, pi)\n6 3.14\n7\n>>> max(1, 2.4, -6)\n8 2.4\nPar rapport à la discussion de la rubrique précédente, et sont des exemples de fonctions prenant plusieurs\nmin() max()\narguments. En Python, quand une fonction prend plusieurs arguments, on doit les séparer par une virgule. et\nmin() max()\nprennent en argument autant d’entiers et de floats que l’on veut, mais il en faut au moins deux."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, utilisez l’interpréteur Python.\n2.10.1 Nombres de Friedman\n5\nLes nombres de Friedman sont des nombres qui peuvent s’exprimer avec tous leurs chiffres dans une expression\nmathématique.\n3\nPar exemple, 347 est un nombre de Friedman, car il peut s’écrire sous la forme 4+7 . De même pour 127 qui peut\n−\n7\ns’écrire sous la forme 2 1.\nDéterminez si les expressions suivantes correspondent à des nombres de Friedman. Pour cela, vous les écrirez en\nPython puis exécuterez le code correspondant.\n• 6\n7+3\n•\n3\n( + )\n3 4\n• 6 −\n3 5\n5. https://fr.wikipedia.org/wiki/Nombre_de_Friedman\n22 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n2.10. Exercices Chapitre 2. Variables\n• 8 ×\n(1+2 ) 5\n•\n8 7\n(2+1 )\n2.10.2 Prédire le résultat : opérations\nEssayez de prédire le résultat de chacune des instructions suivantes, puis vérifiez-le dans l’interpréteur Python :\n•\n(1+2)**3\n•\n\"Da\" * 4\n•\n\"Da\" + 3\n•\n(\"Pa\"+\"La\") * 2\n•\n(\"Da\"*4) / 2\n•\n5 / 2\n•\n5 // 2\n•\n5 % 2\n2.10.3 Prédire le résultat : opérations et conversions de types\nEssayez de prédire le résultat de chacune des instructions suivantes, puis vérifiez-le dans l’interpréteur Python :\n•\nstr(4) * int(\"3\")\n•\nint(\"3\") + float(\"3.2\")\n•\nstr(3) * float(\"3.2\")\n•\nstr(3/4) * 2\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 23"
  },
  {
    "title": "print()",
    "content": "Dans le chapitre 1 Introduction, nous avons rencontré la fonction qui aﬀiche une chaîne de caractères (le\nprint()\nfameux ). En fait, la fonction aﬀiche l’argument qu’on lui passe entre parenthèses et un\n\"Hello world!\" print()\nretour à ligne. Ce retour à ligne supplémentaire est ajouté par défaut. Si toutefois, on ne veut pas aﬀicher ce retour à la\nligne, on peut utiliser l’argument par « mot-clé » :\nend\n1\n>>> print(\"Hello world!\")\n2 Hello world!\n3\n>>> print(\"Hello world!\", end=\"\")\n4 Hello world!>>>\nLigne 1. On a utilisé l’instruction classiquement en passant la chaîne de caractères en\nprint() \"Hello world!\"\nargument.\nLigne 3. On a ajouté un second argument , en précisant le mot-clé . Nous aborderons les arguments\nend=\"\" end\npar mot-clé dans le chapitre 10 Fonctions. Pour l’instant, dites-vous que cela modifie le comportement par défaut des\nfonctions.\nLigne 4. L’effet de l’argument est que les trois chevrons se retrouvent collés après la chaîne de caractères\nend=\"\" >>>\n.\n\"Hello world!\"\nUne autre manière de s’en rendre compte est d’utiliser deux fonctions à la suite. Dans la portion de code\nprint()\nsuivante, le caractère « » sert à séparer plusieurs instructions Python sur une même ligne :\n;\n1 >>> print(\"Hello\") ; print(\"Joe\")\n2\nHello\n3 Joe\n4\n>>> print(\"Hello\", end=\"\") ; print(\"Joe\")\n5 HelloJoe\n6 >>> print(\"Hello\", end=\" \") ; print(\"Joe\")\n7\nHello Joe\nLa fonction peut également aﬀicher le contenu d’une variable quel que soit son type. Par exemple, pour un\nprint()\nentier :\n1\n>>> var = 3\n2 >>> print(var)\n3\n3\n24\n3.2. Messages d’erreur Chapitre 3. Aﬀichage\nIl est également possible d’aﬀicher le contenu de plusieurs variables (quel que soit leur type) en les séparant par des\nvirgules :\n1\n>>> x = 32\n2 >>> nom = \"John\"\n3\n>>> print(nom, \"a\", x, \"ans\")\n4 John a 32 ans\nPython a écrit une phrase complète en remplaçant les variables et par leur contenu. Vous remarquerez que\nx nom\npour aﬀicher plusieurs éléments de texte sur une seule ligne, nous avons utilisé le séparateur « » entre les différents\n,\néléments. Python a également ajouté un espace à chaque fois que l’on utilisait le séparateur « ». On peut modifier ce\n,\ncomportement en passant à la fonction l’argument par mot-clé :\nprint() sep\n1\n>>> x = 32\n2 >>> nom = \"John\"\n3\n>>> print(nom, \"a\", x, \"ans\", sep=\"\")\n4 Johna32ans\n5\n>>> print(nom, \"a\", x, \"ans\", sep=\"-\")\n6 John-a-32-ans\n7\n>>> print(nom, \"a\", x, \"ans\", sep=\"_\")\n8 John_a_32_ans\nPour aﬀicher deux chaînes de caractères l’une à côté de l’autre, sans espace, on peut soit les concaténer, soit utiliser\nl’argument par mot-clé avec une chaîne de caractères vide :\nsep\n1 >>> ani1 = \"chat\"\n2\n>>> ani2 = \"souris\"\n3 >>> print(ani1, ani2)\n4\nchat souris\n5 >>> print(ani1 + ani2)\n6\nchatsouris\n7 >>> print(ani1, ani2, sep=\"\")\n8\nchatsouris"
  },
  {
    "title": "Messages d’erreur",
    "content": "Nous avons déjà croisé des messages d’erreur dans le chapitre précédent sur les variables. Nous vous expliquons ici\ncomment les lire.\nDepuis la version 3.10 de Python, l’interpréteur renvoie des messages explicites lorsqu’on fait une erreur de syntaxe.\nPar exemple, on considère le script suivant (enregistré dans un fichier nommé ) qui contient plusieurs erreurs.\ntest.py\nLes voyez-vous ?\n1\nprint(\"chat\"\n2 print(\"souris\")\n3\nprint(1 / 0)\n4 print(int(\"deux\"))\nVous avez sans doute repéré l’oubli d’une parenthèse fermante en ligne 1. Lorsqu’on lance le script, on obtient :\n$ python test.py\nFile \"test.py\", line 1\nprint(\"chat\"\n^\nSyntaxError: '(' was never closed\nComment doit-on lire ce message d’erreur ? Et bien cela se fait toujours du bas vers le haut. Le message s’appelle\nune Traceback et contient plusieurs types d’information :\n•\nTout en bas : On a le type d’erreur qui a été généré (on verra plus tard que cela s’appelle en réalité une exception).\nIci une erreur de syntaxe appelée . Puis sur la même ligne, un indice supplémentaire (ici l’absence\nSyntaxError\nd’une parenthèse).\n•\nUn peu plus haut : une description de l’erreur où on voit la parenthèse ouverte qui n’a jamais été fermée.\n•\nEncore plus haut : le numéro de ligne dans le code où l’erreur a été détectée.\nAvec cette Traceback il devient facile de corriger l’erreur.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 25\nChapitre 3. Aﬀichage 3.3. Écriture formatée et f-strings\nAttention\nDans les vieilles versions de Python (< 3.10), la même erreur conduisait à une Traceback beaucoup moins claire :\n$ python3.5 test.py\nFile \"test.py\", line 2\nprint(\"souris\")\n^\nSyntaxError: invalid syntax\nL’interpréteur vous indiquait une erreur de syntaxe en ligne 2 alors que l’oubli de parenthèse était en ligne 1 ! Pour\ncette raison, utilisez dans la mesure du possible une version récente de Python (3.12 ou 3.13).\nSi nous corrigeons la ligne 1 en mettant la parenthèse finale et que nous relançons le script, nous aurons cette fois-ci\nune erreur due à une division par zéro :\n$ python test.py\nchat\nsouris\nTraceback (most recent call last):\nFile \"test.py\", line 3, in <module>\nprint(1 / 0)\n~~^~~\nZeroDivisionError: division by zero\nSi nous corrigeons cette erreur en ligne 3 en évitant la division par zéro (par exemple en mettant ),\nprint(1 / 1)\nl’exécution donnera un autre message d’erreur dû à la ligne 4 où la transformation d’une chaîne de caractères en entier\nn’est pas possible :\n$ python test.py\nchat\nsouris\n1\nTraceback (most recent call last):\nFile \"test.py\", line 4, in <module>\nprint(int(\"deux\"))\n^^^^^^^^^^^\nValueError: invalid literal for int() with base 10: 'deux'\nÀ nouveau dans ces deux derniers exemples de Traceback, vous voyez qu’on a la même construction. Tout en bas, le\ntype d’erreur, puis en remontant une description du problème et le numéro de ligne où l’erreur a été détectée.\nConseil\nIl est important de bien lire chaque message d’erreur généré par Python. En général, la clé du problème est mentionnée\ndans ce message vous donnant des éléments pour le corriger."
  },
  {
    "title": "Écriture formatée et f-strings",
    "content": "3.3.1 Définitions\nDéfinition\nL’écriture formatée est un mécanisme permettant d’aﬀicher des variables avec un format précis, par exemple justifiées\nà gauche ou à droite, ou encore avec un certain nombre de décimales pour les floats. L’écriture formatée est incontournable\nlorsqu’on veut créer des fichiers organisés en « belles colonnes » comme par exemple les fichiers PDB (pour en savoir\nplus sur ce format, reportez-vous à l’annexe A Quelques formats de données en biologie).\nDepuis la version 3.6, Python a introduit les f-strings pour mettre en place l’écriture formatée que nous allons décrire\nen détail dans cette rubrique. Il existe d’autres manières pour formater des chaînes de caractères qui étaient utilisées\n26 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n3.3. Écriture formatée et f-strings Chapitre 3. Aﬀichage\navant la version 3.6, nous expliquons cela dans le chapitre 26 Remarques complémentaires (en ligne). Toutefois, nous\nvous conseillons vivement l’utilisation des f-strings si vous débutez l’apprentissage de Python. Il est inutile d’apprendre\nles anciennes manières.\nDéfinition\nf-string est le diminutif de formatted string literals. Mais encore ? Dans le chapitre précédent, nous avons vu les\nchaînes de caractères ou encore strings qui étaient représentées par un texte entouré de guillemets simples ou doubles.\nPar exemple :\n1\n\"Ceci est une chaîne de caractères\"\nL’équivalent en f-string est la même chaîne de caractères précédée du caractère sans espace entre les deux :\nf\n1\nf\"Ceci est une chaîne de caractères\"\nCe caractère avant les guillemets va indiquer à Python qu’il s’agit d’une f-string mettant en place le mécanisme de\nf\nl’écriture formatée, contrairement à une string normale.\nNous expliquons plus en détail dans le chapitre 11 Plus sur les chaînes de caractères pourquoi on doit mettre ce et\nf\nquel est le mécanisme sous-jacent.\n3.3.2 Prise en main des f-strings\nLes f-strings permettent une meilleure organisation de l’aﬀichage des variables. Reprenons l’exemple ci-dessus à propos\nde notre ami John :\n1\n>>> x = 32\n2 >>> nom = \"John\"\n3\n>>> print(f\"{nom} a {x} ans\")\n4 John a 32 ans\nIl suﬀit de passer un nom de variable au sein de chaque couple d’accolades et Python les remplace par leur contenu.\nLa syntaxe apparait plus lisible que l’équivalent vu précédemment :\n1\n>>> print(nom, \"a\", x, \"ans\")\n2 John a 32 ans\nBien sûr, il ne faut pas omettre le avant le premier guillemet, sinon Python prendra cela pour une chaîne de\nf\ncaractères normale et ne mettra pas en place le mécanisme de remplacement entre les accolades :\n1 >>> print(\"{nom} a {x} ans\")\n2\n{nom} a {x} ans\nRemarque\nUne variable est utilisable plus d’une fois pour une f-string donnée :\n1\n>>> var = \"to\"\n2 >>> print(f\"{var} et {var} font {var}{var}\")\n3\nto et to font toto\n4 >>>\nEnfin, il est possible de mettre entre les accolades des valeurs numériques ou des chaînes de caractères :\n1 >>> print(f\"J'affiche l'entier {10} et le float {3.14}\")\n2\nJ'affiche l'entier 10 et le float 3.14\n3 >>> print(f\"J'affiche la chaine {'Python'}\")\n4\nJ'affiche la chaine Python\nMême si cela ne présente que peu d’intérêt pour l’instant, il s’agit d’une commande Python parfaitement valide. Nous\nverrons des exemples plus pertinents par la suite. Cela fonctionne avec n’importe quel type de variable (entiers, chaînes\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 27\nChapitre 3. Aﬀichage 3.3. Écriture formatée et f-strings\nde caractères, floats, etc.). Attention toutefois pour les chaînes de caractères, utilisez des guillemets simples au sein des\naccolades si vous définissez votre f-string avec des guillemets doubles.\n3.3.3 Spécification de format\nLes f-strings permettent de remplacer des variables au sein d’une chaîne de caractères. On peut également spécifier\nle format de leur aﬀichage.\nPrenons un exemple. Imaginez que vous vouliez calculer, puis aﬀicher, la proportion de GC d’un génome. La proportion\nde GC s’obtient comme la somme des bases Guanine (G) et Cytosine (C) divisée par le nombre total de bases (A, T, C,\nG) du génome considéré. Si on a, par exemple, 4 500 bases G et 2 575 bases C, pour un total de 14 800 bases, vous\npourriez procéder comme suit (notez bien l’utilisation des parenthèses pour gérer les priorités des opérateurs) :\n1\n>>> prop_GC = (4500 + 2575) / 14800\n2 >>> print(\"La proportion de GC est\", prop_GC)\n3\nLa proportion de GC est 0.4780405405405405\nLe résultat obtenu présente trop de décimales (seize dans le cas présent). Pour écrire le résultat plus lisiblement, vous\npouvez spécifier dans les accolades le format qui vous intéresse. Dans le cas présent, vous voulez formater un float\n{}\npour l’aﬀicher avec deux puis trois décimales :\n1\n>>> print(f\"La proportion de GC est {prop_GC:.2f}\")\n2 La proportion de GC est 0.48\n3\n>>> print(f\"La proportion de GC est {prop_GC:.3f}\")\n4 La proportion de GC est 0.478\nDétaillons le contenu des accolades de la première ligne ( ) :\n{prop_GC:.2f}\n•\nD’abord on a le nom de la variable à formatter, , c’est indispensable avec les f-strings.\nprop_GC\n•\nEnsuite on rencontre les deux-points , ceux-ci indiquent que ce qui suit va spécifier le format dans lequel on veut\n:\naﬀicher la variable .\nprop_GC\n•\nÀ droite des deux-points on trouve qui indique ce format : la lettre indique qu’on souhaite aﬀicher la variable\n.2f f\nsous forme d’un float, les caractères indiquent la précision voulue, soit ici deux chiffres après la virgule.\n.2\nNotez enfin que le formatage avec ( étant un entier positif) renvoie un résultat arrondi.\n.xf x\nVous pouvez aussi formater des entiers avec la lettre (ici veut dire decimal integer) :\nd d\n1\n>>> nb_G = 4500\n2 >>> print(f\"Ce génome contient {nb_G:d} guanines\")\n3\nCe génome contient 4500 guanines\nou mettre plusieurs nombres dans une même chaîne de caractères :\n1 >>> nb_G = 4500\n2\n>>> nb_C = 2575\n3 >>> print(f\"Ce génome contient {nb_G:d} G et {nb_C:d} C, \"\n4\n... f\"soit une proportion de {prop_GC:.2f}\")\n5 Ce génome contient 4500 G et 2575 C, soit une proportion de 0.48\n6\n>>> perc_GC = prop_GC * 100\n7 >>> print(f\"Ce génome contient {nb_G:d} G et {nb_C:d} C, \"\n8\n... f\"soit un %GC de {perc_GC:.2f} %\")\n9 Ce génome contient 4500 G et 2575 C, soit un %GC de 47.80 %\nLes instructions étant longues dans cet exemple, nous avons coupé chaque chaîne de caractères sur deux lignes. Il faut\nmettre à chaque fois le pour préciser à Python qu’on utilise une f-string. Les indiquent que l’interpréteur attend\nf ...\nque l’on ferme la parenthèse du entamé sur la ligne précédente. Nous reverrons cette syntaxe dans le chapitre 11\nprint\nPlus sur les chaînes de caractères.\nEnfin, il est possible de préciser sur combien de caractères vous voulez qu’un résultat soit écrit et comment se fait\nl’alignement (à gauche, à droite), ou si vous voulez centrer le texte. Dans la portion de code suivante, le caractère sert\n;\nde séparateur entre les instructions sur une même ligne :\n28 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n3.3. Écriture formatée et f-strings Chapitre 3. Aﬀichage\n1\n>>> print(10) ; print(1000)\n2 10\n3\n1000\n4 >>> print(f\"{10:>6d}\") ; print(f\"{1000:>6d}\")\n5\n10\n6 1000\n7 >>> print(f\"{10:<6d}\") ; print(f\"{1000:<6d}\")\n8\n10\n9 1000\n10\n>>> print(f\"{10:^6d}\") ; print(f\"{1000:^6d}\")\n11 10\n12\n1000\n13 >>> print(f\"{10:*^6d}\") ; print(f\"{1000:*^6d}\")\n14\n**10**\n15 *1000*\n16\n>>> print(f\"{10:0>6d}\") ; print(f\"{1000:0>6d}\")\n17 000010\n18\n001000\nNotez que spécifie un alignement à droite, spécifie un alignement à gauche et spécifie un alignement centré.\n> < ^\nIl est également possible d’indiquer le caractère qui servira de remplissage lors des alignements (l’espace est le caractère\npar défaut).\nCe formatage est également possible sur des chaînes de caractères avec la lettre (comme string) :\ns\n1\n>>> print(\"atom HN\") ; print(\"atom HDE1\")\n2 atom HN\n3\natom HDE1\n4 >>> print(f\"atom {'HN':>4s}\") ; print(f\"atom {'HDE1':>4s}\")\n5 atom HN\n6\natom HDE1\nVous voyez tout de suite l’énorme avantage de l’écriture formatée. Elle vous permet d’écrire en colonnes parfaitement\nalignées. Nous verrons que ceci est très pratique si l’on veut écrire les coordonnées des atomes d’une molécule au format\nPDB (pour en savoir plus sur ce format, reportez-vous à l’annexe A Quelques formats de données en biologie).\nPour les floats, il est possible de combiner le nombre de caractères à aﬀicher avec le nombre de décimales :\n1 >>> print(f\"{perc_GC:7.3f}\")\n2\n47.804\n3 >>> print(f\"{perc_GC:10.3f}\")\n4\n47.804\nL’instruction signifie que l’on souhaite écrire un float avec 3 décimales et formaté sur 7 caractères (par défaut\n7.3f\njustifiés à droite). L’instruction fait la même chose sur 10 caractères. Remarquez que le séparateur décimal\n10.3f .\ncompte pour un caractère. De même, si on avait un nombre négatif, le signe compterait aussi pour un caractère.\n-\n3.3.4 Autres détails sur les f-strings\nSi on veut aﬀicher des accolades littérales avec les f-strings, il faut les doubler pour échapper au formatage :\n1 >>> print(f\"Accolades littérales {{}} ou {{ ou }} \"\n2\n... f\"et pour le formatage {10}\")\n3 Accolades littérales {} ou { ou } et pour le formatage 10\nUne remarque importante, si on ne met pas de variable à formater entre les accolades dans une f-string, cela conduit\nà une erreur :\n1 >>> print(f\"accolades sans variable {}\")\n2\nFile \"<stdin>\", line 1\n3 SyntaxError: f-string: empty expression not allowed\nEnfin, il est important de bien comprendre qu’une f-string est indépendante de la fonction . Si on donne\nprint()\nune f-string à la fonction , Python évalue d’abord la f-string et c’est la chaîne de caractères qui en résulte qui\nprint()\nest aﬀichée à l’écran. Tout comme dans l’instruction , c’est d’abord la multiplication ( ) qui est évaluée,\nprint(5*5) 5*5\npuis son résultat qui est aﬀiché à l’écran. On peut s’en rendre compte de la manière suivante dans l’interpréteur :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 29\nChapitre 3. Aﬀichage 3.4. Écriture scientifique\n1\n>>> f\"{perc_GC:10.3f}\"\n2 ' 47.804'\n3\n>>> type(f\"{perc_GC:10.3f}\")\n4 <class 'str'>\nPython considère le résultat de l’instruction comme une chaîne de caractères et la fonction\nf\"{perc_GC:10.3f}\"\nnous le confirme.\ntype()\n3.3.5 Expressions dans les f-strings\nUne fonctionnalité extrêmement puissante des f-strings est de supporter des expressions Python au sein des accolades.\nAinsi, il est possible d’y mettre directement une opération ou encore un appel à une fonction :\n1 >>> print(f\"Le résultat de 5 * 5 vaut {5 * 5}\")\n2\nLe résultat de 5 * 5 vaut 25\n3 >>> print(f\"Résultat d'une opération avec des floats : {(4.1 * 6.7)}\")\n4\nRésultat d'une opération avec des floats : 27.47\n5 >>> print(f\"Le minimum est {min(1, -2, 4)}\")\n6 Le minimum est -2\n7 >>> entier = 2\n8 >>> print(f\"Le type de {entier} est {type(entier)}\")\n9\nLe type de 2 est <class 'int'>\nNous aurons l’occasion de revenir sur cette fonctionnalité au fur et à mesure de ce cours.\nLes possibilités offertes par les f-strings sont nombreuses. Pour vous y retrouver dans les différentes options de\n1\nformatage, nous vous conseillons de consulter ce mémo (en anglais)."
  },
  {
    "title": "Écriture scientifique",
    "content": "Pour les nombres très grands ou très petits, l’écriture formatée permet d’aﬀicher un nombre en notation scientifique\n(sous forme de puissance de 10) avec la lettre :\ne\n1 >>> print(f\"{1_000_000_000:e}\")\n2\n1.000000e+09\n3 >>> print(f\"{0.000_000_001:e}\")\n4\n1.000000e-09\nIl est également possible de définir le nombre de chiffres après la virgule. Dans l’exemple ci-dessous, on aﬀiche un\nnombre avec aucun, 3 et 6 chiffres après la virgule :\n1\n>>> avogadro_number = 6.022_140_76e23\n2 >>> print(f\"{avogadro_number:.0e}\")\n3\n6e+23\n4 >>> print(f\"{avogadro_number:.3e}\")\n5\n6.022e+23\n6 >>> print(f\"{avogadro_number:.6e}\")\n7\n6.022141e+23"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour les exercices 2 à 6, utilisez l’interpréteur Python.\n3.5.1 Aﬀichage dans l’interpréteur et dans un programme\nOuvrez l’interpréteur Python et tapez l’instruction . Que se passe-t-il ?\n1+1\nÉcrivez la même chose dans un script que vous allez créer avec un éditeur de texte. Exécutez ce script en\ntest.py\ntapant dans un shell. Que se passe-t-il ? Pourquoi ? Faites en sorte d’aﬀicher le résultat de l’addition\npython test.py\nen exécutant le script dans un shell.\n1+1\n1. https://fstring.help/cheat/\n30 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n3.5. Exercices Chapitre 3. Aﬀichage\n3.5.2 Poly-A\nGénérez une chaîne de caractères représentant un brin d’ADN poly-A (c’est-à-dire qui ne contient que des bases A)\nde 20 bases de longueur, sans taper littéralement toutes les bases.\n3.5.3 Poly-A et poly-GC\nSur le modèle de l’exercice précédent, générez en une ligne de code un brin d’ADN poly-A (AAAA…) de 20 bases\nsuivi d’un poly-GC régulier (GCGCGC…) de 40 bases.\n3.5.4 Écriture formatée\nEn utilisant l’écriture formatée, aﬀichez en une seule ligne les variables , et dont les valeurs sont respectivement\na b c\nla chaîne de caractères , le nombre entier et le float . La variable sera aﬀichée avec deux décimales.\n\"salut\" 102 10.318 c\n3.5.5 Écriture formatée 2\nDans un script , calculez un pourcentage de GC avec l’instruction suivante :\npercGC.py\nperc_GC = ((4500 + 2575)/14800)*100\nEnsuite, aﬀichez le contenu de la variable à l’écran avec 0, 1, 2 puis 3 décimales sous forme arrondie en\nperc_GC\nutilisant l’écriture formatée et les f-strings. On souhaite que le programme aﬀiche la sortie suivante :\nLe pourcentage de GC est 48 %\nLe pourcentage de GC est 47.8 %\nLe pourcentage de GC est 47.80 %\nLe pourcentage de GC est 47.804 %\n3.5.6 Décomposition de fractions\nUtilisez l’opérateur modulo ( ) et l’opérateur division entière ( ) pour simplifier des fractions, connaissant leur\n% //\nnumérateur et leur dénominateur, et aﬀicher le résultat avec des f-strings.\n7\nPar exemple pour la fraction , le numérateur vaut 7 et le dénominateur vaut 3, et le résultat s’aﬀichera sous la\n3\nforme :\n7/3 = 2 + 1/3\nIci, 2 est le résultat de la division entière du numérateur par le dénominateur et 1 est le reste de la division entière du\nnumérateur par le dénominateur.\nFaites de même pour les fractions suivantes :\n9 23 21 7\n, , et\n4 5 8 2\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 31"
  },
  {
    "title": "Définition",
    "content": "Définition\nUne liste est une structure de données qui contient une collection d’objets Python. Il s’agit d’un nouveau type par\nrapport aux entiers, float, booléens et chaînes de caractères que nous avons vus jusqu’à maintenant. On parle aussi\nd’objet séquentiel en ce sens qu’il contient une séquence d’autres objets.\nPython autorise la construction de liste contenant des valeurs de types différents (par exemple entier et chaîne de\ncaractères), ce qui leur confère une grande flexibilité. Une liste est déclarée par une série de valeurs (n’oubliez pas les\nguillemets, simples ou doubles, s’il s’agit de chaînes de caractères) séparées par des virgules, et le tout encadré par des\ncrochets. En voici quelques exemples :\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> tailles = [5, 2.5, 1.75, 0.15]\n3 >>> mixte = [\"girafe\", 5, \"souris\", 0.15]\n4\n>>> animaux\n5 ['girafe', 'tigre', 'singe', 'souris']\n6\n>>> tailles\n7 [5, 2.5, 1.75, 0.15]\n8\n>>> mixte\n9 ['girafe', 5, 'souris', 0.15]\nLorsque l’on aﬀiche une liste, Python la restitue telle qu’elle a été saisie."
  },
  {
    "title": "Utilisation",
    "content": "Un des gros avantages d’une liste est que vous accédez à ses éléments par leur position. Ce numéro est appelé indice\n(ou index) de la liste.\nliste : [\"girafe\", \"tigre\", \"singe\", \"souris\"]\nindice : 0 1 2 3\n−\nSoyez très attentif au fait que les indices d’une liste de n éléments commencent à 0 et se terminent à n 1. Voyez\nl’exemple suivant :\n32\n4.3. Opération sur les listes Chapitre 4. Listes\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> animaux[0]\n3\n'girafe'\n4 >>> animaux[1]\n5\n'tigre'\n6 >>> animaux[3]\n7 'souris'\nPar conséquent, si on appelle l’élément d’indice 4 de notre liste, Python renverra un message d’erreur :\n1\n>>> animaux[4]\n2 Traceback (innermost last):\n3\nFile \"<stdin>\", line 1, in ?\n4 IndexError: list index out of range\nN’oubliez pas ceci ou vous risquez d’obtenir des bugs inattendus !"
  },
  {
    "title": "Opération sur les listes",
    "content": "Tout comme les chaînes de caractères, les listes supportent l’opérateur de concaténation, ainsi que l’opérateur\n+ *\npour la duplication :\n1\n>>> ani1 = [\"girafe\", \"tigre\"]\n2 >>> ani2 = [\"singe\", \"souris\"]\n3\n>>> ani1 + ani2\n4 ['girafe', 'tigre', 'singe', 'souris']\n5\n>>> ani1 * 3\n6 ['girafe', 'tigre', 'girafe', 'tigre', 'girafe', 'tigre']\nL’opérateur est très pratique pour concaténer deux listes.\n+\nVous pouvez aussi utiliser la méthode lorsque vous souhaitez ajouter un seul élément à la fin d’une liste.\n.append()\nRemarque\nLa notion de méthode est introduite dans la rubrique Note sur le vocabulaire et la syntaxe à la fin de ce chapitre.\nDans l’exemple suivant, nous allons créer une liste vide :\n1 >>> liste1 = []\n2\n>>> liste1\n3 []\npuis lui ajouter deux éléments, l’un après l’autre, d’abord avec la concaténation :\n1\n>>> liste1 = liste1 + [15]\n2 >>> liste1\n3 [15]\n4\n>>> liste1 = liste1 + [-5]\n5 >>> liste1\n6\n[15, -5]\npuis avec la méthode :\n.append()\n1 >>> liste1.append(13)\n2\n>>> liste1\n3 [15, -5, 13]\n4\n>>> liste1.append(-3)\n5 >>> liste1\n6 [15, -5, 13, -3]\nDans cet exemple, nous ajoutons des éléments à une liste en utilisant l’opérateur de concaténation ou la méthode\n+\n.\n.append()\nConseil\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 33\nChapitre 4. Listes 4.4. Indiçage négatif\nNous vous conseillons dans ce cas précis d’utiliser la méthode , dont la syntaxe est plus élégante.\n.append()\nNous reverrons en détail la méthode dans le chapitre 12 Plus sur les listes.\n.append()"
  },
  {
    "title": "Indiçage négatif",
    "content": "La liste peut également être indexée avec des nombres négatifs selon le modèle suivant :\nliste : [\"girafe\", \"tigre\", \"singe\", \"souris\"]\nindice positif : 0 1 2 3\nindice négatif : -4 -3 -2 -1\nou encore :\nliste : [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\nindice positif : 0 1 2 3 4 5\nindice négatif : -6 -5 -4 -3 -2 -1\nLes indices négatifs reviennent à compter à partir de la fin. Leur principal avantage est que vous pouvez accéder au\ndernier élément d’une liste à l’aide de l’indice sans pour autant connaître la longueur de cette liste. L’avant-dernier\n-1\nélément a lui l’indice , l’avant-avant dernier l’indice , etc. :\n-2 -3\n1 >>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2\n>>> animaux[-1]\n3 'souris'\n4 >>> animaux[-2]\n5 'singe'\nPour accéder au premier élément de la liste avec un indice négatif, il faut par contre connaître le bon indice :\n1 >>> animaux[-4]\n2\n'girafe'\nDans ce cas, on utilise plutôt .\nanimaux[0]"
  },
  {
    "title": "Tranches",
    "content": "Un autre avantage des listes est la possibilité de sélectionner une partie d’une liste en utilisant un indiçage construit\nsur le modèle pour récupérer tous les éléments, du émième au énième (de l’élément inclu à l’élément\n[m:n+1] m n+1\nexclu). On dit alors qu’on récupère une tranche de la liste, par exemple :\n1 >>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2\n>>> animaux[0:2]\n3 ['girafe', 'tigre']\n4\n>>> animaux[0:3]\n5 ['girafe', 'tigre', 'singe']\n6\n>>> animaux[0:]\n7 ['girafe', 'tigre', 'singe', 'souris']\n8\n>>> animaux[:]\n9 ['girafe', 'tigre', 'singe', 'souris']\n10\n>>> animaux[1:]\n11 ['tigre', 'singe', 'souris']\n12 >>> animaux[1:-1]\n13\n['tigre', 'singe']\nNotez que lorsqu’aucun indice n’est indiqué à gauche ou à droite du symbole deux-points , Python prend par défaut\n:\ntous les éléments depuis le début ou tous les éléments jusqu’à la fin respectivement.\nOn peut aussi préciser le pas en ajoutant un symbole deux-points supplémentaire et en indiquant le pas par un entier :\n34 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n4.6. Fonction Chapitre 4. Listes\nlen()\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> animaux[0:3:2]\n3\n['girafe', 'singe']\n4 >>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n5\n>>> x\n6 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n7 >>> x[::1]\n8\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n9 >>> x[::2]\n10\n[0, 2, 4, 6, 8]\n11 >>> x[::3]\n12\n[0, 3, 6, 9]\n13 >>> x[1:6:3]\n14\n[1, 4]\nFinalement, on se rend compte que l’accès au contenu d’une liste fonctionne sur le modèle .\nliste[début:fin:pas]"
  },
  {
    "title": "len()",
    "content": "L’instruction vous permet de connaître la longueur d’une liste, c’est-à-dire le nombre d’éléments que contient\nlen()\nla liste. Voici un exemple d’utilisation :\n1 >>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2\n>>> len(animaux)\n3 4\n4\n>>> len([1, 2, 3, 4, 5, 6, 7, 8])\n5 8"
  },
  {
    "title": "range() list()",
    "content": "L’instruction est une fonction spéciale en Python qui génère des nombres entiers compris dans un intervalle.\nrange()\nLorsqu’elle est utilisée en combinaison avec la fonction , on obtient une liste d’entiers. Par exemple :\nlist()\n1 >>> list(range(10))\n2 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nLa commande a généré une liste contenant tous les nombres entiers de 0 inclus à 10 exclu. Nous\nlist(range(10))\nverrons l’utilisation de la fonction toute seule dans le chapitre 5 Boucles et comparaisons.\nrange()\nDans l’exemple ci-dessus, la fonction a pris un argument, mais elle peut également prendre deux ou trois\nrange()\narguments, voyez plutôt :\n1 >>> list(range(0, 5))\n2\n[0, 1, 2, 3, 4]\n3 >>> list(range(15, 20))\n4\n[15, 16, 17, 18, 19]\n5 >>> list(range(0, 1000, 200))\n6\n[0, 200, 400, 600, 800]\n7 >>> list(range(2, -2, -1))\n8\n[2, 1, 0, -1]\nL’instruction fonctionne sur le modèle . Les arguments entre crochets sont\nrange() range([début,] fin[, pas])\noptionnels. Pour obtenir une liste de nombres entiers, il faut l’utiliser systématiquement avec la fonction .\nlist()\nEnfin, prenez garde aux arguments optionnels par défaut ( pour et pour ) :\n0 début 1 pas\n1\n>>> list(range(10,0))\n2 []\nIci la liste est vide car Python a pris la valeur du pas par défaut qui est de 1. Ainsi, si on commence à 10 et qu’on\navance par pas de 1, on ne pourra jamais atteindre 0. Python génère ainsi une liste vide. Pour éviter ça, il faudrait, par\nexemple, préciser un pas de -1 pour obtenir une liste d’entiers décroissants :\n1 >>> list(range(10,0,-1))\n2\n[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 35\nChapitre 4. Listes 4.8. Listes de listes"
  },
  {
    "title": "Listes de listes",
    "content": "Pour finir, sachez qu’il est tout à fait possible de construire des listes de listes. Cette fonctionnalité peut parfois être\ntrès pratique. Par exemple :\n1\n>>> prairie1 = [\"girafe\", 4]\n2 >>> prairie2 = [\"tigre\", 2]\n3\n>>> prairie3 = [\"singe\", 5]\n4 >>> savane = [prairie1, prairie2, prairie3]\n5\n>>> savane\n6 [['girafe', 4], ['tigre', 2], ['singe', 5]]\nDans cet exemple, chaque sous-liste contient une catégorie d’animal et le nombre d’animaux pour chaque catégorie.\nPour accéder à un élément de la liste, on utilise l’indiçage habituel :\n1\n>>> savane[1]\n2 ['tigre', 2]\nPour accéder à un élément de la sous-liste, on utilise un double indiçage :\n1 >>> savane[1][0]\n2\n'tigre'\n3 >>> savane[1][1]\n4 2\nOn verra un peu plus loin qu’il existe en Python des dictionnaires qui sont également très pratiques pour stocker\nde l’information structurée. On verra aussi qu’il existe un module nommé NumPy qui permet de créer des listes ou des\ntableaux de nombres (vecteurs et matrices) et de les manipuler."
  },
  {
    "title": "Minimum, maximum et somme d’une liste",
    "content": "Les fonctions , et renvoient respectivement le minimum, le maximum et la somme d’une liste\nmin() max() sum()\npassée en argument :\n1\n>>> liste1 = list(range(10))\n2 >>> liste1\n3 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n4\n>>> sum(liste1)\n5 45\n6\n>>> min(liste1)\n7 0\n8\n>>> max(liste1)\n9 9\nMême si en théorie ces fonctions peuvent prendre en argument une liste de strings, on les utilisera la plupart du temps\navec des types numériques (liste d’entiers et / ou de floats).\nNous avions déjà croisé , dans le chapitre 2 Variables. Ces deux fonctions pouvaient prendre plusieurs\nmin() max()\narguments entiers et / ou floats, par exemple :\n1 >>> min(3, 4)\n2\n3\nAttention toutefois à ne pas mélanger entiers et floats d’une part avec une liste d’autre part, car cela renvoie une\nerreur :\n1 >>> min(liste1, 3, 4)\n2\nTraceback (most recent call last):\n3 File \"<stdin>\", line 1, in <module>\n4\nTypeError: '<' not supported between instances of 'int' and 'list'\nSoit on passe plusieurs entiers et / ou floats en argument, soit on passe une liste unique."
  },
  {
    "title": "Problème avec les copies de listes",
    "content": "Nous attirons votre attention sur un comportement de Python qui peut paraitre étrange lorsqu’on copie une liste :\n36 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n4.11. Note sur le vocabulaire et la syntaxe Chapitre 4. Listes\n1\n>>> liste1 = list(range(5))\n2 >>> list(range(5))\n3\n>>> liste1\n4 [0, 1, 2, 3, 4]\n5\n>>> liste2 = liste1\n6 >>> liste2\n7 [0, 1, 2, 3, 4]\n8\n>>> liste1[3] = -50\n9 >>> liste1\n10\n[0, 1, 2, -50, 4]\n11 >>> liste2\n12\n[0, 1, 2, -50, 4]\nComme vous voyez en ligne 8, la modification de a modifié également . Cela vient du fait que Python\nliste1 liste2\na effectué la copie de liste en ligne 5 par référence. Ainsi, les deux listes pointent vers le même objet dans la mémoire.\nPour contrer ce problème et faire en sorte que soit bien distincte de , on peut utiliser la fonction :\nliste2 liste1 list()\n1\n>>> liste1 = list(range(5))\n2 >>> liste1\n3\n[0, 1, 2, 3, 4]\n4 >>> liste2 = list(liste1)\n5\n>>> liste2\n6 [0, 1, 2, 3, 4]\n7\n>>> liste1[3] = -50\n8 >>> liste1\n9 [0, 1, 2, -50, 4]\n10\n>>> liste2\n11 [0, 1, 2, 3, 4]\nAttention\nCette astuce ne fonctionne que pour des listes à une dimension (c’est-à-dire pour des listes qui ne contiennent que\ndes éléments de type simple comme des entiers, des floats, des chaînes de caractères et des booléens), mais pas pour des\nlistes de listes. Le chapitre 12 Plus sur les listes explique l’origine de ce comportement et comment s’en sortir à tous les\ncoups."
  },
  {
    "title": "Note sur le vocabulaire et la syntaxe",
    "content": "Revenons quelques instants sur la notion de méthode abordée dans ce chapitre avec . En Python, on peut\n.append()\nconsidérer chaque variable comme un objet sur lequel on peut appliquer des méthodes. Une méthode est simplement une\nfonction qui utilise et/ou agit sur l’objet lui-même, les deux étant connectés par un point. La syntaxe générale est de la\nforme .\nobjet.méthode()\nDans l’exemple suivant :\n1\n>>> liste1 = [1, 2]\n2 >>> liste1.append(3)\n3\n>>> liste1\n4 [1, 2, 3]\nla méthode est liée à qui est un objet de type liste. La méthode modifie l’objet liste en lui\n.append() liste1\najoutant un élément.\nNous aurons de nombreuses occasions de revoir cette notation .\nobjet.méthode()"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, utilisez l’interpréteur Python.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 37\nChapitre 4. Listes 4.12. Exercices\n4.12.1 Prédire la sortie\nSoit les trois lignes de code suivantes :\n1\nliste1 = list(range(10, 15))\n2 var = 0\n3\nvar2 = 10\nPrédisez le comportement de chaque instruction ci-dessous, sans les recopier dans un script ni dans l’interpréteur\nPython :\n•\nprint(liste1[2])\n•\nprint(liste1[var])\n•\nprint(liste1[var2])\n•\nprint(liste1[\"var\"])\nLorsqu’une instruction produit une erreur, identifiez pourquoi.\n4.12.2 Jours de la semaine\nConstituez une liste contenant les sept jours de la semaine.\nsemaine\n1. À partir de cette liste, comment récupérez-vous seulement les cinq premiers jours de la semaine d’une part, et ceux\ndu week-end d’autre part ? Utilisez pour cela l’indiçage.\n2. Cherchez un autre moyen pour arriver au même résultat (en utilisant un autre indiçage).\n3. Trouvez deux manières pour accéder au dernier jour de la semaine.\n4. Inversez les jours de la semaine en une commande.\n4.12.3 Saisons\nCréez quatre listes , , et contenant les mois correspondants à ces saisons. Créez\nhiver printemps ete automne\nensuite une liste contenant les listes , , et . Prévoyez ce que renvoient les\nsaisons hiver printemps ete automne\ninstructions suivantes, puis vérifiez-le dans l’interpréteur :\n1.\nsaisons[2]\n2.\nsaisons[1][0]\n3.\nsaisons[1:2]\n4. . Comment expliquez-vous ce dernier résultat ?\nsaisons[:][1]\n4.12.4 Table de multiplication par 9\nAﬀichez la table de multiplication par 9 en une seule commande avec les instructions et .\nrange() list()\n4.12.5 Nombres pairs\nRépondez à la question suivante en une seule commande. Combien y a-t-il de nombres pairs dans l’intervalle\n[2,\ninclus ?\n10000]\n38 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Boucles for",
    "content": "5.1.1 Principe\nEn programmation, on est souvent amené à répéter plusieurs fois une instruction. Incontournables à tout langage de\nprogrammation, les boucles vont nous aider à réaliser cette tâche répétitive de manière compacte et eﬀicace.\nImaginez par exemple que vous souhaitiez aﬀicher les éléments d’une liste les uns après les autres. Dans l’état actuel\nde vos connaissances, il faudrait taper quelque chose du style :\n1\nanimaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 print(animaux[0])\n3\nprint(animaux[1])\n4 print(animaux[2])\n5\nprint(animaux[3])\nSi votre liste ne contient que 4 éléments, ceci est encore faisable mais imaginez qu’elle en contienne 100 voire 1 000 !\nPour remédier à cela, il faut utiliser les boucles . Regardez l’exemple suivant :\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> for animal in animaux:\n3 ... print(animal)\n4\n...\n5 girafe\n6\ntigre\n7 singe\n8\nsouris\nCommentons en détails ce qu’il s’est passé dans cet exemple :\nLa variable est appelée variable d’itération , elle prend successivement les différentes valeurs de la liste\nanimal\nà chaque itérations (ou tour) de boucle. On verra un peu plus loin dans ce chapitre que l’on peut choisir le\nanimaux\nnom que l’on veut pour cette variable. Celle-ci est créée par Python la première fois que la ligne contenant le est\nfor\nexécutée (si elle existait déjà son contenu serait écrasé). Une fois la boucle terminée, cette variable d’itération\nanimal\nn’est pas détruite et conserve la dernière valeur de la liste (ici la chaîne de caractères ).\nanimaux \"souris\"\nNotez bien les types des variables utilisées ici :\n•\nest une liste sur laquelle on itère ;\nanimaux\n•\nest une chaîne de caractères car chaque élément de la liste est une chaîne de caractères.\nanimal animaux\n39\nChapitre 5. Boucles et comparaisons 5.1. Boucles\nfor\nNous verrons plus loin que la variable d’itération peut être de n’importe quel type selon la liste parcourue. En Python,\nune boucle itère la plupart du temps sur un objet dit séquentiel (c’est-à-dire un objet constitué d’autres objets) tel\nqu’une liste. De tels objets sont dits itérables car on peut effectuer une boucle dessus. Nous verrons aussi plus tard\nd’autres objets séquentiels sur lesquels on peut itérer dans une boucle.\nD’ores et déjà, prêtez attention au caractère deux-points « » à la fin de la ligne débutant par . Cela signifie\n: for\nque la boucle attend un bloc d’instructions, en l’occurrence toutes les instructions que Python répétera à chaque\nfor\nitération de la boucle. On appelle ce bloc d’instructions le corps de la boucle. Comment indique-t-on à Python où ce\nbloc commence et se termine ? Cela est signalé uniquement par l’indentation, c’est-à-dire le décalage vers la droite de\nla (ou des) ligne(s) du bloc d’instructions.\nRemarque\nLes notions de bloc d’instruction et d’indentations ont été introduites dans le chapitre 1 Introduction.\nDans l’exemple suivant, le corps de la boucle contient deux instructions (ligne 2 et ligne 3) car elles sont indentées\npar rapport à la ligne débutant par :\nfor\n1\nfor animal in animaux:\n2 print(animal)\n3\nprint(animal*2)\n4 print(\"C'est fini\")\nLa ligne 4 ne fait pas partie du corps de la boucle car elle est au même niveau que le (c’est-à-dire non indentée par\nfor\nrapport au ). Notez également que chaque instruction du corps de la boucle doit être indentée de la même manière\nfor\n(ici 4 espaces).\nRemarque\nOutre une meilleure lisibilité, les deux-points et l’indentation sont formellement requis en Python. Même si on\npeut indenter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les\ndéveloppeurs recommandent l’utilisation de quatre espaces. Vous pouvez consulter à ce sujet le chapitre 16 Bonnes\npratiques de programmation en Python.\nFaites en sorte de configurer votre éditeur de texte favori de façon à écrire quatre espaces lorsque vous tapez sur la\ntouche Tab (tabulation).\nSi on oublie l’indentation, Python renvoie un message d’erreur :\n1 >>> for animal in animaux:\n2\n... print(animal)\n3 File \"<stdin>\", line 2\n4\nprint(animal)\n5 ^\n6 IndentationError: expected an indented block\nDans les exemples ci-dessus, nous avons exécuté une boucle en itérant directement sur une liste. Une tranche d’une\nliste étant elle même une liste, on peut également itérer dessus :\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> for animal in animaux[1:3]:\n3\n... print(animal)\n4 ...\n5\ntigre\n6 singe\nOn a vu que les boucles pouvaient utiliser une liste contenant des chaînes de caractères, mais elles peuvent tout\nfor\naussi bien utiliser des listes contenant des entiers (ou n’importe quel type de variable) :\n40 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n5.1. Boucles Chapitre 5. Boucles et comparaisons\nfor\n1\n>>> for i in [1, 2, 3]:\n2 ... print(i)\n3\n...\n4 1\n5\n2\n6 3\n5.1.2 Fonction\nrange()\nPython possède la fonction que nous avons rencontrée précédemment dans le chapitre 4 Listes, pratique\nrange()\npour faire une boucle sur une liste d’entiers de manière automatique :\n1 >>> for i in range(4):\n2\n... print(i)\n3 ...\n4\n0\n5 1\n6\n2\n7 3\nDans cet exemple, nous pouvons faire plusieurs remarques importantes :\n•\nContrairement à la création de liste avec , la fonction peut être utilisée telle quelle dans\nlist(range(4)) range()\nune boucle. Il n’est pas nécessaire de taper même si cela fonctionnerait également.\nfor i in list(range(4)):\n•\n1\nComment cela est possible ? est une fonction qui a été spécialement conçue pour cela , c’est-à-dire\nrange()\nque l’on peut itérer directement dessus. Pour Python, il s’agit d’un nouveau type : par exemple dans l’instruction\n, la variable est de type range (tout comme on avait les types int, float, str ou list) à utiliser\nx = range(3) x\nspécialement avec les boucles.\n•\nL’instruction se contente de transformer un objet de type range en un objet de type list. Si vous\nlist(range(4))\nvous souvenez bien, il s’agit d’une fonction de casting, qui convertit un type en un autre (voir chapitre 2 Variables).\nIl n’y aucun intérêt à utiliser dans une boucle la construction . C’est même contre-\nfor i in list(range(4)):\nproductif. En effet, se contente de stocker l’entier actuel, le pas pour passer à l’entier suivant, et le\nrange()\ndernier entier à parcourir, ce qui revient à stocker seulement 3 nombres entiers et ce quelle que soit la longueur\nde la séquence, même avec un . Si on utilisait , Python construirait\nrange(1000000) list(range(1000000))\nd’abord une liste de 1 million d’éléments dans la mémoire puis itérerait dessus, d’où une énorme perte de temps !\n5.1.3 Nommage de la variable d’itération\nDans l’exemple précédent, nous avons choisi le nom pour la variable d’itération. Ceci est une habitude en informatique\ni\net indique en général qu’il s’agit d’un entier (le nom vient sans doute du mot indice ou index en anglais). Nous vous\ni\nconseillons de suivre cette convention afin d’éviter les confusions. Si vous itérez sur les indices, vous pouvez appeler la\nvariable d’itération (par exemple dans ).\ni for i in range(4):\nSi, par contre, vous itérez sur une liste comportant des chaînes de caractères (ou tout autre type de variable), utilisez\nun nom explicite pour la variable d’itération. Par exemple :\nfor prenom in [\"Joe\", \"Bill\", \"John\"]:\nou\nfor proportion in [0.12, 0.53, 0.07, 0.28]:\n5.1.4 Itération sur les indices ou les éléments\nRevenons à notre liste . Nous allons maintenant parcourir cette liste, mais cette fois par une itération sur\nanimaux\nses indices :\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> for i in range(4):\n3\n... print(animaux[i])\n4 ...\n5\ngirafe\n6 tigre\n7 singe\n8\nsouris\n1. https://docs.python.org/fr/3/library/stdtypes.html#typesseq-range\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 41\nChapitre 5. Boucles et comparaisons 5.2. Comparaisons\nLa variable prendra les valeurs successives 0, 1, 2 et 3 et on accèdera à chaque élément de la liste par son\ni animaux\nindice (i.e. ). Notez à nouveau le nom de la variable d’itération car on itère sur les indices.\nanimaux[i] i\nQuand utiliser l’une ou l’autre des deux méthodes ? La plus eﬀicace est celle qui réalise les itérations directement\nsur les éléments :\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> for animal in animaux:\n3\n... print(animal)\n4 ...\n5 girafe\n6\ntigre\n7 singe\n8\nsouris\nRemarque\nDans le chapitre 18 Jupyter et ses notebooks, nous mesurerons le temps d’exécution de ces deux méthodes pour vous\nmontrer que l’itération sur les éléments est la méthode la plus rapide.\nToutefois, il se peut qu’au cours d’une boucle vous ayez besoin des indices, auquel cas vous devrez itérer sur les\nindices :\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> for i in range(len(animaux)):\n3\n... print(f\"L'animal {i} est un(e) {animaux[i]}\")\n4 ...\n5\nL'animal 0 est un(e) girafe\n6 L'animal 1 est un(e) tigre\n7\nL'animal 2 est un(e) singe\n8 L'animal 3 est un(e) souris\nEnfin, Python possède la fonction qui vous permet d’itérer sur les indices et les éléments eux-mêmes :\nenumerate()\n1\n>>> animaux = [\"girafe\", \"tigre\", \"singe\", \"souris\"]\n2 >>> for i, animal in enumerate(animaux):\n3\n... print(f\"L'animal {i} est un(e) {animal}\")\n4 ...\n5\nL'animal 0 est un(e) girafe\n6 L'animal 1 est un(e) tigre\n7 L'animal 2 est un(e) singe\n8\nL'animal 3 est un(e) souris"
  },
  {
    "title": "Comparaisons",
    "content": "Avant de passer aux boucles , abordons tout de suite les comparaisons. Celles-ci seront reprises dans le chapitre\nwhile\n6 Tests.\nPython est capable d’effectuer toute une série de comparaisons entre le contenu de deux variables, telles que :\nOpérateur de comparaison Signification\négal à\n==\ndifférent de\n!=\nstrictement supérieur à\n>\nsupérieur ou égal à\n>=\nstrictement inférieur à\n<\ninférieur ou égal à\n<=\nObservez les exemples suivants avec des nombres entiers :\n42 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n5.3. Boucles Chapitre 5. Boucles et comparaisons\nwhile\n1\n>>> x = 5\n2 >>> x == 5\n3\nTrue\n4 >>> x > 10\n5\nFalse\n6 >>> x < 10\n7 True\nPython renvoie la valeur si la comparaison est vraie et si elle est fausse. et sont des booléens\nTrue False True False\ncomme nous avions vu au chapitre 2 Variables.\nFaites bien attention à ne pas confondre l’opérateur d’affectation qui affecte une valeur à une variable et\n=\nl’opérateur de comparaison qui compare les valeurs de deux variables.\n==\nVous pouvez également effectuer des comparaisons sur des chaînes de caractères.\n1 >>> animal = \"tigre\"\n2\n>>> animal == \"tig\"\n3 False\n4\n>>> animal != \"tig\"\n5 True\n6\n>>> animal == \"tigre\"\n7 True\nDans le cas des chaînes de caractères, a priori seuls les tests et ont un sens. En fait, on peut aussi utiliser les\n== !=\nopérateurs , , et . Dans ce cas, l’ordre alphabétique est pris en compte, par exemple :\n< > <= >=\n1 >>> \"a\" < \"b\"\n2\nTrue\nest inférieur à car le caractère a est situé avant le caractère b dans l’ordre alphabétique. En fait, c’est\n\"a\" \"b\"\n2\nl’ordre ASCII des caractères qui est pris en compte (à chaque caractère correspond un code numérique), on peut donc\naussi comparer des caractères spéciaux (comme ou ) entre eux. Enfin, on peut comparer des chaînes de caractères de\n# ~\nplusieurs caractères :\n1\n>>> \"ali\" < \"alo\"\n2 True\n3\n>>> \"abb\" < \"ada\"\n4 True\nDans ce cas, Python compare les deux chaînes de caractères, caractère par caractère, de la gauche vers la droite (le\npremier caractère avec le premier, le deuxième avec le deuxième, etc). Dès qu’un caractère est différent entre l’une et\nl’autre des deux chaînes, il considère que la chaîne la plus petite est celle qui présente le caractère ayant le plus petit\ncode ASCII (les caractères suivants de la chaîne de caractères sont ignorés dans la comparaison), comme dans l’exemple\nci-dessus.\n\"abb\" < \"ada\""
  },
  {
    "title": "while",
    "content": "Une alternative à l’instruction couramment utilisée en informatique est la boucle . Avec ce type de boucle,\nfor while\nune série d’instructions est exécutée tant qu’une condition est vraie. Par exemple :\n1\n>>> i = 1\n2 >>> while i <= 4:\n3\n... print(i)\n4 ... i = i + 1\n5 ...\n6 1\n7 2\n8\n3\n9 4\nRemarquez qu’il est encore une fois nécessaire d’indenter le bloc d’instructions correspondant au corps de la boucle\n(ici, les instructions lignes 3 et 4).\n2. http://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 43\nChapitre 5. Boucles et comparaisons 5.4. Exercices\nUne boucle nécessite généralement trois éléments pour fonctionner correctement :\nwhile\n1. Initialisation de la variable d’itération avant la boucle (ligne 1).\n2. Test de la variable d’itération associée à l’instruction (ligne 2).\nwhile\n3. Mise à jour de la variable d’itération dans le corps de la boucle (ligne 4).\nFaites bien attention aux tests et à l’incrémentation que vous utilisez, car une erreur mène souvent à des « boucles\ninfinies » qui ne s’arrêtent jamais. Vous pouvez néanmoins toujours stopper l’exécution d’un script Python à l’aide de la\ncombinaison de touches Ctrl-C (c’est-à-dire en pressant simultanément les touches Ctrl et C). Par exemple :\n1 i = 0\n2\nwhile i < 10:\n3 print(\"Le Python c'est cool !\")\nIci, nous avons omis de mettre à jour la variable dans le corps de la boucle. Par conséquent, la boucle ne s’arrêtera\ni\njamais (sauf en pressant Ctrl-C) puisque la condition sera toujours vraie.\ni < 10\nLa boucle combinée à la fonction peut s’avérer commode lorsqu’on souhaite demander à l’utilisateur\nwhile input()\nune valeur numérique. Par exemple :\n1\n>>> i = 0\n2 >>> while i < 10:\n3\n... reponse = input(\"Entrez un entier supérieur à 10 : \")\n4 ... i = int(reponse)\n5 ...\n6\nEntrez un entier supérieur à 10 : 4\n7 Entrez un entier supérieur à 10 : -3\n8\nEntrez un entier supérieur à 10 : 15\n9 >>> i\n10\n15\nLa fonction prend en argument un message (sous la forme d’une chaîne de caractères), demande à l’utilisateur\ninput()\nd’entrer une valeur et renvoie celle-ci sous forme d’une chaîne de caractères, qu’il faut ensuite convertir en entier (avec\nla fonction ligne 4). Si on reprend les trois éléments d’une boucle while, on trouve l’initialisation de la variable\nint()\nd’itération en ligne 1, le test de sa valeur en ligne 2, et sa mise à jour en ligne 4.\nConseil\nComment choisir entre la boucle while et la boucle for ? La boucle while s’utilisera généralement lorsqu’on ne sait pas\nà l’avance le nombre d’itérations (comme dans le dernier exemple). Si on connait à l’avance le nombre d’itérations, par\nexemple si on veut écrire 10 fois , nous vous conseillons la boucle for.\nLe Python c'est cool"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n5.4.1 Boucles de base\nSoit la liste . Aﬀichez l’ensemble des éléments de cette liste (un\n[\"vache\", \"souris\", \"levure\", \"bacterie\"]\nélément par ligne) de trois façons différentes (deux méthodes avec et une avec ).\nfor while\n5.4.2 Boucles et jours de la semaine\nConstituez une liste contenant les 7 jours de la semaine.\nsemaine\nÉcrivez une série d’instructions aﬀichant les jours de la semaine (en utilisant une boucle ), ainsi qu’une autre série\nfor\nd’instructions aﬀichant les jours du week-end (en utilisant une boucle ).\nwhile\n44 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n5.4. Exercices Chapitre 5. Boucles et comparaisons\n5.4.3 Nombres de 1 à 10 sur une ligne\nAvec une boucle, aﬀichez les nombres de 1 à 10 sur une seule ligne.\nConseil\nPensez à relire le début du chapitre 3 Aﬀichage qui discute de la fonction .\nprint()\n5.4.4 Nombres pairs et impairs\nSoit la liste de nombres . Écrivez un programme qui, à\nimpairs [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]\npartir de la liste , construit une liste dans laquelle tous les éléments de sont incrémentés de 1.\nimpairs pairs impairs\n5.4.5 Calcul de la moyenne\nVoici les notes d’un étudiant . Calculez la moyenne de ces notes. Utilisez l’écriture formatée\n[14, 9, 6, 8, 12]\npour aﬀicher la valeur de la moyenne avec deux décimales.\n5.4.6 Produit de nombres consécutifs\nAvec les fonctions et , créez la liste contenant les nombres entiers pairs de 2 à 20 inclus.\nlist() range() entiers\nCalculez ensuite le produit des nombres consécutifs deux à deux de en utilisant une boucle. Exemple pour\nentiers\nles premières itérations :\n8\n24\n48\n[...]\n5.4.7 Triangle\nCréez un script qui dessine un triangle comme celui-ci :\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n5.4.8 Triangle inversé\nCréez un script qui dessine un triangle comme celui-ci :\n**********\n*********\n********\n*******\n******\n*****\n****\n***\n**\n*\n5.4.9 Triangle gauche\nCréez un script qui dessine un triangle comme celui-ci :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 45\nChapitre 5. Boucles et comparaisons 5.4. Exercices\n*\n**\n***\n****\n*****\n******\n*******\n********\n*********\n**********\n5.4.10 Pyramide\nCréez un script qui dessine une pyramide comme celle-ci :\npyra.py\n*\n***\n*****\n*******\n*********\n***********\n*************\n***************\n*****************\n*******************\nEssayez de faire évoluer votre script pour dessiner la pyramide à partir d’un nombre arbitraire de lignes . Vous\nN\npourrez demander à l’utilisateur le nombre de lignes de la pyramide avec les instructions suivantes qui utilisent la fonction\n:\ninput()\n1\nreponse = input(\"Entrez un nombre de lignes (entier positif): \")\n2 N = int(reponse)\n5.4.11 Parcours de matrice\nImaginons que l’on souhaite parcourir tous les éléments d’une matrice carrée, c’est-à-dire d’une matrice qui est\nconstituée d’autant de lignes que de colonnes.\nCréez un script qui parcourt chaque élément de la matrice et qui aﬀiche le numéro de ligne et de colonne uniquement\navec des boucles .\nfor\n×\nPour une matrice de dimensions 2 2, le schéma de la figure 5.1 vous indique comment parcourir une telle matrice.\nL’aﬀichage attendu est :\nligne colonne\n1 1\n1 2\n2 1\n2 2\nAttention à bien respecter l’alignement des chiffres qui doit être justifié à droite sur 4 caractères. Testez avec une\n× × ×\nmatrice de dimensions 3 3, puis 5 5, et enfin 10 10.\nCréez une seconde version de votre script, cette fois-ci avec deux boucles .\nwhile\n5.4.12 Parcours de demi-matrice sans la diagonale (exercice ++)\nEn se basant sur le script précédent, on souhaite réaliser le parcours d’une demi-matrice carrée sans la diagonale. On\npeut noter que cela produit tous les couples possibles une seule fois (1 et 2 est équivalent à 2 et 1), en excluant par\nailleurs chaque élément avec lui même (1 et 1, 2 et 2, etc). Pour mieux comprendre ce qui est demandé, la figure 5.2\nindique les cases à parcourir en gris :\n×\nCréez un script qui aﬀiche le numéro de ligne et de colonne, puis la taille de la matrice N N et le nombre total de\n×\ncases parcourues. Par exemple pour une matrice 4 4 (N=4) :\n46 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n5.4. Exercices Chapitre 5. Boucles et comparaisons\nFigure 5.1 – Parcours d’une matrice.\nFigure 5.2 – Demi-matrice sans la diagonale (en gris).\nligne colonne\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\nPour une matrice 4x4, on a parcouru 6 cases\nTestez votre script avec , puis et enfin .\nN=3 N=4 N=5\nConcevez une seconde version à partir du script précédent, où cette fois on n’aﬀiche plus tous les couples possibles,\nmais simplement la valeur de et le nombre de cases parcourues. Aﬀichez cela pour des valeurs de allant de 2 à 10.\nN N\nPouvez-vous trouver une formule générale reliant le nombre de cases parcourues à ?\nN\n5.4.13 Sauts de puce\nOn imagine une puce qui se déplace aléatoirement sur une ligne, en avant ou en arrière, par pas de 1 ou -1. Par\nexemple, si elle est à l’emplacement 0, elle peut sauter à l’emplacement 1 ou -1 ; si elle est à l’emplacement 2, elle peut\nsauter à l’emplacement 3 ou 1, etc.\nAvec une boucle , simulez le mouvement de cette puce de l’emplacement initial 0 à l’emplacement final 5 (voir\nwhile\nle schéma de la figure 5.3). Combien de sauts sont nécessaires pour réaliser ce parcours ? Relancez plusieurs fois le\nprogramme. Trouvez-vous le même nombre de sauts à chaque exécution ?\nConseil\nUtilisez l’instruction qui renvoie au hasard les valeurs -1 ou 1 avec la même probabilité.\nrandom.choice([-1,1])\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 47\nChapitre 5. Boucles et comparaisons 5.4. Exercices\nFigure 5.3 – Sauts de puce.\nAvant d’utiliser cette instruction, mettez au tout début de votre script la ligne\nimport random\nNous verrons la signification de cette syntaxe particulière dans le chapitre 9 Modules.\n5.4.14 Suite de Fibonacci (exercice +++)\n3\nLa suite de Fibonacci est une suite mathématique qui porte le nom de Leonardo Fibonacci, un mathématicien italien\ne\ndu XIII siècle. Initialement, cette suite a été conçue pour décrire la croissance d’une population de lapins, mais elle\npeut également être utilisée pour décrire certains motifs géométriques retrouvés dans la nature (coquillages, fleurs de\ntournesol…).\n− −\nPour la suite de Fibonacci ( ), le terme au rang n (avec > ) est la somme des nombres aux rangs et :\nx n 1 n 1 n 2\nn\nx = x +x\n− −\nn n 1 n 2\nPar définition, les deux premiers termes sont x = 0 et x = 1.\n0 1\nÀ titre d’exemple, les 10 premiers termes de la suite de Fibonacci sont donc 0, 1, 1, 2, 3, 5, 8, 13, 21 et 34.\nCréez un script qui construit une liste avec les 15 premiers termes de la suite de Fibonacci puis l’aﬀiche.\nfibo\nAméliorez ce script en aﬀichant, pour chaque élément de la liste avec n > 1, le rapport entre l’élément de rang\nfibo\n−\nn et l’élément de rang n 1. Ce rapport tend-il vers une constante ? Si oui, laquelle ?\n3. https://fr.wikipedia.org/wiki/Suite_de_Fibonacci\n48 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Définition",
    "content": "Les tests sont un élément essentiel à tout langage informatique si on veut lui donner un peu de complexité car ils\npermettent à l’ordinateur de prendre des décisions. Pour cela, Python utilise l’instruction ainsi qu’une comparaison\nif\nque nous avons abordée au chapitre précédent. Voici un premier exemple :\n1 >>> x = 2\n2\n>>> if x == 2:\n3 ... print(\"Le test est vrai !\")\n4\n...\n5 Le test est vrai !\net un second :\n1 >>> x = \"souris\"\n2\n>>> if x == \"tigre\":\n3 ... print(\"Le test est vrai !\")\n4 ...\nIl y a plusieurs remarques à faire concernant ces deux exemples :\n•\nDans le premier exemple, l’instruction est exécutée, car le test est vrai. Dans le\nprint(\"Le test est vrai !\")\nsecond exemple, le test est faux et rien n’est aﬀiché.\n•\nLes blocs d’instructions dans les tests doivent forcément être indentés comme pour les boucles et .\nfor while\nL’indentation indique la portée des instructions à exécuter si le test est vrai.\n•\nComme avec les boucles et , la ligne qui contient l’instruction se termine par le caractère deux-points\nfor while if\n« ».\n:"
  },
  {
    "title": "Tests à plusieurs cas",
    "content": "Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une même instruction . Plutôt\nif\nque d’utiliser deux instructions , on peut se servir des instructions et :\nif if else\n49\nChapitre 6. Tests 6.3. Importance de l’indentation\n1\n>>> x = 2\n2 >>> if x == 2:\n3\n... print(\"Le test est vrai !\")\n4 ... else:\n5\n... print(\"Le test est faux !\")\n6 ...\n7 Le test est vrai !\n8\n>>> x = 3\n9 >>> if x == 2:\n10\n... print(\"Le test est vrai !\")\n11 ... else:\n12\n... print(\"Le test est faux !\")\n13 ...\n14\nLe test est faux !\nOn peut utiliser une série de tests dans la même instruction , notamment pour tester plusieurs valeurs d’une même\nif\nvariable.\nPar exemple, on se propose de tirer au sort une base d’ADN puis d’aﬀicher le nom de cette dernière. Dans le code\nsuivant, nous utilisons l’instruction qui renvoie un élément choisi au hasard dans une liste.\nrandom.choice(liste)\nL’instruction sera vue plus tard dans le chapitre 9 Modules, admettez pour le moment qu’elle est\nimport random\nnécessaire :\n1\n>>> import random\n2 >>> base = random.choice([\"a\", \"t\", \"c\", \"g\"])\n3 >>> if base == \"a\":\n4 ... print(\"choix d'une adénine\")\n5 ... elif base == \"t\":\n6\n... print(\"choix d'une thymine\")\n7 ... elif base == \"c\":\n8\n... print(\"choix d'une cytosine\")\n9 ... elif base == \"g\":\n10\n... print(\"choix d'une guanine\")\n11 ...\n12\nchoix d'une cytosine\nDans cet exemple, Python teste la première condition puis, si et seulement si elle est fausse, teste la deuxième et ainsi\nde suite… Le code correspondant à la première condition vérifiée est exécuté puis Python sort du bloc d’instructions du\n. Il est également possible d’ajouter une condition supplémentaire qui est exécutée si aucune des conditions du\nif else\net des n’est vraie.\nif elif"
  },
  {
    "title": "Importance de l’indentation",
    "content": "De nouveau, faites bien attention à l’indentation ! Vous devez être très rigoureux sur ce point. Pour vous en convaincre,\nexécutez ces deux exemples de code :\nCode 1\n1 nombres = [4, 5, 6]\n2\nfor nb in nombres:\n3 if nb == 5:\n4 print(\"Le test est vrai\")\n5\nprint(f\"car la variable nb vaut {nb}\")\nRésultat :\nLe test est vrai\ncar la variable nb vaut 5\n50 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n6.4. Tests multiples Chapitre 6. Tests\nCode 2\n1\nnombres = [4, 5, 6]\n2 for nb in nombres:\n3\nif nb == 5:\n4 print(\"Le test est vrai\")\n5\nprint(f\"car la variable nb vaut {nb}\")\nRésultat :\ncar la variable nb vaut 4\nLe test est vrai\ncar la variable nb vaut 5\ncar la variable nb vaut 6\nLes deux codes pourtant très similaires produisent des résultats très différents. Si vous observez avec attention\nl’indentation des instructions sur la ligne 5, vous remarquerez que dans le code 1, l’instruction est indentée deux fois,\nce qui signifie qu’elle appartient au bloc d’instructions du test . Dans le code 2, l’instruction de la ligne 5 n’est\nif\nindentée qu’une seule fois, ce qui fait qu’elle n’appartient plus au bloc d’instructions du test , d’où l’aﬀichage de\nif\npour toutes les valeurs de .\ncar la variable nb vaut xx nb"
  },
  {
    "title": "Tests multiples",
    "content": "Les tests multiples permettent de tester plusieurs conditions en même temps en utilisant des opérateurs booléens. Les\ndeux opérateurs les plus couramment utilisés sont OU et ET. Voici un petit rappel sur le fonctionnement de l’opérateur\nOU :\nCondition 1 Opérateur Condition 2 Résultat\nVrai OU Vrai Vrai\nVrai OU Faux Vrai\nFaux OU Vrai Vrai\nFaux OU Faux Faux\net de l’opérateur ET :\nCondition 1 Opérateur Condition 2 Résultat\nVrai ET Vrai Vrai\nVrai ET Faux Faux\nFaux ET Vrai Faux\nFaux ET Faux Faux\nEn Python, on utilise le mot réservé pour l’opérateur ET et le mot réservé pour l’opérateur OU. Respectez\nand or\nbien la casse des opérateurs et qui, en Python, s’écrivent en minuscule. En voici un exemple d’utilisation :\nand or\n1 >>> x = 2\n2\n>>> y = 2\n3 >>> if x == 2 and y == 2:\n4\n... print(\"le test est vrai\")\n5 ...\n6 le test est vrai\nNotez que le même résultat serait obtenu en utilisant deux instructions imbriquées :\nif\n1\n>>> x = 2\n2 >>> y = 2\n3\n>>> if x == 2:\n4 ... if y == 2:\n5\n... print(\"le test est vrai\")\n6 ...\n7\nle test est vrai\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 51\nChapitre 6. Tests 6.5. Instructions et\nbreak continue\nConseil\nNous vous conseillons la syntaxe avec un qui est plus compacte. De manière générale, moins il y a de niveau\nand\nd’indentations mieux c’est pour la lisibilité.\nVous pouvez aussi tester directement l’effet de ces opérateurs à l’aide de et (attention à respecter la\nTrue False\ncasse) :\n1\n>>> True or False\n2 True\nEnfin, on peut utiliser l’opérateur logique de négation qui inverse le résultat d’une condition :\nnot\n1 >>> not True\n2\nFalse\n3 >>> not False\n4\nTrue\n5 >>> not (True and True)\n6 False"
  },
  {
    "title": "break continue",
    "content": "Ces deux instructions modifient le comportement d’une boucle ( ou ) avec un test. Ainsi, l’instruction\nfor while\nstoppe la boucle en cours :\nbreak\n1 >>> for nombre in range(4):\n2\n... if nombre > 1:\n3 ... break\n4\n... print(nombre)\n5 ...\n6 0\n7\n1\nL’instruction saute à l’itération suivante, sans exécuter la suite du bloc d’instructions de la boucle :\ncontinue\n1 >>> for nombre in range(4):\n2\n... if nombre == 2:\n3 ... continue\n4\n... print(nombre)\n5 ...\n6 0\n7\n1\n8 3"
  },
  {
    "title": "Tests de valeur sur des floats",
    "content": "Lorsque l’on souhaite tester la valeur d’une variable de type float, le premier réflexe serait d’utiliser l’opérateur d’égalité\ncomme :\n1\n>>> 1/10 == 0.1\n2 True\nToutefois, nous vous le déconseillons formellement. Pourquoi ? Python stocke les valeurs numériques des floats sous\n1\nforme de nombres flottants (d’où leur nom), et cela mène à certaines limitations . Observez l’exemple suivant :\n1 >>> (3 - 2.7) == 0.3\n2\nFalse\n3 >>> 3 - 2.7\n4\n0.2999999999999998\nNous voyons que le résultat de l’opération n’est pas exactement d’où le résultat en ligne 2.\n3 - 2.7 0.3 False\nEn fait, ce problème ne vient pas de Python, mais plutôt de la manière dont un ordinateur traite les nombres flottants\n(comme un rapport de nombres binaires). Ainsi certaines valeurs de float ne peuvent être qu’approchées. Une manière\n1. https://docs.python.org/fr/3/tutorial/floatingpoint.html\n52 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n6.7. Exercices Chapitre 6. Tests\nde s’en rendre compte est d’utiliser l’écriture formatée en demandant l’aﬀichage d’un grand nombre de décimales :\n1 >>> 0.3\n2\n0.3\n3 >>> f\"{0.3:.5f}\"\n4\n'0.30000'\n5 >>> f\"{0.3:.60f}\"\n6 '0.299999999999999988897769753748434595763683319091796875000000'\n7\n>>> var = 3 - 2.7\n8 >>> f\"{var:.60f}\"\n9\n'0.299999999999999822364316059974953532218933105468750000000000'\n10 >>> abs(var - 0.3)\n11\n1.6653345369377348e-16\nOn observe que lorsqu’on tape , Python aﬀiche une valeur arrondie. En réalité, le nombre réel ne peut être\n0.3 0.3\nqu’approché lorsqu’on le code en nombre flottant. Il est essentiel d’avoir cela en tête lorsque l’on compare deux floats.\nMême si et ne donnent pas le même résultat, la différence est toutefois infinétisimale, de l’ordre de\n0.3 3 - 2.7 1e-16\nme\nsoit la 16 décimale !\nPour ces raisons, il ne faut surtout pas utiliser l’opérateur pour tester si un float est égal à une certaine valeur, car\n==\ncet opérateur correspond à une égalité stricte. La bonne pratique est de vérifier si un float est compris dans un intervalle\navec une certaine précision. Si on appelle cette précision delta, on peut procéder ainsi :\n1 >>> delta = 1e-5\n2\n>>> var = 3.0 - 2.7\n3 >>> 0.3 - delta < var < 0.3 + delta\n4 True\n5\n>>> abs(var - 0.3) < delta\n6 True\n±\nIci on teste si est compris dans l’intervalle 0.3 delta. En choisissant delta à , on teste jusqu’à la cinquième\nvar 1e-5\ndécimale. Les deux méthodes mènent à un résultat strictement équivalent :\n•\nLa ligne 3 est plus intuitive car elle ressemble à un encadrement mathématique.\n•\nLa ligne 5 utilise la fonction valeur absolue et est plus compacte.\nabs()\nUne dernière manière pour tester la valeur d’un float, apparue en Python 3.5, est d’utiliser la fonction\nmath.isclose\n:\n()\n1 >>> import math\n2 >>> var = 3.0 - 2.7\n3\n>>> math.isclose(var, 0.3, abs_tol=1e-5)\n4 True\nCette fonction prend en argument les deux floats à comparer, ainsi que l’argument par mot-clé correspondant\nabs_tol\nà la précision souhaitée (que nous avions appelée ci-dessus). Nous vous conseillons de toujours préciser cet argument\ndelta\n. Comme vu au dessus pour tirer une base au hasard, l’instruction sera vue dans le chapitre 9\nabs_tol import math\nModules, admettez pour le moment qu’elle est nécessaire.\nConseil\nSur les trois manières de procéder pour comparer un float à une valeur, nous vous conseillons celle avec\nmath.\nqui nous parait la plus lisible.\nisclose()"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 53\nChapitre 6. Tests 6.7. Exercices\n6.7.1 Jours de la semaine\nConstituez une liste contenant le nom des sept jours de la semaine.\nsemaine\nEn utilisant une boucle, écrivez chaque jour de la semaine ainsi que les messages suivants :\n•\ns’il s’agit du lundi au jeudi ;\nAu travail\n•\ns’il s’agit du vendredi ;\nChouette c'est vendredi\n•\ns’il s’agit du samedi ou du dimanche.\nRepos ce week-end\nCes messages ne sont que des suggestions, vous pouvez laisser libre cours à votre imagination.\n6.7.2 Séquence complémentaire d’un brin d’ADN\nLa liste ci-dessous représente la séquence d’un brin d’ADN :\n[\"A\", \"C\", \"G\", \"T\", \"T\", \"A\", \"G\", \"C\", \"T\", \"A\", \"A\", \"C\", \"G\"]\nCréez un script qui transforme cette séquence en sa séquence complémentaire.\nRappel : la séquence complémentaire s’obtient en remplaçant A par T, T par A, C par G et G par C.\n6.7.3 Minimum d’une liste\nLa fonction de Python renvoie l’élément le plus petit d’une liste constituée de valeurs numériques ou de chaînes\nmin()\nde caractères. Sans utiliser cette fonction, créez un script qui détermine le plus petit élément de la liste .\n[8, 4, 6, 1, 5]\n6.7.4 Fréquence des acides aminés\nLa liste ci-dessous représente une séquence d’acides aminés :\n[\"R\", \"A\", \"W\", \"W\", \"A\", \"W\", \"A\", \"R\", \"W\", \"W\", \"R\", \"A\", \"G\"]\nCalculez la fréquence des acides aminés alanine (A), arginine (R), tryptophane (W) et glycine (G) dans cette séquence.\n6.7.5 Notes et mention d’un étudiant\nVoici les notes d’un étudiant : 14, 9, 13, 15 et 12. Créez un script qui aﬀiche la note maximum (utilisez la fonction\n), la note minimum (utilisez la fonction ) et qui calcule la moyenne.\nmax() min()\nAﬀichez la valeur de la moyenne avec deux décimales. Aﬀichez aussi la mention obtenue sachant que la mention est\n« passable » si la moyenne est entre 10 inclus et 12 exclus, « assez bien » entre 12 inclus et 14 exclus et « bien » au-delà\nde 14.\n6.7.6 Nombres pairs\nConstruisez une boucle qui parcourt les nombres de 0 à 20 et qui aﬀiche les nombres pairs inférieurs ou égaux à 10\nd’une part, et les nombres impairs strictement supérieurs à 10 d’autre part.\nPour cet exercice, vous pourrez utiliser l’opérateur modulo qui renvoie le reste de la division entière entre deux\n%\nnombres et dont voici quelques exemples d’utilisation :\n1 >>> 4 % 3\n2\n1\n3 >>> 5 % 3\n4\n2\n5 >>> 4 % 2\n6 0\n7\n>>> 6 % 2\n8 0\nVous remarquerez qu’un nombre est pair lorsque le reste de sa division entière par 2 est nul.\n6.7.7 Conjecture de Syracuse (exercice +++)\n2\nLa conjecture de Syracuse est une conjecture mathématique qui reste improuvée à ce jour et qui est définie de la\nmanière suivante.\nSoit un entier positif n. Si n est pair, alors le diviser par 2. S’il est impair, alors le multiplier par 3 et lui ajouter 1.\nEn répétant cette procédure, la suite de nombres atteint la valeur 1 puis se prolonge indéfiniment par une suite de trois\nvaleurs triviales appelée cycle trivial.\n2. http://fr.wikipedia.org/wiki/Conjecture_de_Syracuse\n54 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n6.7. Exercices Chapitre 6. Tests\nJusqu’à présent, la conjecture de Syracuse, selon laquelle depuis n’importe quel entier positif la suite de Syracuse\natteint 1, n’a pas été mise en défaut.\nPar exemple, les premiers éléments de la suite de Syracuse si on prend comme point de départ 10 sont : 10, 5, 16, 8,\n4, 2, 1…\nCréez un script qui, partant d’un entier positif n (par exemple 10 ou 20), crée une liste des nombres de la suite de\nSyracuse. Avec différents points de départ (c’est-à-dire avec différentes valeurs de n), la conjecture de Syracuse est-elle\ntoujours vérifiée ? Quels sont les nombres qui constituent le cycle trivial ?\nConseil\n1. Pour cet exercice, vous avez besoin de faire un nombre d’itérations inconnu pour que la suite de Syracuse atteigne le\nchiffre 1 puis entame son cycle trivial. Vous pourrez tester votre algorithme avec un nombre arbitraire d’itérations,\ntypiquement 20 ou 100, suivant votre nombre n de départ.\n2. Un nombre est pair lorsque le reste de sa division entière (opérateur modulo ) par 2 est nul.\n%\n6.7.8 Attribution de la structure secondaire des acides aminés d’une protéine (exercice\n+++)\nDans une protéine, les différents acides aminés sont liés entre eux par une liaison peptidique. Les angles phi et psi sont\ndeux angles mesurés autour de cette liaison peptidique. Leurs valeurs sont utiles pour définir la conformation spatiale\n(appelée « structure secondaire ») adoptée par les acides aminés.\nPar exemple, les angles phi et psi d’une conformation en « hélice alpha » parfaite ont une valeur de -57 degrés et -47\ndegrés respectivement. Bien sûr, il est très rare que l’on trouve ces valeurs parfaites dans une protéine, et il est habituel\n±\nde tolérer une déviation de 30 degrés autour des valeurs idéales de ces angles.\nVous trouverez ci-dessous une liste de listes contenant les valeurs des angles phi et psi de 15 acides aminés de la\n3\nprotéine 1TFE :\n1 [[48.6, 53.4],[-124.9, 156.7],[-66.2, -30.8], \\\n2\n[-58.8, -43.1],[-73.9, -40.6],[-53.7, -37.5], \\\n3 [-80.6, -26.0],[-68.5, 135.0],[-64.9, -23.5], \\\n4\n[-66.9, -45.5],[-69.6, -41.0],[-62.7, -37.5], \\\n5 [-68.2, -38.3],[-61.2, -49.1],[-59.7, -41.1]]\nPour le premier acide aminé, l’angle phi vaut 48.6 et l’angle psi 53.4. Pour le deuxième, l’angle phi vaut -124.9 et\nl’angle psi 156.7, etc.\nEn utilisant cette liste, créez un script qui teste, pour chaque acide aminé, s’il est ou non en hélice et aﬀiche les\nvaleurs des angles phi et psi et le message adapté est en hélice ou n’est pas en hélice.\nPar exemple, pour les trois premiers acides aminés :\n[48.6, 53.4] n'est pas en hélice\n[-124.9, 156.7] n'est pas en hélice\n[-66.2, -30.8] est en hélice\nD’après vous, quelle est la structure secondaire majoritaire de ces 15 acides aminés ?\nRemarque\nPour en savoir plus sur le monde merveilleux des protéines, n’hésitez pas à consulter la page Wikipedia sur la structure\n4\nsecondaire des protéines .\n6.7.9 Détermination des nombres premiers inférieurs à 100 (exercice +++)\n5\nVoici un extrait de l’article sur les nombres premiers tiré de l’encyclopédie en ligne Wikipédia :\n3.\nhttps://www.rcsb.org/structure/1TFE\n4. https://fr.wikipedia.org/wiki/Structure_des_prot%C3%A9ines#Angles_di%C3%A8dres_et_structure_\nsecondaire\n5. http://fr.wikipedia.org/wiki/Nombre_premier\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 55\nChapitre 6. Tests 6.7. Exercices\nUn nombre premier est un entier naturel qui admet exactement deux diviseurs distincts entiers et positifs (qui sont\nalors 1 et lui-même). Cette définition exclut 1, qui n’a qu’un seul diviseur entier positif. Par opposition, un nombre non\n×\nnul produit de deux nombres entiers différents de 1 est dit composé. Par exemple 6 = 2 3 est composé, tout comme\n×\n= , mais 11 est premier car 1 et 11 sont les seuls diviseurs de 11. Les nombres 0 et 1 ne sont ni premiers ni\n21 3 7\ncomposés.\nDéterminez tous les nombres premiers inférieurs à 100. Combien y a-t-il de nombres premiers entre 0 et 100 ? Pour\nvous aider, nous vous proposons plusieurs méthodes.\nMéthode 1 (peu optimale, mais assez intuitive)\nPour chaque nombre N de 2 à 100, calculez le reste de la division entière (avec l’opérateur modulo ) depuis 1 jusqu’à\n%\nlui-même. Si N est premier, il aura exactement deux nombres pour lesquels le reste de la division entière est égal à 0 (1\net lui-même). Si N n’est pas premier, il aura plus de deux nombres pour lesquels le reste de la division entière est égal à\n0.\nMéthode 2 (quelques petites optimisations qui font gagner du temps)\nOn reprend la méthode 1 avec deux petites optimisations. On sait que tout entier N supérieur à 1 est divisible par\n1 et par lui-même. Ainsi, il est inutile de tester ces deux diviseurs. On propose donc de tester tous les diviseurs de 2 à\n−\nN 1. Si on ne trouve aucun diviseur, alors N est premier. À partir du moment où on trouve un diviseur, il est inutile\nde continuer à chercher d’autres diviseurs car ne sera pas premier. On suggère ainsi de stopper la boucle (pensez à\nN\n). Vous pourrez aussi utiliser une variable drapeau comme qui sera à si N est premier, sinon\nbreak est_premier True\nà .\nFalse\nMéthode 3 (plus optimale et rapide, mais un peu plus compliquée)\nParcourez tous les nombres N de 2 à 100 et vérifiez si ceux-ci sont composés, c’est-à-dire s’ils sont le produit de deux\nnombres premiers. Pratiquement, cela consiste à vérifier que le reste de la division entière (opérateur modulo ) entre N\n%\net chaque nombre premier déterminé jusqu’à maintenant est nul. Le cas échéant, N n’est pas premier.\n6.7.10 Recherche d’un nombre par dichotomie (exercice +++)\n6\nLa recherche par dichotomie est une méthode qui consiste à diviser (en général en parties égales) un problème pour\nen trouver la solution. À titre d’exemple, voici une discussion entre Pierre et Patrick dans laquelle Pierre essaie de deviner\nle nombre (compris entre 1 et 100 inclus) auquel Patrick a pensé :\n•\n[Patrick] « C’est bon, j’ai pensé à un nombre entre 1 et 100. »\n•\n[Pierre] « OK, je vais essayer de le deviner. Est-ce que ton nombre est plus petit ou plus grand que 50 ? »\n•\n[Patrick] « Plus grand. »\n•\n[Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 75 ? »\n•\n[Patrick] « Plus grand. »\n•\n[Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 87 ? »\n•\n[Patrick] « Plus petit. »\n•\n[Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 81 ? »\n•\n[Patrick] « Plus petit. »\n•\n[Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 78 ? »\n•\n[Patrick] « Plus grand. »\n•\n[Pierre] « Est-ce que ton nombre est plus petit, plus grand ou égal à 79 ? »\n•\n[Patrick] « Égal. C’est le nombre auquel j’avais pensé. Bravo ! »\nPour arriver rapidement à deviner le nombre, l’astuce consiste à prendre à chaque fois la moitié de l’intervalle dans\nlequel se trouve le nombre. Voici le détail des différentes étapes :\n1. Le nombre se trouve entre 1 et 100, on propose 50 (100 / 2).\n2. Le nombre se trouve entre 50 et 100, on propose 75 ( 50 + (100-50)/2 ).\n3. Le nombre se trouve entre 75 et 100, on propose 87 ( 75 + (100-75)/2 ).\n6. https://fr.wikipedia.org/wiki/Dichotomie\n56 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n6.7. Exercices Chapitre 6. Tests\n4. Le nombre se trouve entre 75 et 87, on propose 81 ( 75 + (87-75)/2 ).\n5. Le nombre se trouve entre 75 et 81, on propose 78 ( 75 + (81-75)/2 ).\n6. Le nombre se trouve entre 78 et 81, on propose 79 ( 78 + (81-78)/2 ).\nCréez un script qui reproduit ce jeu de devinettes. Vous pensez à un nombre entre 1 et 100 et l’ordinateur essaie de\nle deviner par dichotomie en vous posant des questions.\nVotre programme utilisera la fonction pour interagir avec l’utilisateur. Voici un exemple de son fonctionne-\ninput()\nment :\n1 >>> lettre = input(\"Entrez une lettre : \")\n2\nEntrez une lettre : P\n3 >>> print(lettre)\n4 P\nPour vous guider, voici ce que donnerait le programme avec la conversation précédente :\nPensez à un nombre entre 1 et 100.\nEst-ce votre nombre est plus grand, plus petit ou égal à 50 ? [+/-/=] +\nEst-ce votre nombre est plus grand, plus petit ou égal à 75 ? [+/-/=] +\nEst-ce votre nombre est plus grand, plus petit ou égal à 87 ? [+/-/=] -\nEst-ce votre nombre est plus grand, plus petit ou égal à 81 ? [+/-/=] -\nEst-ce votre nombre est plus grand, plus petit ou égal à 78 ? [+/-/=] +\nEst-ce votre nombre est plus grand, plus petit ou égal à 79 ? [+/-/=] =\nJ'ai trouvé en 6 questions !\nLes caractères indiquent à l’utilisateur comment il doit interagir avec l’ordinateur, c’est-à-dire entrer soit le\n[+/-/=]\ncaractère si le nombre choisi est plus grand que le nombre proposé par l’ordinateur, soit le caractère si le nombre\n+ -\nchoisi est plus petit que le nombre proposé par l’ordinateur, soit le caractère si le nombre choisi est celui proposé par\n=\nl’ordinateur (en appuyant ensuite sur la touche Entrée).\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 57"
  },
  {
    "title": "Lecture dans un fichier",
    "content": "Une grande partie de l’information en biologie est stockée sous forme de texte dans des fichiers. Pour traiter cette\ninformation, vous devez le plus souvent lire ou écrire dans un ou plusieurs fichiers. Python possède pour cela de nombreux\noutils qui vous simplifient la vie.\n7.1.1 Méthode\n.readlines()\nAvant de passer à un exemple concret, créez un fichier dans l’éditeur de texte de votre choix avec le contenu suivant :\ngirafe\ntigre\nsinge\nsouris\nEnregistrez ce fichier dans votre répertoire courant avec le nom . Puis, testez le code suivant dans\nanimaux.txt\nl’interpréteur Python :\n1 >>> filin = open(\"animaux.txt\", \"r\")\n2\n>>> filin\n3 <_io.TextIOWrapper name='animaux.txt' mode='r' encoding='UTF-8'>\n4\n>>> filin.readlines()\n5 ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n']\n6 >>> filin.close()\n7\n>>> filin.readlines()\n8 Traceback (most recent call last):\n9\nFile \"<stdin>\", line 1, in <module>\n10 ValueError: I/O operation on closed file.\nIl y a plusieurs commentaires à faire sur cet exemple :\n•\nLigne 1. La fonction ouvre le fichier . Ce fichier est ouvert en lecture seule, comme l’indique\nopen() animaux.txt\nle second argument (pour read) de . Remarquez que le fichier n’est pas encore lu, mais simplement ouvert\nr open()\n(un peu comme lorsqu’on ouvre un livre, mais qu’on ne l’a pas encore lu). Le curseur de lecture est prêt à lire le\npremier caractère du fichier. L’instruction suppose que le fichier est\nopen(\"animaux.txt\", \"r\") animaux.txt\ndans le répertoire depuis lequel l’interpréteur Python a été lancé. Si ce n’est pas le cas, il faut préciser le chemin\nd’accès au fichier. Par exemple, pour Linux ou Mac OS X ou\n/home/pierre/animaux.txt C:\\Users\\pierre\npour Windows.\n\\animaux.txt\n58\n7.1. Lecture dans un fichier Chapitre 7. Fichiers\n•\nLigne 2. Lorsqu’on aﬀiche le contenu de la variable , on se rend compte que Python la considère comme un\nfilin\nobjet de type fichier ouvert (ligne 3).\n•\nLigne 4. Nous utilisons à nouveau la syntaxe (présentée dans le chapitre 3 Aﬀichage). Ici la\nobjet.méthode()\nméthode agit sur l’objet en déplaçant le curseur de lecture du début à la fin du fichier, puis\n.readlines() filin\nelle renvoie une liste contenant toutes les lignes du fichier (dans notre analogie avec un livre, ceci correspondrait à\nlire toutes les lignes du livre).\n•\nLigne 6. Enfin, on applique la méthode sur l’objet , ce qui, vous vous en doutez, ferme le fichier\n.close() filin\n(ceci reviendrait à fermer le livre). Vous remarquerez que la méthode ne renvoie rien, mais modifie l’état\n.close()\nde l’objet en fichier fermé. Ainsi, si on essaie de lire à nouveau les lignes du fichier, Python renvoie une\nfilin\nerreur, car il ne peut pas lire un fichier fermé (lignes 7 à 10).\nVoici maintenant un exemple complet de lecture d’un fichier avec Python :\n1\n>>> filin = open(\"animaux.txt\", \"r\")\n2 >>> lignes = filin.readlines()\n3\n>>> lignes\n4 ['girafe\\n', 'tigre\\n', 'singe\\n', 'souris\\n']\n5\n>>> for ligne in lignes:\n6 ... print(ligne)\n7\n...\n8 girafe\n9\n10 tigre\n11\n12\nsinge\n13\n14\nsouris\n15\n16\n>>> filin.close()\nVous voyez qu’en cinq lignes de code, vous avez lu, parcouru le fichier et aﬀiché son contenu.\nRemarque\n•\nChaque élément de la liste est une chaîne de caractères. C’est en effet sous forme de chaînes de caractères\nlignes\nque Python lit le contenu d’un fichier.\n•\nChaque élément de la liste se termine par le caractère . Ce caractère un peu particulier correspond au «\nlignes \\n\n1\nsaut de ligne » qui permet de passer d’une ligne à la suivante (en anglais line feed). Ceci est codé par un caractère\nspécial que l’on représente par . Vous pourrez parfois rencontrer également la notation octale . Dans la\n\\n \\012\nsuite de cet ouvrage, nous emploierons aussi l’expression « retour à la ligne » que nous trouvons plus intuitive.\n•\nPar défaut, l’instruction aﬀiche quelque chose puis revient à la ligne. Ce retour à la ligne dû à\nprint() print()\nse cumule alors avec celui de la fin de ligne ( ) de chaque ligne du fichier et donne l’impression qu’une ligne est\n\\n\nsautée à chaque fois.\nIl existe en Python le mot-clé qui permet d’ouvrir et de fermer un fichier de manière eﬀicace. Si pour une raison\nwith\nou une autre l’ouverture ou la lecture du fichier conduit à une erreur, l’utilisation de garantit la bonne fermeture\nwith\ndu fichier, ce qui n’est pas le cas dans le code précédent. Voici donc le même exemple avec :\nwith\n1. https://fr.wikipedia.org/wiki/Saut_de_ligne\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 59\nChapitre 7. Fichiers 7.1. Lecture dans un fichier\n1\n>>> with open(\"animaux.txt\", 'r') as filin:\n2 ... lignes = filin.readlines()\n3\n... for ligne in lignes:\n4 ... print(ligne)\n5\n...\n6 girafe\n7\n8\ntigre\n9\n10\nsinge\n11\n12\nsouris\n13\n14\n>>>\nRemarque\n•\nL’instruction introduit un bloc d’instructions qui doit être indenté. C’est à l’intérieur de ce bloc que nous\nwith\neffectuons toutes les opérations sur le fichier.\n•\nUne fois sorti du bloc d’instructions, Python fermera automatiquement le fichier. Vous n’avez donc plus besoin\nd’utiliser la méthode .\n.close()\n7.1.2 Méthode\n.read()\nIl existe d’autres méthodes que pour lire (et manipuler) un fichier. Par exemple, la méthode\n.readlines() .read()\nlit tout le contenu d’un fichier et renvoie une chaîne de caractères unique :\n1 >>> with open(\"animaux.txt\", \"r\") as filin:\n2\n... filin.read()\n3 ...\n4\n'girafe\\ntigre\\nsinge\\nsouris\\n'\n5 >>>\n7.1.3 Méthode\n.readline()\nLa méthode (sans à la fin) lit une ligne d’un fichier et la renvoie sous forme de chaîne de caractères.\n.readline() s\nÀ chaque nouvel appel de , la ligne suivante est renvoyée. Associée à la boucle , cette méthode\n.readline() while\npermet de lire un fichier ligne par ligne :\n1 >>> with open(\"animaux.txt\", \"r\") as filin:\n2\n... ligne = filin.readline()\n3 ... while ligne != \"\":\n4\n... print(ligne)\n5 ... ligne = filin.readline()\n6\n...\n7 girafe\n8\n9 tigre\n10\n11 singe\n12\n13\nsouris\n14\n15\n>>>\n7.1.4 Itérations directes sur le fichier\nPython essaie de vous faciliter la vie au maximum. Voici un moyen à la fois simple et élégant de parcourir un fichier :\n60 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n7.2. Écriture dans un fichier Chapitre 7. Fichiers\n1\n>>> with open(\"animaux.txt\", \"r\") as filin:\n2 ... for ligne in filin:\n3\n... print(ligne)\n4 ...\n5\ngirafe\n6\n7 tigre\n8\n9 singe\n10\n11 souris\n12\n13 >>>\nL’objet est « itérable », ainsi la boucle va demander à Python d’aller lire le fichier ligne par ligne.\nfilin for\nConseil\nPrivilégiez cette méthode par la suite.\nRemarque\nLes méthodes abordées précédemment permettent d’accéder au contenu d’un fichier, soit ligne par ligne (méthode\n), soit globalement en une seule chaîne de caractères (méthode ), soit globalement avec les lignes\n.readline() .read()\ndifférenciées sous forme d’une liste de chaînes de caractères (méthode ). Il est également possible en\n.readlines()\nPython de se rendre à un endroit particulier d’un fichier avec la méthode mais qui sort du cadre de cet ouvrage.\n.seek()"
  },
  {
    "title": "Écriture dans un fichier",
    "content": "Écrire dans un fichier est aussi simple que de le lire. Voyez l’exemple suivant :\n1 >>> animaux2 = [\"poisson\", \"abeille\", \"chat\"]\n2\n>>> with open(\"animaux2.txt\", \"w\") as filout:\n3 ... for animal in animaux2:\n4\n... filout.write(animal)\n5 ...\n6 7\n7\n7\n8 4\nQuelques commentaires sur cet exemple :\n•\nLigne 1. Création d’une liste de chaînes de caractères .\nanimaux2\n•\nLigne 2. Ouverture du fichier en mode écriture, avec le caractère pour write. L’instruction\nanimaux2.txt w with\ncrée un bloc d’instructions qui doit être indenté.\n•\nLigne 3. Parcours de la liste avec une boucle .\nanimaux2 for\n•\nLigne 4. À chaque itération de la boucle, nous avons écrit chaque élément de la liste dans le fichier. La méthode\ns’applique sur l’objet . Notez qu’à chaque utilisation de la méthode , celle-ci nous\n.write() filout .write()\naﬀiche le nombre d’octets (équivalent au nombre de caractères) écrits dans le fichier (lignes 6 à 8). Ceci est\nvalable uniquement dans l’interpréteur. Si vous créez un programme avec les mêmes lignes de code, ces valeurs ne\ns’aﬀicheront pas à l’écran.\nSi nous ouvrons le fichier avec un éditeur de texte, voici ce que nous obtenons :\nanimaux2.txt\npoissonabeillechat\nCe n’est pas exactement le résultat attendu car implicitement nous voulions le nom de chaque animal sur une ligne.\nNous avons oublié d’ajouter le caractère fin de ligne après chaque nom d’animal.\nPour ce faire, nous pouvons utiliser l’écriture formatée :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 61\nChapitre 7. Fichiers 7.3. Ouvrir deux fichiers avec l’instruction\nwith\n1\n>>> animaux2 = [\"poisson\", \"abeille\", \"chat\"]\n2 >>> with open(\"animaux2.txt\", \"w\") as filout:\n3\n... for animal in animaux2:\n4 ... filout.write(f\"{animal}\\n\")\n5\n...\n6 8\n7 8\n8\n5\n•\nLigne 4. L’écriture formatée, vue au chapitre 3 Aﬀichage, permet d’ajouter un retour à la ligne ( ) après le nom\n\\n\nde chaque animal.\n•\nLignes 6 à 8. Le nombre d’octets écrits dans le fichier est augmenté de 1 par rapport à l’exemple précédent, car\nle caractère retour à la ligne compte pour un seul octet.\nLe contenu du fichier est alors :\nanimaux2.txt\npoisson\nabeille\nchat\nVous voyez qu’il est relativement simple en Python de lire ou d’écrire dans un fichier."
  },
  {
    "title": "Ouvrir deux fichiers avec l’instruction with",
    "content": "On peut avec l’instruction ouvrir deux fichiers (ou plus) en même temps. Voyez l’exemple suivant :\nwith\n1\nwith open(\"animaux.txt\", \"r\") as fichier1, open(\"animaux2.txt\", \"w\") as fichier2:\n2 for ligne in fichier1:\n3\nfichier2.write(\"* \" + ligne)\nSi le fichier contient le texte suivant :\nanimaux.txt\nsouris\ngirafe\nlion\nsinge\nalors le contenu de sera :\nanimaux2.txt\n* souris\n* girafe\n* lion\n* singe\nDans cet exemple, permet une notation très compacte en s’affranchissant de deux méthodes .\nwith .close()\nSi vous souhaitez aller plus loin, sachez que l’instruction est plus générale et peut être utilisée dans d’autres\nwith\n2\ncontextes ."
  },
  {
    "title": "Note sur les retours à la ligne sous Unix et sous Windows",
    "content": "Conseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nOn a vu plus haut que le caractère spécial correspondait à un retour à la ligne. C’est le standard sous Unix (Mac\n\\n\nOS X et Linux).\nToutefois, Windows utilise deux caractères spéciaux pour le retour à la ligne : correspondant à un retour chariot\n\\r\n(hérité des machines à écrire) et comme sous Unix.\n\\n\nSi vous avez commencé à programmer en Python 2, vous aurez peut-être remarqué que, selon les versions, la lecture\n3\nde fichier supprimait parfois les et d’autres fois les laissait. Heureusement, la fonction dans Python 3 gère\n\\r open()\n2.\nhttps://docs.python.org/fr/3/reference/compound_stmts.html#the-with-statement\n3. https://docs.python.org/fr/3/library/functions.html#open\n62 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n7.5. Importance des conversions de types avec les fichiers Chapitre 7. Fichiers\ntout ça automatiquement et renvoie uniquement des sauts de ligne sous forme d’un seul (même si le fichier a été\n\\n\nconçu sous Windows et qu’il contient initialement des ).\n\\r"
  },
  {
    "title": "Importance des conversions de types avec les fichiers",
    "content": "Vous avez sans doute remarqué que les méthodes qui lisent un fichier (par exemple ) vous renvoient\n.readlines()\nsystématiquement des chaînes de caractères. De même, pour écrire dans un fichier, il faut fournir une chaîne de caractères\nà la méthode .\n.write()\nPour tenir compte de ces contraintes, il faudra utiliser les fonctions de conversion de types vues au chapitre 2\nVariables : , et . Ces fonctions de conversion sont essentielles lorsqu’on lit ou écrit des nombres\nint() float() str()\ndans un fichier.\nEn effet, les nombres dans un fichier sont considérés comme du texte, donc comme des chaînes de caractères, par la\nméthode . Par conséquent, il faut les convertir (en entier ou en float) si on veut effectuer des opérations\n.readlines()\nnumériques avec."
  },
  {
    "title": "Du respect des formats de données et de fichiers",
    "content": "Maintenant que vous savez lire et écrire des fichiers en Python, vous êtes capables de manipuler beaucoup d’information\nen biologie. Prenez garde cependant aux formats de fichiers, c’est-à-dire à la manière dont est stockée l’information\nbiologique dans des fichiers. Nous vous renvoyons pour cela à l’annexe A Quelques formats de données en biologie."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n7.7.1 Moyenne des notes\n4\nLe fichier contient les notes obtenues par des étudiants pour le cours de Python. Chaque ligne du fichier\nnotes.txt\nne contient qu’une note.\nTéléchargez le fichier et enregistrez-le dans votre répertoire de travail. N’hésitez pas à l’ouvrir avec un\nnotes.txt\néditeur de texte pour voir à quoi il ressemble.\nCréez un script Python qui lit chaque ligne de ce fichier, extrait les notes sous forme de float et les stocke dans une\nliste.\nTerminez le script en calculant et aﬀichant la moyenne des notes avec deux décimales.\n7.7.2 Admis ou recalé\nTéléchargez le fichier de l’exercice précédent et enregistrez-le dans votre répertoire de travail. N’hésitez\nnotes.txt\npas l’ouvrir avec un éditeur de texte pour voir à quoi il ressemble.\nCréez un script Python qui lit chaque ligne de ce fichier, extrait les notes sous forme de float et les stocke dans une\nliste.\nLe script réécrira ensuite les notes dans le fichier avec une note par ligne suivie de « recalé » si la note\nnotes2.txt\nest inférieure à 10 et « admis » si la note est supérieure ou égale à 10. Toutes les notes seront écrites avec une décimale.\nÀ titre d’exemple, voici les trois premières lignes attendues pour le fichier :\nnotes2.txt\n13.5 admis\n17.0 admis\n9.5 recalé\n7.7.3 Spirale (exercice +++)\nCréez un script qui calcule les coordonnées cartésiennes d’une spirale à deux dimensions.\nspirale.py\n4. https://python.sdv.u-paris.fr/data-files/notes.txt\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 63\nChapitre 7. Fichiers 7.7. Exercices\nθ\nLes coordonnées cartésiennes x et y d’un point A sur un cercle de rayon r s’expriment en fonction de l’angle\nA A\nreprésenté sur la figure 7.1 comme :\nθ ×\nx = cos( ) r\nA\nθ ×\ny = ( ) r\nsin\nA\nFigure 7.1 – Point A de coordonnées ( , ) sur le cercle de rayon .\nx y r\nA A\nPour calculer les coordonnées cartésiennes qui décrivent la spirale, vous allez faire varier deux variables en même\ntemps :\n• θ π\nl’angle , qui va prendre des valeurs de 0 à 4 radians par pas de 0,1, ce qui correspond à deux tours complets ;\n•\nle rayon du cercle r, qui va prendre comme valeur initiale 0,5 puis que vous allez incrémenter (c’est-à-dire augmenter)\npar pas de 0,1.\nLes fonctions trigonométriques sinus et cosinus sont disponibles dans le module math que vous découvrirez plus en\ndétails dans le chapitre 9 Modules. Pour les utiliser, vous ajouterez au début de votre script l’instruction :\nimport math\nLa fonction sinus sera et la fonction cosinus . Ces deux fonctions prennent comme argument\nmath.sin() math.cos()\nπ\nune valeur d’angle en radian. La constante mathématique sera également accessible grâce à ce module via .\nmath.pi\nPar exemple :\n1\n>>> math.sin(0)\n2 0.0\n3\n>>> math.sin(math.pi/2)\n4 1.0\n5\n>>> math.cos(math.pi)\n6 -1.0\nSauvegardez ensuite les coordonnées cartésiennes dans le fichier en respectant le format suivant :\nspirale.dat\n•\nun couple de coordonnées (x et y ) par ligne ;\nA A\n•\nau moins un espace entre les deux coordonnées x et y ;\nA A\n•\nles coordonnées aﬀichées sur 10 caractères avec 5 chiffres après la virgule.\nLes premières lignes de devrait ressembler à :\nspirale.dat\n64 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n7.7. Exercices Chapitre 7. Fichiers\n0.50000 0.00000\n0.59700 0.05990\n0.68605 0.13907\n0.76427 0.23642\n0.82895 0.35048\n0.87758 0.47943\n[...] [...]\nUne fois que vous avez généré le fichier , visualisez votre spirale avec le code suivant (que vous pouvez\nspirale.dat\nrecopier dans un autre script ou à la suite de votre script ) :\nspirale.py\n1 import matplotlib.pyplot as plt\n2\n3\nx = []\n4 y = []\n5\nwith open(\"spirale.dat\", \"r\") as f_in:\n6 for line in f_in:\n7\ncoords = line.split()\n8 x.append(float(coords[0]))\n9\ny.append(float(coords[1]))\n10\n11\nfig, ax = plt.subplots(figsize=(8,8))\n12 mini = min(x+y) - 2\n13\nmaxi = max(x+y) + 2\n14 ax.set_xlim(mini, maxi)\n15 ax.set_ylim(mini, maxi)\n16 ax.plot(x, y)\n17 fig.savefig(\"spirale.png\")\nVisualisez l’image ainsi créée.\nspirale.png\nRemarque\nLe module matplotlib est utilisé ici pour la visualisation de la spirale. Son utilisation est détaillée dans le chapitre 21\nModule matplotlib.\nθ\nEssayez de jouer sur les paramètres et r, et leur pas d’incrémentation, pour construire de nouvelles spirales.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 65"
  },
  {
    "title": "Dictionnaires et tuples",
    "content": "Dans ce chapitre, nous allons voir deux nouveaux types d’objet qui s’avèrent extrêmement utiles : les dictionnaires et\nles tuples. Comme les listes vues dans le chapitre 4, les dictionnaires et tuples contiennent une collection d’autres objets.\nToutefois, nous verrons que ces trois types sont régis par des règles différentes pour accéder à leur contenu, ainsi que\ndans leur fonctionnement."
  },
  {
    "title": "Dictionnaires",
    "content": "8.1.1 Définition et fonctionnement\nDéfinition\nUn dictionnaire contient une collection d’objets Python auxquels on accède à l’aide d’une clé de correspondance\nplutôt qu’un indice. Ainsi, il ne s’agit pas d’objets séquentiels comme les listes, mais plutôt d’objets dits de correspondance\n(mapping objects en anglais) ou tableaux associatifs.\nCeci étant défini, comment fonctionnent-ils exactement ? Regardons un exemple :\n1\n>>> animal1 = {}\n2 >>> animal1[\"nom\"] = \"girafe\"\n3\n>>> animal1[\"taille\"] = 5.0\n4 >>> animal1[\"poids\"] = 1100\n5\n>>> animal1\n6 {'nom': 'girafe', 'taille': 5.0, 'poids': 1100}\n•\nLigne 1. On définit un dictionnaire vide avec les accolades (tout comme on peut le faire pour les listes avec\n{}\n).\n[]\n•\nLignes 2 à 4. On remplit le dictionnaire avec plusieurs clés ( , , ) auxquelles on affecte\n\"nom\" \"taille\" \"poids\"\ndes valeurs ( , , ).\n\"girafe\" 5.0 1100\n•\nLigne 5. On aﬀiche le contenu du dictionnaire. Les accolades nous montrent qu’il s’agit bien d’un dictionnaire,\net pour chaque élément séparé par une virgule on a une association du type . Ici, les clés sont des\nclé: valeur\nchaînes de caractères (ce qui sera souvent le cas), et les valeurs peuvent être n’importe quel objet Python.\nUne fois le dictionnaire créé, on récupère la valeur associée à une clé donnée avec une syntaxe du type\ndictionnaire\n. Par exemple :\n[\"clé\"]\n66\n8.1. Dictionnaires Chapitre 8. Dictionnaires et tuples\n1\n>>> animal1[\"nom\"]\n2 'girafe'\n3\n>>> animal1[\"taille\"]\n4 5.0\nOn se souvient que pour accéder à l’élément d’une liste, il fallait utiliser un indice (par exemple, ). Ici,\nliste[2]\nl’utilisation d’une clé (qui est souvent une chaîne de caractères) rend les choses plus explicites.\nVous pouvez mettre autant de couples clé / valeur que vous voulez dans un dictionnaire (tout comme vous pouvez\najouter autant d’éléments que vous le souhaitez dans une liste).\nRemarque\nJusqu’à la version 3.6 de Python, un dictionnaire était aﬀiché sans ordre particulier. L’ordre d’aﬀichage des éléments\nn’était pas forcément le même que celui dans lequel il avait été rempli. De même, lorsqu’on itérait dessus, l’ordre n’était\npas garanti. Depuis Python 3.7 (inclus), ce comportement a changé : un dictionnaire est toujours aﬀiché dans le même\nordre que celui utilisé pour le remplir. Et si on itère sur un dictionnaire, cet ordre est aussi respecté. Ce détail provient de\nl’implémentation interne des dictionnaires dans Python, mais cela nous concerne peu. Ce qui importe, c’est de se rappeler\nqu’on accède aux éléments par leur clé, et non par leur position telle que le dictionnaire est aﬀiché. Cet ordre n’a pas\nd’importance, sauf dans de rares cas.\nOn peut aussi initialiser toutes les clés et les valeurs d’un dictionnaire en une seule opération :\n1 >>> animal2 = {\"nom\": \"singe\", \"poids\": 70, \"taille\": 1.75}\nMais rien ne nous empêche d’ajouter une clé et une valeur supplémentaire :\n1 >>> animal2[\"age\"] = 15\n2\n>>> animal2\n3 {'nom': 'singe', 'poids': 70, 'taille': 1.75, 'age': 15}\nAprès ce premier tour d’horizon, on perçoit l’avantage des dictionnaires : pouvoir retrouver des éléments par des noms\n(clés) plutôt que par des indices.\nLes humains retiennent mieux les noms que les chiffres. Ainsi, les dictionnaires se révèlent très pratiques lorsque vous\ndevez manipuler des structures complexes à décrire et que les listes présentent leurs limites. L’usage des dictionnaires\nrend en général le code plus lisible. Par exemple, si nous souhaitions stocker les coordonnées (x,y,z) d’un point dans\nl’espace, nous pourrions utiliser pour la version liste et\ncoors = [0, 1, 2] coors = {\"x\": 0, \"y\": 1, \"z\": 2}\npour la version dictionnaire. Quelqu’un qui lit le code comprendra tout de suite que contient la coordonnée\ncoors[\"z\"]\nz, ce sera moins intuitif avec .\ncoors[2]\nConseil\nNous verrons dans le chapitre 14 Conteneurs que plusieurs types d’objets sont utilisables en tant que clé de dictionnaire.\nMalgré cela, nous conseillons de n’utiliser que des chaînes de caractères lorsque vous débutez.\n8.1.2 Fonction\nlen()\nComme pour les listes, l’instruction renvoie la longueur du dictionnaire, sauf qu’ici il s’agit du nombre de\nlen()\ncouples clé / valeur. Voici un exemple d’utilisation :\n1 ani3 = {\"nom\": \"pinson\", \"poids\": 0.02, \"taille\": 0.15}\n2\n>>> len(ani3)\n3 3\n8.1.3 Itération sur les clés pour obtenir les valeurs\nSi on souhaite voir toutes les associations clés / valeurs, on peut itérer sur un dictionnaire de la manière suivante :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 67\nChapitre 8. Dictionnaires et tuples 8.1. Dictionnaires\n1\n>>> animal2 = {'nom': 'singe', 'poids': 70, 'taille': 1.75}\n2 >>> for key in animal2:\n3\n... print(key, animal2[key])\n4 ...\n5\npoids 70\n6 nom singe\n7 taille 1.75\nPar défaut, l’itération sur un dictionnaire se fait sur les clés. Dans cet exemple, la variable d’itération prend\nkey\nsuccessivement la valeur de chaque clé, donne la valeur correspondant à chaque clé.\nanimal2[key]\n8.1.4 Méthodes et\n.keys() .values()\nLes méthodes et renvoient, comme vous vous en doutez, les clés et les valeurs d’un dictionnaire :\n.keys() .values()\n1 >>> animal2.keys()\n2\ndict_keys(['poids', 'nom', 'taille'])\n3 >>> animal2.values()\n4\ndict_values([70, 'singe', 1.75])\nLes mentions et indiquent que nous avons à faire à des objets un peu particuliers. Ils ne\ndict_keys dict_values\nsont pas indexables (on ne peut pas retrouver un élément par indice, par exemple renverra une erreur).\ndico.keys()[0]\nSi besoin, nous pouvons les transformer en liste avec la fonction :\nlist()\n1 >>> animal2.values()\n2\ndict_values(['singe', 70, 1.75])\n3 >>> list(animal2.values())\n4\n['singe', 70, 1.75]\nToutefois, on peut itérer dessus dans une boucle (on dit qu’ils sont itérables) :\n1 >>> for cle in animal2.keys():\n2\n... print(cle)\n3 ...\n4\nnom\n5 poids\n6 taille\n8.1.5 Méthode .items()\nLa méthode renvoie un nouvel objet :\n.items() dict_items\n1 >>> dico = {0: \"t\", 1: \"o\", 2: \"t\", 3: \"o\"}\n2\n>>> dico.items()\n3 dict_items([(0, 't'), (1, 'o'), (2, 't'), (3, 'o')])\nOn ne peut pas retrouver un élément par son indice dans un objet , toutefois on peut itérer dessus :\ndict_items\n1 >>> dico.items()[2]\n2\nTraceback (most recent call last):\n3 File \"<stdin>\", line 1, in <module>\n4\nTypeError: 'dict_items' object is not subscriptable\n5 >>> for key, val in dico.items():\n6\n... print(key, val)\n7 ...\n8 0 t\n9\n1 o\n10 2 t\n11\n3 o\nNotez la syntaxe particulière qui ressemble à la fonction vue au chapitre 5 Boucles et comparaisons.\nenumerate()\nOn itère à la fois sur et sur . Nous aurons l’explication de ce mécanisme dans la rubrique sur les tuples ci-après.\nkey val\n8.1.6 Existence d’une clé ou d’une valeur\nPour vérifier si une clé existe dans un dictionnaire, on peut utiliser le test d’appartenance avec l’opérateur qui\nin\nrenvoie un booléen :\n68 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n8.1. Dictionnaires Chapitre 8. Dictionnaires et tuples\n1\n>>> animal2 = {'nom': 'singe', 'poids': 70, 'taille': 1.75}\n2 >>> \"poids\" in animal2\n3\nTrue\n4 >>> if \"poids\" in animal2:\n5\n... print(\"La clé 'poids' existe pour animal2\")\n6 ...\n7 La clé 'poids' existe pour animal2\n8\n>>> \"age\" in animal2\n9 False\n10\n>>> if \"age\" in animal2:\n11 ... print(\"La clé 'age' existe pour animal2\")\n12\n...\nDans le second test (lignes 10 à 12), le message n’est pas aﬀiché car la clé n’est pas présente dans le dictionnaire\nage\n.\nanimal2\nSi on souhaite tester si une valeur existe dans un dictionnaire, on peut utiliser l’opérateur avec l’objet renvoyé par\nin\nla méthode :\n.values()\n1 >>> animal2 = {'nom': 'singe', 'poids': 70, 'taille': 1.75}\n2\n>>> animal2.values()\n3 dict_values(['singe', 70, 1.75])\n4\n>>> \"singe\" in animal2.values()\n5 True\n8.1.7 Méthode\n.get()\nPar défaut, si on demande la valeur associée à une clé qui n’existe pas, Python renvoie une erreur :\n1\n>>> animal2 = {'nom': 'singe', 'poids': 70, 'taille': 1.75}\n2 >>> animal2[\"age\"]\n3\nTraceback (most recent call last):\n4 File \"<stdin>\", line 1, in <module>\n5\nKeyError: 'age'\nLa méthode s’affranchit de ce problème. Elle extrait la valeur associée à une clé mais ne renvoie pas d’erreur\n.get()\nsi la clé n’existe pas :\n1\n>>> animal2.get(\"nom\")\n2 'singe'\n3 >>> animal2.get(\"age\")\n4\n>>>\nIci, la valeur associée à la clé est , mais la clé n’existe pas. On peut également indiquer à une\nnom singe age .get()\nvaleur par défaut si la clé n’existe pas :\n1 >>> animal2.get(\"age\", 42)\n2 42\n8.1.8 Liste de dictionnaires\nEn créant une liste de dictionnaires qui possèdent les mêmes clés, on obtient une structure qui ressemble à une base\nde données :\n1\n>>> animaux = [animal1, animal2]\n2 >>> animaux\n3 [{'nom': 'girafe', 'poids': 1100, 'taille': 5.0}, {'nom': 'singe',\n4\n'poids': 70, 'taille': 1.75}]\n5 >>>\n6\n>>> for ani in animaux:\n7 ... print(ani[\"nom\"])\n8\n...\n9 girafe\n10\nsinge\nVous constatez ainsi que les dictionnaires permettent de gérer des structures complexes de manière plus explicite que\nles listes.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 69\nChapitre 8. Dictionnaires et tuples 8.2. Tuples"
  },
  {
    "title": "Tuples",
    "content": "8.2.1 Définition\nDéfinition\nLes tuples (« n-uplets » en français) sont des objets séquentiels correspondant aux listes, mais ils sont toutefois\nnon modifiables. On dit aussi qu’ils sont immuables. Vous verrez ci-dessous que nous les avons déjà croisés à plusieurs\nreprises !\nPratiquement, on utilise les parenthèses au lieu des crochets pour les créer :\n1\n>>> tuple1 = (1, 2, 3)\n2 >>> tuple1\n3\n(1, 2, 3)\n4 >>> type(tuple1)\n5\n<class 'tuple'>\n6 >>> tuple1[2]\n7\n3\n8 >>> tuple1[0:2]\n9\n(1, 2)\n10 >>> tuple1[2] = 15\n11 Traceback (most recent call last):\n12\nFile \"<stdin>\", line 1, in <module>\n13 TypeError: 'tuple' object does not support item assignment\nL’affectation et l’indiçage fonctionnent comme avec les listes. Mais si on essaie de modifier un des éléments du tuple\n(en ligne 10), Python renvoie un message d’erreur car les tuples sont non modifiables. Si vous voulez ajouter un élément\n(ou le modifier), vous devez créer un nouveau tuple :\n1\n>>> tuple1 = (1, 2, 3)\n2 >>> tuple1\n3\n(1, 2, 3)\n4 >>> tuple1 = tuple1 + (2,)\n5 >>> tuple1\n6\n(1, 2, 3, 2)\nConseil\nCet exemple montre que les tuples sont peu adaptés lorsqu’on a besoin d’ajouter, retirer, modifier des éléments. La\ncréation d’un nouveau tuple à chaque étape s’avère lourde et il n’y a aucune méthode pour faire cela puisque les tuples\nsont non modifiables. Pour ce genre de tâche, les listes sont clairement mieux adaptées.\nRemarque\nPour créer un tuple d’un seul élément comme ci-dessus, utilisez une syntaxe avec une virgule , pour\n(element,)\néviter une ambiguïté avec une simple expression. Par exemple, équivaut à l’entier , alors que l’expression est\n(2) 2 (2,)\nun tuple contenant l’élément .\n2\nAutre particularité des tuples, il est possible de les créer sans les parenthèses, dès lors que ceci ne pose pas d’ambiguïté\navec une autre expression :\n1 >>> tuple1 = (1, 2, 3)\n2\n>>> tuple1\n3 (1, 2, 3)\n4\n>>> tuple1 = 1, 2, 3\n5 >>> tuple1\n6\n(1, 2, 3)\n70 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n8.2. Tuples Chapitre 8. Dictionnaires et tuples\nToutefois, afin d’éviter les confusions, nous vous conseillons d’utiliser systématiquement les parenthèses lorsque vous\ndébutez.\nLes opérateurs et fonctionnent comme pour les listes (concaténation et duplication) :\n+ *\n1\n>>> (1, 2) + (3, 4)\n2 (1, 2, 3, 4)\n3\n>>> (1, 2) * 4\n4 (1, 2, 1, 2, 1, 2, 1, 2)\nEnfin, on peut utiliser la fonction qui fonctionne exactement comme la fonction , c’est-\ntuple(sequence) list()\nà-dire qu’elle prend en argument un objet et renvoie le tuple correspondant (opération de casting) :\n1\n>>> tuple([1,2,3])\n2 (1, 2, 3)\n3\n>>> tuple(\"ATGCCGCGAT\")\n4 ('A', 'T', 'G', 'C', 'C', 'G', 'C', 'G', 'A', 'T')\n5\n>>> tuple(range(5))\n6 (0, 1, 2, 3, 4)\nRemarque\nComme la fonction , la fonction prend en argument un objet contenant d’autres objets. Elle ne\nlist() tuple()\nfonctionne pas avec les entiers, floats ou booléens. Par exemple, renvoie une erreur. On en verra plus sur ces\ntuple(2)\nquestions dans le chapitre 14 Conteneurs.\n8.2.2 Affectation multiple\nLes tuples sont souvent utilisés pour l’affectation multiple, c’est-à-dire, affecter des valeurs à plusieurs variables en\nmême temps :\n1\n>>> x, y, z = 1, 2, 3\n2 >>> x\n3\n1\n4 >>> y\n5\n2\n6 >>> z\n7 3\nAttention, le nombre de variables et de valeurs doit être cohérents à gauche et à droite de l’opérateur :\n=\n1 >>> x, y = 1, 2, 3\n2\nTraceback (most recent call last):\n3 File \"<stdin>\", line 1, in <module>\n4\nValueError: too many values to unpack (expected 2)\nIl est aussi possible de faire des affectations multiples avec des listes, par exemple :\n.\n[x, y, z] = [1, 2, 3]\nToutefois, cette syntaxe est alourdie par la présence des crochets. On préfèrera donc la syntaxe avec les tuples sans\nparenthèses.\nRemarque\nNous avons appelé l’opération affectation multiple pour signifier que l’on affectait des valeurs\nx, y, z = 1, 2, 3\nà plusieurs variables en même temps.\nVous pourrez rencontrer aussi l’expression tuple unpacking que l’on pourrait traduire par « désempaquetage de tuple\n». De même, il existe le list unpacking.\nCe terme tuple unpacking provient du fait que l’on peut décomposer un tuple initial de n éléments en autant de\nvariables différentes en une seule instruction.\nPar exemple, si on crée un tuple de trois éléments :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 71\nChapitre 8. Dictionnaires et tuples 8.2. Tuples\n1\n>>> tuple1 = (1, 2, 3)\n2 >>> tuple1\n3\n(1, 2, 3)\nOn peut « désempaqueter » le tuple en une seule instruction :\n1 >>> x, y, z = tuple1\n2\n>>> x\n3 1\nCela serait possible également avec l’indiçage, mais il faudrait utiliser autant d’instruction que d’éléments :\n1 >>> x = tuple1[0]\n2\n>>> y = tuple1[1]\n3 >>> z = tuple1[2]\nDans les deux cas, vaudra , vaudra et vaudra .\nx 1 y 2 z 3\nConseil\nLa syntaxe pour désempaqueter un tuple est plus élégante, plus lisible et plus compacte. Elle\nx, y, z = tuple1\nsera donc à privilégier.\nL’affectation multiple est un mécanisme très puissant et important en Python. Nous verrons qu’il est particulièrement\nutile avec les fonctions dans les chapitres 10 Fonctions et 13 Plus sur les fonctions.\n8.2.3 Itérations sur plusieurs valeurs à la fois\nNous avons déjà croisé les tuples avec la fonction dans le chapitre 5 Boucles et comparaisons. Cette\nenumerate()\ndernière permettait d’itérer en même temps sur les indices et les éléments d’une liste :\n1 >>> for indice, element in enumerate([75, -75, 0]):\n2\n... print(indice, element)\n3 ...\n4\n0 75\n5 1 -75\n6\n2 0\n7 >>> for bidule in enumerate([75, -75, 0]):\n8\n... print(bidule, type(bidule))\n9 ...\n10 (0, 75) <class 'tuple'>\n11 (1, -75) <class 'tuple'>\n12 (2, 0) <class 'tuple'>\nLignes 7 à 12. La fonction itère sur une série de tuples. Pouvoir séparer et dans la\nenumerate() indice element\nboucle est possible avec l’affectation multiple, par exemple : (voir rubrique précédente).\nindice, element = 0, 75\nDans le même ordre d’idée, nous avons déjà vu la méthode qui permettait d’itérer sur des couples clé /\n.items()\nvaleur d’un dictionnaire :\n1 >>> dico = {\"pinson\": 2, \"merle\": 3}\n2\n>>> for cle, valeur in dico.items():\n3 ... print(cle, valeur)\n4\n...\n5 pinson 2\n6\nmerle 3\n7 >>> for bidule in dico.items():\n8 ... print(bidule, type(bidule))\n9 ...\n10 ('pinson', 2) <class 'tuple'>\n11\n('merle', 3) <class 'tuple'>\nLa méthode itère, comme , sur une série de tuples.\n.items() enumerate()\nEnfin, on peut itérer sur trois valeurs en même temps à partir d’une liste de tuples de trois éléments :\n72 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n8.3. Exercices Chapitre 8. Dictionnaires et tuples\n1\n>>> liste = [(5, 6, 7), (6, 7, 8), (7, 8, 9)]\n2 >>> for x, y, z in liste:\n3\n... print(x, y, z)\n4 ...\n5\n5 6 7\n6 6 7 8\n7 7 8 9\nOn pourrait concevoir la même chose sur quatre ou cinq éléments, voire plus. La seule contrainte est d’avoir une\ncorrespondance systématique entre le nombre de variables d’itération (par exemple trois variables dans l’exemple ci-dessus\navec ) et la longueur de chaque sous-tuple de la liste sur laquelle on itère (dans l’exemple ci-dessus, chaque\nx, y, z\nsous-tuple a trois éléments).\n8.2.4 Fonction divmod()\nDans le chapitre 2 Variables, on a vu les opérateurs et qui renvoient respectivement le quotient et le reste d’une\n// %\ndivision entière. La fonction prend en argument deux valeurs, le numérateur et le dénominateur d’une division,\ndivmod()\net renvoie le quotient et le reste de la division entière correspondante :\n1 >>> 3 / 4\n2\n0.75\n3 >>> 3 // 4\n4\n0\n5 >>> 3 % 4\n6\n3\n7 >>> divmod(3, 4)\n8\n(0, 3)\nEn utilisant l’affectation multiple, on peut ainsi récupérer à la volée le quotient et le reste en une seule ligne :\n1\n>>> quotient, reste = divmod(3, 4)\n2 >>> quotient\n3\n0\n4 >>> reste\n5\n3\nCette fonction est très pratique, notamment quand on souhaite convertir des secondes en minutes et secondes\nrésiduelles. Par exemple, si on veut convertir 754 secondes en minutes :\n1 >>> 754 / 60\n2\n12.566666666666666\n3 >>> divmod(754, 60)\n4\n(12, 34)\nLa division normale nous donne un float en minutes qui n’est pas très pratique, il faut encore convertir\n0.566666666666666\nminute en secondes et gérer les problèmes d’arrondi. La fonction renvoie le résultat directement : 12 min et\ndivmod()\n34 s. On pourrait raisonner de manière similaire pour convertir des minutes en heures, des heures en jours, etc.\n8.2.5 Remarque finale\nLes listes, les dictionnaires et les tuples sont tous des objets contenant une collection d’autres objets. En Python,\non peut construire des listes qui contiennent des dictionnaires, des tuples ou d’autres listes, mais aussi des dictionnaires\ncontenant des tuples, des listes, etc. Les combinaisons sont infinies !"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour le premier exercice, utilisez l’interpréteur Python. Pour les suivants, créez des scripts puis exécutez-les dans un\nshell.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 73\nChapitre 8. Dictionnaires et tuples 8.3. Exercices\n8.3.1 Prédire la sortie\nSoit les deux lignes de code suivantes :\n1 dico = {\"nom\": \"Joe\", \"age\": 24, \"taille\": 181}\n2\nvar = \"nom\"\nPrédisez le comportement de chaque instruction ci-dessous, sans les recopier dans un script ni dans l’interpréteur\nPython :\n•\nprint(dico[\"age\"])\n•\nprint(dico[var])\n•\nprint(dico[24])\n•\nprint(dico[\"var\"])\n•\nprint(dico[\"taille\"])\nLorsqu’une instruction produit une erreur, identifiez pourquoi. Vérifiez ensuite vos prédictions en recopiant les ins-\ntructions dans l’interpréteur Python.\n8.3.2 Moyennes des notes\nSoit le dictionnaire suivant donnant les notes d’un étudiant :\n1 dico_notes = {\n2\n\"math\": 14, \"programmation\": 12,\n3 \"anglais\": 16, \"biologie\": 10,\n4\n\"sport\": 19\n5 }\nCalculez la moyenne de ses notes de deux manières différentes. Calculez à nouveau la moyenne sans la note de biologie.\n8.3.3 Composition en acides aminés\nEn utilisant un dictionnaire, déterminez le nombre d’occurrences de chaque acide aminé dans la séquence\nAGWPSGGASAGLAILWGASAIMPGALW\n. Le dictionnaire ne doit contenir que les acides aminés présents dans la séquence.\nVous ne pouvez pas utiliser autant d’instructions que d’acides aminés différents. Pensez au test d’appartenance.\nif\n8.3.4 Convertisseur de secondes\nUn athlète court un marathon, malheureusement sa montre ne mesure son temps qu’en secondes. Celle-ci aﬀiche 11\n905. Aidez-le à convertir son temps en heures, minutes et secondes avec la fonction .\ndivmod()\n8.3.5 Convertisseur de jours\nL’âge de Camille et Céline en jours est respectivement de 8 331 jours et 8 660 jours. Quel est leur âge en années,\nmois et jours, en supposant qu’une année compte 365 jours et qu’un mois compte 30 jours ? La fonction vous\ndivmod()\naidera à nouveau.\n8.3.6 Propriétés des acides aminés\nLes acides aminés peuvent être séparés en quatre grandes catégories : apolaires (a), polaires (p), chargés positivement\n(+) et chargés négativement (-). Le dictionnaire suivant implémente cette classification :\n1 aa2prop = {'A': 'a', 'V': 'a', 'L': 'a', 'G': 'a', 'I': 'a', 'M': 'a',\n2\n'W': 'a', 'F': 'a', 'P': 'a',\n3 'S': 'p', 'C': 'p', 'N': 'p', 'Q': 'p', 'T': 'p', 'Y': 'p',\n4\n'D': '-', 'E': '-',\n5 'K': '+', 'R': '+', 'H': '+' }\nOn souhaite convertir la séquence en acide aminé du domaine transmembranaire d’une intégrine humaine\nSNADVVYEKQMLYLYVLSGIGGLLLLLLIFIVLYKVGFFKRNLKEKMEAG\nen une série de signes indiquant la nature des acides aminés (a, p, + et -). Aﬀichez tout d’abord la séquence sur une\nligne, puis la nature des acides aminés sur une seconde ligne.\nLa séquence contient une hélice transmembranaire, donc une succession de résidus apolaires, essayez de la retrouver\nvisuellement.\n74 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n8.3. Exercices Chapitre 8. Dictionnaires et tuples\nPour cet exercice, nous vous conseillons d’itérer sur la chaîne de caractères contenant la séquence. Nous reverrons\ncela dans le chapitre 11 Plus sur les chaînes de caractères.\n8.3.7 Boucle sur plusieurs éléments simultanément\nÀ partir de la liste de tuples suivante :\n[(\"chien\", 3), (\"chat\", 4), (\"souris\", 16)]\naﬀichez chaque animal et son nombre en utilisant qu’une seule boucle . Attention, pour cet exercice, il est interdit\nfor\nd’utiliser l’indiçage des listes.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 75"
  },
  {
    "title": "Définition",
    "content": "Les modules sont des programmes Python qui contiennent des fonctions que l’on est amené à souvent réutiliser (on\nles appelle aussi bibliothèques, ou libraries en anglais). Ce sont des « boîtes à outils » qui vous seront très utiles.\nLes développeurs de Python ont mis au point de nombreux modules qui effectuent différentes tâches. Pour cette\nraison, prenez toujours le réflexe de vérifier si une partie du code que vous souhaitez écrire n’existe pas déjà sous forme\nde module.\nLa plupart de ces modules sont déjà installés dans les versions standards de Python. Vous pouvez accéder à une\n1\ndocumentation exhaustive sur le site de Python. N’hésitez pas à explorer un peu ce site, la quantité de modules\ndisponibles est impressionnante (plus de 300 modules)."
  },
  {
    "title": "Importation de modules",
    "content": "Dans les chapitres précédents, nous avons rencontré la notion de module plusieurs fois, notamment lorsque nous avons\nvoulu tirer un nombre aléatoire :\n1 >>> import random\n2\n>>> random.randint(0, 10)\n3 4\nRegardons de plus près cet exemple :\n•\n2\nLigne 1. L’instruction donne accès à toutes les fonctions du module random .\nimport\n•\nLigne 2. Nous utilisons la fonction du module random. Cette fonction renvoie un nombre entier\nrandint(0, 10)\ntiré aléatoirement entre inclus et inclus.\n0 10\nNous avons également croisé le module math lors de l’exercice sur la spirale (voir le chapitre 7 Fichiers). Ce module\nπ\nnous a donné accès aux fonctions trigonométriques sinus et cosinus, et à la constante :\n1\n>>> import math\n2 >>> math.cos(math.pi / 2)\n3\n6.123233995736766e-17\n4 >>> math.sin(math.pi / 2)\n5 1.0\n1.\nhttps://docs.python.org/fr/3/py-modindex.html\n2. https://docs.python.org/fr/3/library/random.html#module-random\n76\n9.2. Importation de modules Chapitre 9. Modules\nEn résumé, l’utilisation de la syntaxe permet d’importer tout une série de fonctions organisées par\nimport module\n« thèmes ». Par exemple, les fonctions gérant les nombres aléatoires avec random et les fonctions mathématiques avec\nmath. Python possède de nombreux autres modules internes (c’est-à-dire présent de base lorsqu’on installe Python).\nRemarque\nDans le chapitre 3 Aﬀichage, nous avons introduit la syntaxe avec étant un objet et\ntruc.bidule() truc .bidule()\nune méthode. Nous vous avions expliqué qu’une méthode était une fonction un peu particulière :\n•\nelle était liée à un objet par un point ;\n•\nen général, elle agissait sur ou utilisait l’objet auquel elle était liée.\nPar exemple, la méthode vue dans le chapitre 4 Listes. Dans l’instruction , la méthode\n.append() liste1.append(3)\najoute l’entier à l’objet auquel elle est liée.\n.append() 3 liste1\nAvec les modules, nous rencontrons une syntaxe similaire. Par exemple, dans l’instruction , on pourrait\nmath.cos()\n3\npenser que est aussi une méthode. En fait la documentation oﬀicielle de Python précise bien que dans ce cas\n.cos()\nest une fonction. Dans cet ouvrage, nous utiliserons ainsi le mot fonction lorsqu’on évoquera des fonctions issues\n.cos()\nde modules.\nSi cela vous parait encore ardu, ne vous inquiétez pas : c’est à force de pratiquer et de lire que vous vous approprierez\nle vocabulaire. La syntaxe est là pour rappeler de quel module provient la fonction en un coup\nmodule.fonction()\nd’œil.\nIl existe un autre moyen d’importer une ou plusieurs fonctions d’un module :\n1\n>>> from random import randint\n2 >>> randint(0,10)\n3\n7\nÀ l’aide du mot-clé , on peut importer une fonction spécifique d’un module donné. Remarquez bien qu’il est\nfrom\ninutile de répéter le nom du module dans ce cas : seul le nom de la fonction en question est requis.\nOn peut également importer toutes les fonctions d’un module :\n1\n>>> from random import *\n2 >>> randint(0,50)\n3 46\n4\n>>> uniform(0,2.5)\n5 0.64943174760727951\nL’instruction importe toutes les fonctions du module random. On peut utiliser toutes ses\nfrom random import *\nfonctions directement, comme par exemple et qui renvoient des nombres aléatoires entiers et\nrandint() uniform()\nfloats.\nDans la pratique, plutôt que de charger toutes les fonctions d’un module en une seule fois :\n1 from random import *\nNous vous conseillons de charger le module seul de la manière suivante :\n1 import random\npuis d’appeler explicitement les fonctions voulues, par exemple :\n1\n>>> import random\n2 >>> random.randint(1, 10)\n3\n4\n4 >>> random.uniform(1, 3)\n5\n1.8645753676306085\nIl est également possible de définir un alias (un nom plus court) pour un module :\n3. https://docs.python.org/fr/3/tutorial/modules.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 77\nChapitre 9. Modules 9.3. Obtenir de l’aide sur les modules importés\n1\n>>> import random as rand\n2 >>> rand.randint(1, 10)\n3\n6\n4 >>> rand.uniform(1, 3)\n5\n2.643472616544236\nDans cet exemple, les fonctions du module random sont accessibles via l’alias .\nrand\nEnfin, pour vider de la mémoire un module déjà chargé, on peut utiliser l’instruction :\ndel\n1 >>> import random\n2 >>> random.randint(0,10)\n3\n2\n4 >>> random.uniform(1, 3)\n5\n2.825594756352219\n6 >>> del random\n7\n>>> random.randint(0,10)\n8 Traceback (most recent call last):\n9\nFile \"<stdin>\", line 1, in ?\n10 NameError: name 'random' is not defined. Did you forget to import 'random'?\nOn constate alors qu’un rappel (ligne 7) d’une fonction du module random, après l’avoir vidé de la mémoire (ligne 6),\nretourne un message d’erreur (lignes 8-10). Dans le cas présent, le message d’erreur est explicite et demande à l’utilisateur\ns’il n’a pas oublié d’importer le module random."
  },
  {
    "title": "Obtenir de l’aide sur les modules importés",
    "content": "Pour obtenir de l’aide sur un module, rien de plus simple : il suﬀit d’utiliser la commande :\nhelp()\n1\n>>> import random\n2 >>> help(random)\n3\n[...]\nCe qui renvoie :\nHelp on module random:\nNAME\nrandom - Random variable generators.\nMODULE REFERENCE\nhttps://docs.python.org/3.7/library/random\nThe following documentation is automatically generated from the Python\nsource files. It may be incomplete, incorrect or include features that\nare considered implementation detail and may vary between Python\nimplementations. When in doubt, consult the module reference at the\nlocation listed above.\nDESCRIPTION\nintegers\n--------\nuniform within range\nsequences\n---------\npick random element\npick random sample\nRemarque\n•\nPour vous déplacer dans l’aide, utilisez les flèches du haut et du bas pour le parcourir ligne par ligne, ou les touches\nPage-up et Page-down pour faire défiler l’aide page par page.\n•\nPour quitter l’aide, appuyez sur la touche Q.\n•\nPour chercher du texte, tapez le caractère / puis le texte que vous cherchez, puis la touche Entrée. Par exemple,\npour chercher l’aide sur la fonction , tapez puis Entrée.\nrandint() /randint\n78 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n9.4. Quelques modules courants Chapitre 9. Modules\n•\nVous pouvez également obtenir de l’aide sur une fonction particulière d’un module avec :\nhelp(random.randint)\nLa commande est en fait une commande plus générale, permettant d’avoir de l’aide sur n’importe quel objet\nhelp()\nchargé en mémoire :\n1\n>>> t = [1, 2, 3]\n2 >>> help(t)\n3\nHelp on list object:\n4\n5\nclass list(object)\n6 | list() -> new list\n7 | list(sequence) -> new list initialized from sequence's items\n8\n|\n9 | Methods defined here:\n10\n|\n11 | __add__(...)\n12\n| x.__add__(y) <==> x+y\n13 |\n14\n|\n15 ...\nEnfin, pour connaître d’un seul coup d’œil toutes les méthodes ou variables associées à un objet, utilisez la fonction\n:\ndir()\n1\n>>> import random\n2 >>> dir(random)\n3\n['BPF', 'LOG4', 'NV_MAGICCONST', 'RECIP_BPF', 'Random', 'SG_MAGICCONST',\n4 'SystemRandom', 'TWOPI', 'WichmannHill', '_BuiltinMethodType', '_MethodT\n5\nype', '__all__', '__builtins__', '__doc__', '__file__', '__name__', '_ac\n6 os', '_ceil', '_cos', '_e', '_exp', '_hexlify', '_inst', '_log', '_pi',\n7\n'_random', '_sin', '_sqrt', '_test', '_test_generator', '_urandom', '_wa\n8 rn', 'betavariate', 'choice', 'expovariate', 'gammavariate', 'gauss', 'g\n9\netrandbits', 'getstate', 'jumpahead', 'lognormvariate', 'normalvariate',\n10 'paretovariate', 'randint', 'random', 'randrange', 'sample', 'seed', 's\n11 etstate', 'shuffle', 'uniform', 'vonmisesvariate', 'weibullvariate']\n12 >>>"
  },
  {
    "title": "Quelques modules courants",
    "content": "Il existe une série de modules que vous serez probablement amenés à utiliser si vous programmez en Python. En voici\n4\nune liste non exhaustive (pour la liste complète, reportez-vous à la page des modules sur le site de Python) :\n•\n5\nmath : fonctions et constantes mathématiques de base (sin, cos, exp, pi…).\n• 6\nsys : interaction avec l’interpréteur Python, notamment pour le passage d’arguments (voir plus bas).\n• 7\npathlib : gestion des fichiers et des répertoires (voir plus bas).\n•\n8\nrandom : génération de nombres aléatoires.\n• 9\ntime : accès à l’heure de l’ordinateur et aux fonctions gérant le temps.\n•\n10\nurllib : récupération de données sur internet depuis Python.\n• 11\nTkinter : interface python avec Tk. Création d’objets graphiques (voir chapitre 25 Fenêtres graphiques et Tkinter\n(en ligne)).\n• 12\nre : gestion des expressions régulières (voir chapitre 17 Expressions régulières et parsing).\nNous vous conseillons d’aller explorer les pages de ces modules pour découvrir toutes leurs potentialités.\n4. https://docs.python.org/fr/3/py-modindex.html\n5.\nhttps://docs.python.org/fr/3/library/math.html#module-math\n6. https://docs.python.org/fr/3/library/sys.html#module-sys\n7.\nhttps://docs.python.org/fr/3/library/os.html#module-os\n8. https://docs.python.org/fr/3/library/random.html#module-random\n9.\nhttps://docs.python.org/fr/3/library/time.html#module-time\n10. https://docs.python.org/fr/3/library/urllib.html#module-urllib\n11.\nhttps://docs.python.org/fr/3/library/tkinter.html#module-tkinter\n12. https://docs.python.org/fr/3/library/re.html#module-re\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 79\nChapitre 9. Modules 9.5. Module random : génération de nombres aléatoires\nVous verrez dans le chapitre 15 Création de modules comment créer votre propre module lorsque vous souhaitez\nréutiliser souvent vos propres fonctions.\nEnfin, notez qu’il existe de nombreux autres modules externes qui ne sont pas installés de base dans Python, mais\nqui sont très utilisés en bioinformatique et en analyse de données. Par exemple : NumPy (manipulations de vecteurs\net de matrices), Biopython (manipulation de séquences ou de structures de biomolécules), matplotlib (représentations\ngraphiques), pandas (analyse de données tabulées), etc. Ces modules vous serons présentés dans les chapitres 19 à 22."
  },
  {
    "title": "Module random : génération de nombres aléatoires",
    "content": "13\nComme indiqué précédemment, le module random contient des fonctions pour la génération de nombres aléatoires :\n1\n>>> import random\n2 >>> random.randint(0, 10)\n3\n4\n4 >>> random.randint(0, 10)\n5\n10\n6 >>> random.uniform(0, 10)\n7\n6.574743184892878\n8 >>> random.uniform(0, 10)\n9\n1.1655547702189106\nLe module random permet aussi de permuter aléatoirement des listes :\n1\n>>> x = [1, 2, 3, 4]\n2 >>> random.shuffle(x)\n3 >>> x\n4\n[2, 3, 1, 4]\n5 >>> random.shuffle(x)\n6\n>>> x\n7 [4, 2, 1, 3]\nMais aussi de tirer aléatoirement un élément dans une liste donnée :\n1\n>>> bases = [\"A\", \"T\", \"C\", \"G\"]\n2 >>> random.choice(bases)\n3 'A'\n4\n>>> random.choice(bases)\n5 'G'\nLa fonction (avec un s à la fin) réalise plusieurs tirages aléatoires (avec remise, c’est-à-dire qu’on peut\nchoices()\npiocher plusieurs fois le même élément) dans une liste donnée. Le nombre de tirages est précisé par le paramètre :\nk\n1 >>> random.choices(bases, k=5)\n2\n['G', 'A', 'A', 'T', 'G']\n3 >>> random.choices(bases, k=5)\n4 ['A', 'T', 'A', 'A', 'C']\n5\n>>> random.choices(bases, k=10)\n6 ['C', 'T', 'T', 'T', 'G', 'A', 'C', 'A', 'G', 'G']\nSi vous exécutez vous-même les exemples précédents, vous devriez obtenir des résultats légèrement différents de ceux\nindiqués.\nPour des besoins de reproductibilité des analyses en science, on a souvent besoin de retrouver les mêmes résultats\nmême si on utilise des nombres aléatoires. Pour cela, on peut définir ce qu’on appelle la « graine aléatoire ».\nDéfinition\nEn informatique, la génération de nombres aléatoires est un problème complexe. On utilise plutôt des « générateurs\n14 15\nde nombres pseudo-aléatoires ». Pour cela, une graine aléatoire doit être définie. Cette graine est la plupart du temps\nun nombre entier qu’on passe au générateur : celui-ci va alors produire une série donnée de nombres pseudo-aléatoires\nqui dépendent de cette graine. Si on change la graine, la série de nombres change.\n13. https://docs.python.org/fr/3/library/random.html#module-random\n14.\nhttps://fr.wikipedia.org/wiki/G%C3%A9n%C3%A9rateur_de_nombres_pseudo-al%C3%A9atoires\n15. https://fr.wikipedia.org/wiki/Graine_al%C3%A9atoire\n80 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n9.6. Module sys : passage d’arguments Chapitre 9. Modules\nEn Python, la graine aléatoire se définit avec la fonction :\nseed()\n1\n>>> random.seed(42)\n2 >>> random.randint(0, 10)\n3\n1\n4 >>> random.randint(0, 10)\n5\n0\n6 >>> random.randint(0, 10)\n7 4\nIci, la graine aléatoire est fixée à 42. Si on ne précise pas la graine, par défaut Python utilise la date (plus précisément,\nil s’agit du nombre de secondes écoulées depuis une date fixe passée). Ainsi, à chaque fois qu’on relance Python, la graine\nsera différente, car ce nombre de secondes sera différent.\nSi vous exécutez ces mêmes lignes de code (depuis l’instruction ), il se peut que vous ayez des\nrandom.seed(42)\nrésultats différents selon la version de Python. Néanmoins, vous devriez systématiquement obtenir les mêmes résultats si\nvous relancez plusieurs fois de suite ces instructions sur une même machine.\nRemarque\nQuand on utilise des nombres aléatoires, il est fondamental de connaitre la distribution de probablités utilisée par la\nfonction.\nPar exemple, la fonction de base du module random est , elle renvoie un float aléatoire entre 0 et\nrandom.random()\n1 tiré dans une distribution uniforme. Si on tire beaucoup de nombres, on aura la même probabilité d’obtenir tous les\nnombres possibles entre 0 et 1. La fonction tire aussi un entier dans une distribution uniforme. La\nrandom.randint()\nfonction tire quant à elle un float aléatoire dans une distribution gaussienne.\nrandom.gauss()"
  },
  {
    "title": "Module sys : passage d’arguments",
    "content": "16\nLe module sys contient des fonctions et des variables spécifiques à l’interpréteur Python lui-même.\nCe module est particulièrement intéressant pour récupérer les arguments passés à un script Python lorsque celui-ci\nest appelé en ligne de commande.\nDans cet exemple, créons le script suivant que l’on enregistrera sous le nom :\ntest.py\n1\nimport sys\n2 print(sys.argv)\nEnsuite, dans un shell, exécutons le script suivi de plusieurs arguments :\ntest.py\n$ python test.py salut girafe 42\n['test.py', 'salut', 'girafe', '42']\n•\nLigne 1. Le caractère représente l’invite du shell, est le nom du script Python, , et\n$ test.py salut girafe 42\nsont les arguments passés au script (tous séparés par un espace).\n•\nLigne 2. Le script aﬀiche le contenu de la variable . Cette variable est une liste qui contient tous les\nsys.argv\narguments de la ligne de commande, y compris le nom du script Python lui-même qu’on retrouve comme premier\nélément de cette liste dans . On peut donc accéder à chacun des différents arguments du script avec\nsys.argv[0]\n, , etc.\nsys.argv[1] sys.argv[2]\nToujours dans le module sys, la fonction est utile pour quitter un script Python. On peut donner un\nsys.exit()\nargument à cette fonction (en général une chaîne de caractères) qui sera renvoyé au moment où Python quittera le script.\nPar exemple, si vous attendez au moins un argument en ligne de commande, vous pouvez renvoyer un message pour\nindiquer à l’utilisateur ce que le script attend comme argument :\n1\nimport sys\n2\n3 if len(sys.argv) != 2:\n4\nsys.exit(\"ERREUR : il faut exactement un argument.\")\n5\n6\nprint(f\"Argument vaut : {sys.argv[1]}\")\n16. https://docs.python.org/fr/3/library/sys.html#module-sys\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 81\nChapitre 9. Modules 9.6. Module sys : passage d’arguments\nPuis on l’exécute sans argument :\n$ python test.py\nERREUR : il faut exactement un argument.\navec un seul argument :\n$ python test.py 42\nArgument vaut : 42\npuis avec plusieurs :\n$ python test.py 42 salut\nERREUR : il faut exactement un argument.\nRemarque\nOn vérifie dans cet exemple que le script possède deux arguments, car le nom du script lui-même compte pour un\nargument (le tout premier).\nL’intérêt de récupérer des arguments passés dans la ligne de commande à l’appel du script est de pouvoir ensuite les\nutiliser dans le script.\nVoici comme nouvel exemple le script , qui prend comme argument le nom d’un fichier puis\ncompte_lignes.py\naﬀiche le nombre de lignes qu’il contient :\n1\nimport sys\n2\n3\nif len(sys.argv) != 2:\n4 sys.exit(\"ERREUR : il faut exactement un argument.\")\n5\n6 nom_fichier = sys.argv[1]\n7\ntaille = 0\n8 with open(nom_fichier, \"r\") as f_in:\n9 taille = len(f_in.readlines())\n10\n11 print(f\"{nom_fichier} contient {taille} lignes.\")\nSupposons que dans le même répertoire, nous ayons le fichier dont voici le contenu :\nanimaux1.txt\ngirafe\ntigre\nsinge\nsouris\net le fichier qui contient :\nanimaux2.txt\npoisson\nabeille\nchat\nUtilisons maintenant le script :\ncompte_lignes.py\n$ python compte_lignes.py\nERREUR : il faut exactement un argument.\n$ python compte_lignes.py animaux1.txt\nanimaux1.txt contient 4 lignes.\n$ python compte_lignes.py animaux2.txt\nanimaux2.txt contient 3 lignes.\n$ python compte_lignes.py animaux1.txt animaux2.txt\nERREUR : il faut exactement un argument.\nNotre script est donc capable de :\n•\nvérifier si un argument lui est donné et si ce n’est pas le cas d’aﬀicher un message d’erreur ;\n•\nd’ouvrir le fichier dont le nom est fourni en argument, de compter puis d’aﬀicher le nombre de lignes.\n82 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n9.7. Module pathlib : gestion des fichiers et des répertoires Chapitre 9. Modules\nPar contre, le script ne vérifie pas si le fichier fourni en argument existe bien :\n$ python compte_lignes.py animaux3.txt\nTraceback (most recent call last):\nFile \"compte_lignes.py\", line 8, in <module>\nwith open(nom_fichier, \"r\") as f_in:\n^^^^^^^^^^^^^^^^^^^^^^\nFileNotFoundError: [Errno 2] No such file or directory: 'animaux3.txt'\nLa lecture de la partie suivante va nous permettre d’améliorer notre script .\ncompte_lignes.py"
  },
  {
    "title": "Module pathlib : gestion des fichiers et des répertoires",
    "content": "17\nLe module pathlib permet de manipuler les fichiers et les répertoires.\nLe plus souvent, on utilise uniquement la classe du module , qu’on charge de cette manière :\nPath pathlib\n1 >>> from pathlib import Path\nLa méthode vérifie la présence d’un fichier sur le disque dur :\n.exists()\n1 >>> import sys\n2\n>>> from pathlib import Path\n3 >>> if Path(\"toto.pdb\").exists():\n4\n... print(\"le fichier est présent\")\n5 ... else:\n6 ... sys.exit(\"le fichier est absent\")\n7\n...\n8 le fichier est absent\nDans cet exemple, si le fichier n’existe pas sur le disque dur, on quitte le programme avec la fonction du\nexit()\nmodule sys que nous venons de voir.\nLa méthode renvoie le chemin complet du répertoire depuis lequel est lancé Python (cwd signifiant current\n.cwd()\nworking directory) :\n1 >>> from pathlib import Path\n2\n>>> Path().cwd()\n3 PosixPath('/home/pierre')\nOn obtient un objet de type qu’il est possible de transformer si besoin en chaîne de caractères avec la\nPosixPath\nfonction , que nous avons vu dans le chapitre 2 Variables :\nstr()\n1\n>>> str(Path().cwd())\n2 '/home/pierre'\nMais l’intérêt de récupérer un objet de type est qu’on peut ensuite utiliser les méthodes et\nPosixPath .name .parent\npour obtenir respectivement le nom du répertoire (sans son chemin complet) et le répertoire parent :\n1\n>>> Path().cwd()\n2 PosixPath('/home/pierre')\n3\n>>> Path().cwd().name\n4 'pierre'\n5 >>> Path().cwd().parent\n6\nPosixPath('/home')\nEnfin, la méthode liste le contenu du répertoire depuis lequel est lancé Python :\n.iterdir()\n1 >>> list(Path().iterdir())\n2\n[PosixPath('demo.py'), PosixPath('tests'), PosixPath('1BTA.pdb')]\nTout comme la fonction (voir le chapitre 4 Listes), la méthode est un itérateur. La fonction\nrange() .iterdir()\npermet d’obtenir une liste.\nlist()\nToutefois, il est possible d’itérer très facilement sur le contenu d’un répertoire et de savoir s’il contient des fichiers\nou des sous-répertoires :\n17. https://docs.python.org/fr/3/library/pathlib.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 83\nChapitre 9. Modules 9.8. Exercices\n1\n>>> for nom in Path().iterdir():\n2 ... if nom.is_file():\n3\n... print(f\"{nom} est un fichier\")\n4 ... else:\n5\n... print(f\"{nom} n'est pas un fichier\")\n6 ...\n7 demo.py est un fichier\n8\ntests n'est pas un fichier\n9 1BTA.pdb est un fichier\nLa méthode renvoie si l’objet est un fichier, et si ce n’est pas le cas.\n.is_file() True False\nLa méthode parcourt le contenu d’un répertoire, sans en explorer les éventuels sous-répertoires. Si on\n.iterdir()\nsouhaite parcourir récursivement un répertoire, on utilise la méthode . Prenons l’arborescence suivante comme\n.glob()\nexemple :\n1BTA.pdb\ndemo.py\ntests\n├── results.csv\n├── script1.py\n└── script2.py\nLe répertoire courant contient les fichiers et , ainsi que le répertoire . Ce dernier contient\n1BTA.pdb demo.py tests\nlui-même les fichiers , et .\nresults.csv script1.py script2.py\nOn souhaite maintenant lister tous les scripts Python (dont l’extension est ) présents dans le répertoire courant\n.py\net dans ses sous-répertoires :\n1 >>> for nom in Path().glob(\"**/*.py\"):\n2 ... print(f\"{nom}\")\n3\n...\n4 demo.py\n5\ntests/script1.py\n6 tests/script2.py\nDans la chaîne de caractères , recherche tous les sous-répertoires récursivement et signifie\n\"**/*.py\" ** *.py\nn’importe quel nom de fichier qui se termine par l’extension .\n.py\nIl existe de nombreuse autres méthodes associées à la classe du module pathlib, n’hésitez pas à consulter la\nPath\n18\ndocumentation ."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour les trois premiers exercices, utilisez l’interpréteur Python. Pour les exercices suivants, créez des scripts puis\nexécutez-les dans un shell.\n9.8.1 Racine carrée\nAﬀichez sur la même ligne les nombres de 10 à 20 (inclus) ainsi que leur racine carrée avec trois décimales. Utilisez\npour cela le module math avec la fonction . Exemple :\nsqrt()\n10 3.162\n11 3.317\n12 3.464\n13 3.606\n[...]\n19\nConsultez pour cela la documentation de la fonction .\nmath.sqrt()\n18.\nhttps://docs.python.org/3/library/pathlib.html\n19. https://docs.python.org/fr/3/library/math.html#math.sqrt\n84 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n9.8. Exercices Chapitre 9. Modules\n9.8.2 Cosinus\nπ\nCalculez le cosinus de /2 en utilisant le module math avec la fonction et la constante .\ncos() pi\n20 21\nConsultez pour cela la documentation de la fonction et la documentation de la constante .\nmath.cos() math.pi\n9.8.3 Comparaison de floats\nMontrez que\n√\n√\n√\n5+ 4+ 3\nest égale à e à 0,001 près.\nMontrez ensuite que\n√\n√\n√\n7+ 6+ 5\nπ\nest égale à à 0,0001 près.\nConseil\n•\nJetez un oeil à la rubrique sur la comparaison de floats abordée dans le chapitre 6 Tests.\n• π\nLes constantes et e sont obtenues par et .\nmath.pi math.e\n9.8.4 Chemin et contenu du répertoire courant\nAﬀichez le chemin et le contenu du répertoire courant (celui depuis lequel vous avez lancé l’interpréteur Python).\nDéterminez également le nombre total de fichiers et de répertoires présents dans le répertoire courant.\n9.8.5 Aﬀichage temporisé\nAﬀichez les nombres de 1 à 10 avec 1 seconde d’intervalle. Utilisez pour cela le module time et sa fonction .\nsleep()\n22\nConsultez pour cela la documentation de la fonction .\ntime.sleep()\n9.8.6 Séquences aléatoires de chiffres\nGénérez une séquence aléatoire de six chiffres, ceux-ci étant des entiers tirés entre 1 et 4. Utilisez le module random\navec la fonction .\nrandint()\n23\nConsultez pour cela la documentation de la fonction .\nrandom.randint()\n9.8.7 Compteur de points de jeu de belote\nOn considère un jeu de belote avec la variante sans-atout, où chaque carte vaut un certain nombre de points quelle\nque soit sa couleur (trèfle, carreau, coeur, pique). Un dictionnaire permet de mettre la correspondance entre chaque carte\net son nombre de points :\n1\n# Nombre de points de chaque carte.\n2 # (V = valet, D = dame, R = roi, # d = 10, A = as).\n3\ndico_points_sans_atouts = {\"7\": 0, \"8\": 0, \"9\": 0, \"V\": 2, \"D\": 3,\n4 \"R\": 4, \"d\": 10, \"A\": 11}\nPar ailleurs, on peut représenter un jeu de 32 cartes par une liste :\njeu_cartes = [\"7\", \"8\", \"9\", \"d\", \"V\", \"D\", \"R\", \"A\"] * 4\nCréez un programme qui tire huit cartes au hasard sans remise et qui aﬀiche le nombre de points\nbelote.py\ncorrespondant. Pour cela, vous pouvez utiliser la fonction et son argument par mot-clé . N’hésitez\nrandom.sample() k\n24\npas à consulter la documentation . On souhaite une sortie de ce style :\n20. https://docs.python.org/fr/3/library/math.html#math.cos\n21.\nhttps://docs.python.org/fr/3/library/math.html#math.pi\n22. https://docs.python.org/fr/3/library/time.html#time.sleep\n23.\nhttps://docs.python.org/fr/3/library/random.html#random.randint\n24. https://docs.python.org/fr/3/library/random.html#random.sample\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 85\nChapitre 9. Modules 9.8. Exercices\n$ python belote.py\nLa main est ['7', 'A', '9', 'A', 'R', 'd', 'V', 'D'].\n7 --> 0 points\nA --> 11 points\n9 --> 0 points\nA --> 11 points\nR --> 4 points\nd --> 10 points\nV --> 2 points\nD --> 3 points\nLe nombre total de points de la main est 41.\n9.8.8 Séquences aléatoires d’ADN\nGénérez une séquence aléatoire d’ADN de 20 bases de deux manières différentes. Utilisez le module random avec la\nfonction ou .\nchoice() choices()\n9.8.9 Séquences aléatoires d’ADN avec argument\nCréez un script qui prend comme argument un nombre de bases, construit une séquence aléatoire\ndna_random.py\nd’ADN dont la longueur est le nombre de bases fourni en argument, puis aﬀiche cette séquence.\nLe script devra vérifier qu’un argument est bien fourni et renvoyer un message d’erreur si ce n’est pas le cas.\nConseil\nPour générer la séquence d’ADN, utilisez la fonction abordée dans l’exercice précédent.\nrandom.choice()\n9.8.10 Compteur de lignes\nAméliorez le script , dont le code a été donné précédemment, de façon à ce qu’il renvoie un\ncompte_lignes.py\nmessage d’erreur si le fichier n’existe pas.\nPar exemple, si les fichiers et sont bien dans le répertoire courant, mais pas\nanimaux1.txt animaux2.txt animaux3\n:\n.txt\n$ python compte_lignes.py animaux1.txt\nanimaux1.txt contient 4 lignes.\n$ python compte_lignes.py animaux2.txt\nanimaux2.txt contient 3 lignes.\n$ python compte_lignes.py animaux3.txt\nERREUR : animaux3.txt n'existe pas.\n9.8.11 Détermination du nombre pi par la méthode Monte Carlo (exercice +++)\nSoit un cercle de rayon 1 (en trait plein sur la figure 9.1) inscrit dans un carré de côté 2 (en trait pointillé).\n2 π 2 π\nAvec R = 1, l’aire du carré vaut (2R) soit 4 et l’aire du disque délimité par le cercle vaut R soit .\nEn choisissant N points aléatoires (à l’aide d’une distribution uniforme) à l’intérieur du carré, la probabilité que ces\npoints se trouvent aussi dans le cercle est :\nπ\naire du cercle\np = =\naire du carré 4\nSoit n, le nombre de points effectivement dans le cercle, il vient alors\nπ\nn\np = = ,\nN 4\nd’où\nn\nπ ×\n= .\n4\nN\nπ\nDéterminez une approximation de par cette méthode. Pour cela, pour N itérations :\n86 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n9.8. Exercices Chapitre 9. Modules\nFigure 9.1 – Cercle de rayon 1 inscrit dans un carré de côté 2.\n1. Choisissez aléatoirement les coordonnées x et y d’un point entre -1 et 1. Utilisez la fonction du module\nuniform()\nrandom.\n2. Calculez la distance entre le centre du cercle et ce point.\n3. Déterminez si cette distance est inférieure au rayon du cercle, c’est-à-dire si le point est dans le cercle ou pas.\n4. Si le point est effectivement dans le cercle, incrémentez le compteur n.\nπ π\nFinalement calculez le rapport entre n et N et proposez une estimation de . Quelle valeur de obtenez-vous pour\nπ\n100 itérations ? 1000 itérations ? 10 000 itérations ? Comparez les valeurs obtenues à la valeur de fournie par le module\nmath.\nOn rappelle que la distance d entre deux points A et B de coordonnées respectives (x ,y ) et (x ,y ) se calcule\nA A B B\ncomme :\n√\n− −\nd = (x x )2 +(y y )2\nB A B A\n25\nPour vous aider, consultez la documentation de la fonction .\nrandom.uniform()\n25. https://docs.python.org/fr/3/library/random.html#random.uniform\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 87"
  },
  {
    "title": "Principe et généralités",
    "content": "En programmation, les fonctions sont très utiles pour réaliser plusieurs fois la même opération au sein d’un programme.\nElles rendent également le code plus lisible et plus clair en le fractionnant en blocs logiques.\nVous connaissez déjà certaines fonctions Python. Par exemple du module renvoie le cosinus\nmath.cos(angle) math\nde la variable exprimé en radian. Vous connaissez aussi des fonctions internes à Python comme ou\nangle range()\n. Pour l’instant, une fonction est à vos yeux une sorte de « boîte noire » :\nlen()\n1. À laquelle vous passez aucune, une ou plusieurs variable(s) entre parenthèses. Ces variables sont appelées argu-\nments. Il peut s’agir de n’importe quel type d’objet Python.\n2. Qui effectue une action.\n3. Qui renvoie un objet Python ou rien du tout.\nTout cela est illustré schématiquement dans la figure ci-dessous.\nFigure 10.1 – Fonctionnement schématique d’une fonction.\nPar exemple, si vous appelez la fonction de la manière suivante :\nlen()\n88\n10.2. Définition Chapitre 10. Fonctions\n1\n>>> len([0, 1, 2])\n2 3\nvoici ce qu’il se passe :\n1. vous appelez en lui passant une liste en argument (ici la liste ) ;\nlen() [0, 1, 2]\n2. la fonction calcule la longueur de cette liste ;\n3. elle vous renvoie un entier égal à cette longueur.\nAutre exemple, si vous appelez la méthode (n’oubliez pas, une méthode est une fonction qui\nma_liste.append()\nagit sur l’objet auquel elle est attachée par un point) :\n1 >>> ma_liste.append(5)\n1. Vous passez l’entier en argument ;\n5\n2. la méthode ajoute l’entier à l’objet ;\nappend() 5 ma_liste\n3. et elle ne renvoie rien.\nAux yeux du programmeur, au contraire, une fonction est une portion de code effectuant une suite d’instructions bien\nparticulière. Mais avant de vous présenter la syntaxe et la manière de construire une fonction, revenons une dernière fois\nsur cette notion de « boîte noire » :\n•\nUne fonction effectue une tâche. Pour cela, elle reçoit éventuellement des arguments et renvoie éventuellement\nquelque chose. L’algorithme utilisé au sein de la fonction n’intéresse pas directement l’utilisateur. Par exemple, il\nest inutile de savoir comment la fonction calcule un cosinus. On a juste besoin de savoir qu’il faut lui\nmath.cos()\npasser en argument un angle en radian, et qu’elle renvoie le cosinus de cet angle. Ce qui se passe à l’intérieur de\nla fonction ne regarde que le programmeur.\n•\nChaque fonction effectue en général une tâche unique et précise. Si cela se complique, il est plus judicieux d’écrire\nplusieurs fonctions (qui peuvent éventuellement s’appeler les unes les autres). Cette modularité améliore la qualité\ngénérale et la lisibilité du code. Vous verrez qu’en Python, les fonctions présentent une grande flexibilité.\nPour finir sur les généralités, nous avons utilisé dans la Figure ci-dessus le terme programme principal (main en\nanglais), pour désigner l’endroit depuis lequel on appelle une fonction (on verra plus tard que l’on peut en fait appeler\nune fonction de n’importe où). Le programme principal désigne le code qui est exécuté lorsqu’on lance le script Python,\nc’est-à-dire toute la suite d’instructions en dehors des fonctions. En général, dans un script Python, on écrit d’abord les\nfonctions, puis le programme principal. Nous aurons l’occasion de revenir sur cette notion de programme principal plus\ntard dans ce chapitre, ainsi que dans le chapitre 13 Plus sur les fonctions."
  },
  {
    "title": "Définition",
    "content": "Pour définir une fonction, Python utilise le mot-clé . Si on souhaite que la fonction renvoie quelque chose, il faut\ndef\nutiliser le mot-clé . Par exemple :\nreturn\n1\n>>> def carre(x):\n2 ... return x**2\n3\n...\n4 >>> print(carre(2))\n5\n4\nNotez que la syntaxe de utilise les deux-points comme les boucles et ainsi que les tests : un bloc\ndef for while if\nd’instructions est donc attendu. De même que pour les boucles et les tests, l’indentation de ce bloc d’instructions (qu’on\nappelle le corps de la fonction) est obligatoire.\nDans l’exemple précédent, nous avons passé un argument à la fonction , qui nous a renvoyé (ou retourné)\ncarre()\nune valeur que nous avons immédiatement aﬀichée à l’écran avec l’instruction . Que veut dire valeur renvoyée ?\nprint()\nEt bien cela signifie que cette dernière est récupérable dans une variable :\n1 >>> res = carre(2)\n2\n>>> print(res)\n3 4\nIci, le résultat renvoyé par la fonction est stocké dans la variable . Notez qu’une fonction ne prend pas forcément\nres\nun argument et ne renvoie pas forcément une valeur, par exemple :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 89\nChapitre 10. Fonctions 10.3. Passage d’arguments\n1\n>>> def hello():\n2 ... print(\"bonjour\")\n3\n...\n4 >>> hello()\n5\nbonjour\nDans ce cas, la fonction se contente d’aﬀicher la chaîne de caractères à l’écran. Elle ne prend\nhello() \"bonjour\"\naucun argument et ne renvoie rien. Par conséquent, cela n’a pas de sens de vouloir récupérer dans une variable le résultat\nrenvoyé par une telle fonction. Si on essaie tout de même, Python affecte la valeur qui signifie rien en anglais :\nNone\n1 >>> var = hello()\n2 bonjour\n3 >>> print(var)\n4 None\nCeci n’est pas une faute car Python n’émet pas d’erreur, toutefois cela ne présente, la plupart du temps, guère\nd’intérêt."
  },
  {
    "title": "Passage d’arguments",
    "content": "Le nombre d’arguments que l’on peut passer à une fonction est variable. Nous avons vu ci-dessus des fonctions\nauxquelles on passait zero ou un argument. Dans les chapitres précédents, vous avez rencontré des fonctions internes à\nPython qui prenaient au moins deux arguments. Souvenez-vous par exemple de ou encore\nrange(1, 10) range(1,\n. Le nombre d’arguments est donc laissé libre à l’initiative du programmeur qui développe une nouvelle fonction.\n10, 2)\nUne particularité des fonctions en Python est que vous n’êtes pas obligé de préciser le type des arguments que vous\nlui passez, dès lors que les opérations que vous effectuez avec ces arguments sont valides. Python est en effet connu\ncomme étant un langage au « typage dynamique », c’est-à-dire qu’il reconnaît pour vous le type des variables au moment\nde l’exécution. Par exemple :\n1\n>>> def fois(x, y):\n2 ... return x*y\n3\n...\n4 >>> fois(2, 3)\n5\n6\n6 >>> fois(3.1415, 5.23)\n7\n16.430045000000003\n8 >>> fois(\"to\", 2)\n9 'toto'\n10 >>> fois([1,3], 2)\n11 [1, 3, 1, 3]\nL’opérateur reconnaît plusieurs types (entiers, floats, chaînes de caractères, listes). Notre fonction est donc\n* fois()\ncapable d’effectuer des tâches différentes ! Même si Python autorise cela, méfiez-vous tout de même de cette grande\nflexibilité qui pourrait conduire à des surprises dans vos futurs programmes. En général, il est plus judicieux que chaque\nargument ait un type précis (entiers, floats, chaînes de caractères, etc.) et pas l’un ou l’autre."
  },
  {
    "title": "Renvoi de résultats",
    "content": "Un énorme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets à la fois, comme dans\ncette fraction de code :\n1 >>> def carre_cube(x):\n2\n... return x**2, x**3\n3 ...\n4\n>>> carre_cube(2)\n5 (4, 8)\nEn réalité Python ne renvoie qu’un seul objet, mais celui-ci peut être séquentiel, c’est-à-dire contenir lui-même\nd’autres objets. Dans notre exemple, Python renvoie un objet de type , type que nous avons vu dans le chapitre\ntuple\n8 Dictionnaires et tuples (souvenez-vous, il s’agit d’une sorte de liste avec des propriétés différentes). Notre fonction\npourrait tout autant renvoyer une liste :\n90 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n10.5. Arguments positionnels et arguments par mot-clé Chapitre 10. Fonctions\n1\n>>> def carre_cube2(x):\n2 ... return [x**2, x**3]\n3\n...\n4 >>> carre_cube2(3)\n5\n[9, 27]\nRenvoyer un tuple ou une liste de deux éléments (ou plus) est très pratique en conjonction avec l’affectation multiple,\npar exemple :\n1\n>>> z1, z2 = carre_cube2(3)\n2 >>> z1\n3 9\n4 >>> z2\n5 27\nCela permet de récupérer plusieurs valeurs renvoyées par une fonction et de les affecter à la volée à des variables\ndifférentes.\nUne fonction peut aussi renvoyer un booléen :\n1 def est_pair(x):\n2 if x % 2 == 0:\n3\nreturn True\n4 else:\n5\nreturn False\n6\n7\n# Programme principal.\n8 for chiffre in range(1, 5):\n9\nif est_pair(chiffre):\n10 print(f\"{chiffre} est pair\")\nComme la fonction renvoie un booléen, on peut utiliser la notation qui équivaut à\nif est_pair(chiffre): if\n. Il est courant d’appeler une fonction qui renvoie un booléen\nest_pair(chiffre) == True: est_quelquechose()\ncar on comprend que ça pose la question si c’est vrai ou faux. En anglais, on trouvera la notation . Nous\nis_even()\nreverrons ces notions dans le chapitre 13 Plus sur les fonctions."
  },
  {
    "title": "Arguments positionnels et arguments par mot-clé",
    "content": "Jusqu’à maintenant, nous avons systématiquement passé le nombre d’arguments que la fonction attendait. Que se\npasse-t-il si une fonction attend deux arguments et que nous ne lui en passons qu’un seul ?\n1 >>> def fois(x, y):\n2\n... return x*y\n3 ...\n4 >>> fois(2, 3)\n5 6\n6 >>> fois(2)\n7\nTraceback (most recent call last):\n8 File \"<stdin>\", line 1, in <module>\n9\nTypeError: fois() missing 1 required positional argument: 'y'\nOn constate que passer un seul argument à une fonction qui en attend deux conduit à une erreur.\nDéfinition\nLorsqu’on définit une fonction les arguments et sont appelés arguments positionnels (en\ndef fct(x, y): x y\nanglais, positional arguments). Il est strictement obligatoire de les préciser lors de l’appel de la fonction. De plus, il est\nnécessaire de respecter le même ordre lors de l’appel que dans la définition de la fonction. Dans l’exemple ci-dessus,\n2\ncorrespondra à et correspondra à . Finalement, tout dépendra de leur position, d’où leur qualification de positionnel.\nx 3 y\nMais il est aussi possible de passer un ou plusieurs argument(s) de manière facultative et de leur attribuer une valeur\npar défaut :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 91\nChapitre 10. Fonctions 10.5. Arguments positionnels et arguments par mot-clé\n1\n>>> def fct(x=1):\n2 ... return x\n3\n...\n4 >>> fct()\n5\n1\n6 >>> fct(10)\n7 10\nDéfinition\nUn argument défini avec une syntaxe est appelé argument par mot-clé (en anglais, keyword\ndef fct(arg=val):\nargument). Le passage d’un tel argument lors de l’appel de la fonction est facultatif. Ce type d’argument ne doit pas être\nconfondu avec les arguments positionnels présentés ci-dessus, dont la syntaxe est .\ndef fct(arg):\nIl est bien sûr possible de passer plusieurs arguments par mot-clé :\n1 >>> def fct(x=0, y=0, z=0):\n2 ... return x, y, z\n3\n...\n4 >>> fct()\n5\n(0, 0, 0)\n6 >>> fct(10)\n7\n(10, 0, 0)\n8 >>> fct(10, 8)\n9\n(10, 8, 0)\n10 >>> fct(10, 8, 3)\n11\n(10, 8, 3)\nOn observe que pour l’instant, les arguments par mot-clé sont pris dans l’ordre dans lesquels on les passe lors de\nl’appel. Comment faire si l’on souhaitait préciser l’argument par mot-clé et garder les valeurs de et par défaut ?\nz x y\nSimplement en précisant le nom de l’argument lors de l’appel :\n1 >>> fct(z=10)\n2 (0, 0, 10)\nPython permet même de rentrer les arguments par mot-clé dans un ordre arbitraire :\n1 >>> fct(z=10, x=3, y=80)\n2\n(3, 80, 10)\n3 >>> fct(z=10, y=80)\n4\n(0, 80, 10)\nQue se passe-t-il lorsque nous avons un mélange d’arguments positionnels et par mot-clé ? Et bien les arguments\npositionnels doivent toujours être placés avant les arguments par mot-clé :\n1\n>>> def fct(a, b, x=0, y=0, z=0):\n2 ... return a, b, x, y, z\n3\n...\n4 >>> fct(1, 1)\n5\n(1, 1, 0, 0, 0)\n6 >>> fct(1, 1, z=5)\n7 (1, 1, 0, 0, 5)\n8\n>>> fct(1, 1, z=5, y=32)\n9 (1, 1, 0, 32, 5)\nOn peut toujours passer les arguments par mot-clé dans un ordre arbitraire à partir du moment où on précise leur\nnom. Par contre, si les deux arguments positionnels et ne sont pas passés à la fonction, Python renvoie une erreur.\na b\n1 >>> fct(z=0)\n2\nTraceback (most recent call last):\n3 File \"<stdin>\", line 1, in <module>\n4\nTypeError: fct() missing 2 required positional arguments: 'a' and 'b'\n92 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n10.6. Variables locales et variables globales Chapitre 10. Fonctions\nConseil\nPréciser le nom des arguments par mot-clé lors de l’appel d’une fonction est une pratique que nous vous recommandons.\nCela les distingue clairement des arguments positionnels.\nL’utilisation d’arguments par mot-clé est habituelle en Python. Elle permet de modifier le comportement par défaut\nde nombreuses fonctions. Par exemple, si on souhaite que la fonction n’aﬀiche pas un retour à la ligne, on peut\nprint()\nutiliser l’argument :\nend\n1\n>>> print(\"Message \", end=\"\")\n2 Message >>>\nNous verrons, dans le chapitre 25 Fenêtres graphiques et Tkinter (en ligne), que l’utilisation d’arguments par mot-clé\nest systématique lorsqu’on crée un objet graphique (une fenêtre, un bouton, etc.)."
  },
  {
    "title": "Variables locales et variables globales",
    "content": "Lorsqu’on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une\nvariable est dite locale lorsqu’elle est créée dans une fonction. Elle n’existera et ne sera visible que lors de l’exécution de\nladite fonction.\nUne variable est dite globale lorsqu’elle est créée dans le programme principal. Elle sera visible partout dans le\nprogramme.\nCeci ne vous paraît pas clair ? Nous allons prendre un exemple simple qui vous aidera à mieux saisir ces concepts.\nObservez le code suivant :\n1\n# Définition d'une fonction carre().\n2 def carre(x):\n3\ny = x**2\n4 return y\n5\n6 # Programme principal.\n7\nvar = 5\n8 resultat = carre(var)\n9 print(resultat)\n1\nPour la suite des explications, nous allons utiliser l’excellent site Python Tutor qui permet de visualiser l’état des\nvariables au fur et à mesure de l’exécution d’un code Python. Avant de poursuivre, nous vous conseillons de prendre 5\nminutes pour tester ce site.\nRegardons maintenant ce qui se passe dans le code ci-dessus, étape par étape :\n•\nÉtape 1 : Python est prêt à lire la première ligne de code.\n1. http://www.pythontutor.com\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 93\nChapitre 10. Fonctions 10.6. Variables locales et variables globales\n•\nÉtape 2 : Python met en mémoire la fonction . Notez qu’il ne l’exécute pas ! La fonction est mise dans\ncarre()\nun espace de la mémoire nommé Global frame, il s’agit de l’espace du programme principal. Dans cet espace\nseront stockées toutes les variables globales créées dans le programme. Python est maintenant prêt à exécuter le\nprogramme principal.\n•\nÉtape 3 : Python lit et met en mémoire la variable . Celle-ci étant créée dans le programme principal, il s’agira\nvar\nd’une variable globale. Ainsi, elle sera également stockée dans le Global frame.\n•\nÉtape 4 : La fonction est appelée et on lui passe en argument l’entier . La fonction s’exécute et\ncarre() var\nun nouveau cadre est créé dans lequel Python Tutor va indiquer toutes les variables locales à la fonction. Notez\nbien que la variable passée en argument, qui s’appelle dans la fonction, est créée en tant que variable locale. On\nx\nremarquera aussi que les variables globales situées dans le Global frame sont toujours là.\n94 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n10.6. Variables locales et variables globales Chapitre 10. Fonctions\n•\nÉtape 5 : Python est maintenant prêt à exécuter chaque ligne de code de la fonction.\n•\nÉtape 6 : La variable est créée dans la fonction. Celle-ci est donc stockée en tant que variable locale à la fonction.\ny\n•\nÉtape 7 : Python s’apprête à renvoyer la variable locale au programme principal. Python Tutor nous indique le\ny\ncontenu de la valeur renvoyée.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 95\nChapitre 10. Fonctions 10.6. Variables locales et variables globales\n•\nÉtape 8 : Python quitte la fonction et la valeur renvoyée par celle-ci est affectée à la variable globale .\nresultat\nNotez bien que lorsque Python quitte la fonction, l’espace des variables alloué à la fonction est détruit. Ainsi,\ntoutes les variables créées dans la fonction n’existent plus. On comprend pourquoi elles portent le nom de locales\npuisqu’elles n’existent que lorsque la fonction est exécutée.\n•\nÉtape 9 : Python aﬀiche le contenu de la variable et l’exécution est terminée.\nresultat\nNous espérons que cet exemple guidé facilitera la compréhension des concepts de variables locales et globales. Cela\nviendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 13 Plus sur les fonctions.\n96 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n10.7. Principe DRY Chapitre 10. Fonctions\nD’ici là, essayez de vous entraîner au maximum avec les fonctions. C’est un concept ardu, mais il est impératif de le\nmaîtriser.\nEnfin, comme vous avez pu le constater, Python Tutor nous a grandement aidé à comprendre ce qui se passait.\nN’hésitez pas à l’utiliser sur des exemples ponctuels, ce site vous aidera à visualiser ce qui se passe lorsqu’un code ne fait\npas ce que vous attendez."
  },
  {
    "title": "Principe DRY",
    "content": "2\nL’acronyme DRY signifie Don’t Repeat Yourself. Les fonctions permettent de satisfaire ce principe en évitant la\nduplication de code. En effet, plus un code est dupliqué plusieurs fois dans un programme, plus il sera source d’erreurs,\nnotamment lorsqu’il faudra le faire évoluer.\nConsidérons par exemple le code suivant qui convertit plusieurs températures des degrés Fahrenheit en degrés Celsius :\n1 >>> temp_in_fahrenheit = 60\n2 >>> (temp_in_fahrenheit - 32) * (5/8)\n3 17.5\n4\n>>> temp_in_fahrenheit = 80\n5 >>> (temp_in_fahrenheit - 32) * (5/8)\n6\n30.0\n7 >>> temp_in_fahrenheit = 100\n8\n>>> (temp_in_fahrenheit - 32) * (5/8)\n9 42.5\nMalheureusement, il y a une erreur dans la formule de conversion. En effet, la formule exacte est :\n5\n− ×\ntemp_celsius = (temp_fahrenheit 32)\n9\nIl faut alors reprendre les lignes 2, 5 et 8 précédentes et les corriger. Cela n’est pas eﬀicace, surtout si le même code\nest utilisé à différents endroits dans le programme.\nEn écrivant qu’une seule fois la formule de conversion dans une fonction, on applique le principe DRY :\n1 >>> def convert_fahrenheit_to_celsius(temperature):\n2\n... return (temperature - 32) * (5/9)\n3 ...\n4\n>>> temp_in_fahrenheit = 60\n5 >>> convert_fahrenheit_to_celsius(temp_in_fahrenheit)\n6 15.555555555555557\n7 >>> temp_in_fahrenheit = 80\n8 >>> convert_fahrenheit_to_celsius(temp_in_fahrenheit)\n9\n26.666666666666668\n10 >>> temp_in_fahrenheit = 100\n11\n>>> convert_fahrenheit_to_celsius(temp_in_fahrenheit)\n12 37.77777777777778\nEt s’il y a une erreur dans la formule, il suﬀira de ne la corriger qu’une seule fois, dans la fonction\nconvert_fahrenheit_to_celsius\n.\n()"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour le premier exercice, utilisez Python Tutor. Pour les exercices suivants, créez des scripts puis exécutez-les dans\nun shell.\n10.8.1 Carré et factorielle\n3\nReprenez l’exemple précédent à l’aide du site Python Tutor :\n2. https://www.earthdatascience.org/courses/intro-to-earth-data-science/write-efficient-python-code/\nintro-to-clean-code/dry-modular-code/\n3. http://www.pythontutor.com\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 97\nChapitre 10. Fonctions 10.8. Exercices\n1\n# Définition d'une fonction carre().\n2 def carre(x):\n3\ny = x**2\n4 return y\n5\n6 # Programme principal.\n7 z = 5\n8\nresultat = carre(z)\n9 print(resultat)\nAnalysez ensuite le code suivant et tentez de prédire sa sortie :\n1 def calc_factorielle(n):\n2\nfact = 1\n3 for i in range(2, n+1):\n4\nfact = fact * i\n5 return fact\n6\n7\n# Programme principal.\n8 nb = 4\n9\nfactorielle_nb = calc_factorielle(nb)\n10 print(f\"{nb}! = {factorielle_nb}\")\n11\nnb2 = 10\n12 print(f\"{nb2}! = {calc_factorielle(nb2)}\")\nTestez ensuite cette portion de code avec Python Tutor, en cherchant à bien comprendre chaque étape. Avez-vous\nréussi à prédire la sortie correctement ?\nRemarque\nUne remarque concernant l’utilisation des f-strings que nous avions abordées dans le chapitre 3 Aﬀichage. On découvre\nici une autre possibilité des f-strings dans l’instruction : il est en effet\nf\"{nb2}! = {calc_factorielle(nb2)}\"\npossible d’appeler entre les accolades une fonction (ici ) ! Ainsi, il n’est pas nécessaire de\n{calc_factorielle(nb2)}\ncréer une variable intermédiaire dans laquelle on stocke ce que retourne la fonction.\n10.8.2 Puissance\ny\nCréez une fonction qui renvoie x en utilisant l’opérateur . Pour rappel :\ncalc_puissance(x, y) **\n1 >>> 2**2\n2\n4\n3 >>> 2**3\n4\n8\n5 >>> 2**4\n6\n16\ni\nDans le programme principal, calculez et aﬀichez à l’écran 2 avec i variant de 0 à 20 inclus. On souhaite que le\nrésultat soit présenté avec le formatage suivant :\n2^ 0 = 1\n2^ 1 = 2\n2^ 2 = 4\n[...]\n2^20 = 1048576\n10.8.3 Pyramide\nReprenez l’exercice du chapitre 5 Boucles et comparaisons qui dessine une pyramide.\nDans un script , créez une fonction à laquelle vous passez un nombre entier et qui\npyra.py gen_pyramide() N\nrenvoie une pyramide de N lignes sous forme de chaîne de caractères. Le programme principal demandera à l’utilisateur\nle nombre de lignes souhaitées (utilisez pour cela la fonction ) et aﬀichera la pyramide à l’écran.\ninput()\n98 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n10.8. Exercices Chapitre 10. Fonctions\n10.8.4 Nombres premiers\nReprenez l’exercice du chapitre 6 Tests sur les nombres premiers.\nCréez une fonction qui prend comme argument un nombre entier positif n (supérieur à 2), et qui\nest_premier()\nrenvoie le booléen si n est premier et si n n’est pas premier. Déterminez tous les nombres premiers de 2 à\nTrue False\n100. On souhaite avoir une sortie similaire à celle-ci :\n2 est premier\n3 est premier\n4 n'est pas premier\n[...]\n100 n'est pas premier\n10.8.5 Séquence complémentaire\nCréez une fonction qui prend comme argument une liste de bases et qui renvoie la séquence complé-\nseq_comp()\nmentaire d’une séquence d’ADN sous forme de liste.\nDans le programme principal, à partir de la séquence d’ADN\nseq = [\"A\", \"T\", \"C\", \"G\", \"A\", \"T\", \"C\", \"G\", \"A\", \"T\", \"C\"]\naﬀichez et sa séquence complémentaire (en utilisant votre fonction ).\nseq seq_comp()\nRappel : la séquence complémentaire s’obtient en remplaçant A par T, T par A, C par G et G par C.\n10.8.6 Distance 3D\nCréez une fonction qui calcule la distance euclidienne en trois dimensions entre deux atomes.\ncalc_distance_3D()\n√\nTestez votre fonction sur les 2 points et . Trouvez-vous bien ?\n3\nA(0,0,0) B(1,1,1)\nOn rappelle que la distance euclidienne d entre deux points A et B de coordonnées cartésiennes respectives (x ,y ,z )\nA A A\net ( , , ) se calcule comme suit :\nx y z\nB B B\n√\n− − −\n2 2 2\nd = (x x ) +(y y ) +(z z )\nB A B A B A\n10.8.7 Distribution et statistiques\nCréez une fonction qui prend comme argument trois entiers : debut, fin et n. La fonction renverra\ngen_distrib()\nune liste de n floats aléatoires entre debut et fin. Pour générer un nombre aléatoire dans un intervalle donné, utilisez la\nfonction du module random, dont voici quelques exemples d’utilisation :\nuniform()\n1 >>> import random\n2 >>> random.uniform(1, 10)\n3 8.199672607202174\n4\n>>> random.uniform(1, 10)\n5 2.607528561528022\n6\n>>> random.uniform(1, 10)\n7 9.000404025130946\nAvec la fonction , les bornes passées en argument sont incluses, c’est-à-dire qu’ici, le nombre\nrandom.uniform()\naléatoire renvoyé est dans l’intervalle [1, 10].\nCréez une autre fonction qui prend en argument une liste de floats et qui renvoie une liste de trois\ncalc_stat()\néléments contenant respectivement le minimum, le maximum et la moyenne de la liste.\nDans le programme principal, générez 20 listes aléatoires de 100 floats compris entre 0 et 100 et aﬀichez le minimum\n( ), le maximum ( ) et la moyenne pour chacune d’entre elles. La moyenne pourra être calculée avec les\nmin() max()\nfonctions et .\nsum() len()\nPour chacune des 20 listes, aﬀichez les statistiques (valeur minimale, valeur maximale et moyenne) avec deux chiffres\naprès la virgule :\nListe 1 : min = 0.17 ; max = 99.72 ; moyenne = 57.38\nListe 2 : min = 1.25 ; max = 99.99 ; moyenne = 47.41\n[...]\nListe 19 : min = 1.05 ; max = 99.36 ; moyenne = 49.43\nListe 20 : min = 1.33 ; max = 97.63 ; moyenne = 46.53\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 99\nChapitre 10. Fonctions 10.8. Exercices\nLes écarts sur les statistiques entre les différentes listes sont-ils importants ? Relancez votre script avec des listes de\n1000 éléments, puis 10 000 éléments. Les écarts changent-ils quand le nombre d’éléments par liste augmente ?\n10.8.8 Distance à l’origine (exercice +++)\nEn reprenant votre fonction de calcul de distance euclidienne en trois dimensions , faites-en\ncalc_distance_3D()\nune version pour deux dimensions que vous appellerez .\ncalc_distance_2D()\nCréez une autre fonction , à laquelle vous passez en argument deux listes de floats et\ncalc_dist2ori() list_x\nreprésentant les coordonnées d’une fonction mathématique (par exemple et ( )). Cette fonction renverra\nx sin x\nlist_y\nune liste de floats représentant la distance entre chaque point de la fonction et l’origine (de coordonnées (0,0)).\nLa figure 10.2 montre un exemple sur quelques points de la fonction sin(x) (courbe en trait épais). Chaque trait\npointillé représente la distance que l’on cherche à calculer entre les points de la courbe et l’origine du repère de coordonnées\n(0,0).\nFigure 10.2 – Illustration de la distance à l’origine.\nVotre programme générera un fichier qui contiendra deux colonnes : la première représente les x, la\nsin2ori.dat\nseconde la distance entre chaque point de la fonction sin(x) à l’origine.\nEnfin, pour visualiser votre résultat, ajoutez le code suivant tout à la fin de votre script :\n100 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n10.8. Exercices Chapitre 10. Fonctions\n1\n# Création d'une image pour la visualisation du résultat.\n2 import matplotlib.pyplot as plt\n3\n4 x = []\n5\ny = []\n6 with open(\"sin2ori.dat\", \"r\") as f_in:\n7 for line in f_in:\n8\ncoords = line.split()\n9 x.append(float(coords[0]))\n10\ny.append(float(coords[1]))\n11 fig, ax = plt.subplots(figsize=(6, 6))\n12\nax.plot(x, y)\n13 ax.set_xlabel(\"x\")\n14\nax.set_ylabel(\"Distance de sin(x) à l'origine\")\n15 fig.savefig(\"sin2ori.png\")\nOuvrez l’image .\nsin2ori.png\nRemarque\nLe module matplotlib sera expliqué en détail dans le chapitre 21 Module matplotlib.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 101"
  },
  {
    "title": "Préambule",
    "content": "Nous avons déjà abordé les chaînes de caractères dans les chapitres 2 Variables et 3 Aﬀichage. Ici nous allons un peu\n1\nplus loin, notamment avec les méthodes associées aux chaînes de caractères ."
  },
  {
    "title": "Chaînes de caractères et listes",
    "content": "Les chaînes de caractères peuvent être considérées comme des listes (de caractères) un peu particulières :\n1 >>> animaux = \"girafe tigre\"\n2\n>>> animaux\n3 'girafe tigre'\n4\n>>> len(animaux)\n5 12\n6 >>> animaux[3]\n7\n'a'\nNous pouvons donc utiliser certaines propriétés des listes comme les tranches :\n1 >>> animaux = \"girafe tigre\"\n2\n>>> animaux[0:4]\n3 'gira'\n4\n>>> animaux[9:]\n5 'gre'\n6\n>>> animaux[:-2]\n7 'girafe tig'\n8\n>>> animaux[1:-2:2]\n9 'iaetg'\nMais a contrario des listes, les chaînes de caractères présentent toutefois une différence notable, ce sont des listes\nnon modifiables. Une fois une chaîne de caractères définie, vous ne pouvez plus modifier un de ses éléments. Le cas\néchéant, Python renvoie un message d’erreur :\n1. https://docs.python.org/fr/3/library/string.html\n102\n11.3. Caractères spéciaux Chapitre 11. Plus sur les chaînes de caractères\n1\n>>> animaux = \"girafe tigre\"\n2 >>> animaux[4]\n3\n'f'\n4 >>> animaux[4] = \"F\"\n5\nTraceback (most recent call last):\n6 File \"<stdin>\", line 1, in <module>\n7 TypeError: 'str' object does not support item assignment\nPar conséquent, si vous voulez modifier une chaîne de caractères, vous devez en construire une nouvelle. Pour cela,\nn’oubliez pas que les opérateurs de concaténation ( ) et de duplication ( ) (introduits dans le chapitre 2 Variables)\n+ *\npeuvent vous aider. Vous pouvez également générer une liste, qui elle est modifiable, puis revenir à une chaîne de\ncaractères (voir plus bas)."
  },
  {
    "title": "Caractères spéciaux",
    "content": "Il existe certains caractères spéciaux comme que nous avons déjà vu (pour le retour à la ligne). Le caractère\n\\n \\t\nproduit une tabulation. Si vous voulez écrire des guillemets simples ou doubles et que ceux-ci ne soient pas confondus\navec les guillemets de déclaration de la chaîne de caractères, vous pouvez utiliser ou :\n\\' \\\"\n1\n>>> print(\"Un backslash n\\npuis un backslash t\\t puis un guillemet\\\"\")\n2 Un backslash n\n3\npuis un backslash t puis un guillemet\"\n4 >>> print('J\\'affiche un guillemet simple')\n5\nJ'affiche un guillemet simple\nVous pouvez aussi utiliser astucieusement des guillemets doubles ou simples pour déclarer votre chaîne de caractères :\n1 >>> print(\"Un brin d'ADN\")\n2 Un brin d'ADN\n3\n>>> print('Python est un \"super\" langage de programmation')\n4 Python est un \"super\" langage de programmation\nQuand on souhaite écrire un texte sur plusieurs lignes, il est très commode d’utiliser les guillemets triples qui conservent\nle formatage (notamment les retours à la ligne) :\n1\n>>> x = \"\"\"souris\n2 ... chat\n3\n... abeille\"\"\"\n4 >>> x\n5\n'souris\\nchat\\nabeille'\n6 >>> print(x)\n7\nsouris\n8 chat\n9\nabeille\nAttention, les caractères spéciaux n’apparaissent intérprétés que lorsqu’ils sont utilisés avec la fonction . Par\nprint()\nexemple, le n’apparait comme un retour à la ligne que lorsqu’il est dans une chaîne de caractères passée à la fonction\n\\n\n:\nprint()\n1\n>>> \"bla\\nbla\"\n2 'bla\\nbla'\n3\n>>> print(\"bla\\nbla\")\n4 bla\n5\nbla"
  },
  {
    "title": "Préfixe de chaîne de caractères",
    "content": "Nous avons vu au chapitre 3 Aﬀichage la notion de f-string. Il s’agit d’un mécanisme pour formater du texte au sein\nd’une chaîne de caractères. Par exemple :\n1\n>>> var = \"f-string\"\n2 >>> f\"voici une belle {var}\"\n3\n'voici une belle f-string'\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 103\nChapitre 11. Plus sur les chaînes de caractères 11.4. Préfixe de chaîne de caractères\nQue signifie le que l’on accole aux guillemets de la chaîne de caractères ? Celui-ci est appelé « préfixe de chaîne de\nf\ncaractères » ou stringprefix.\nRemarque\nUn stringprefix modifie la manière dont Python va interpréter ladite string. Celui-ci doit être systématiquement «\ncollé » à la chaîne de caractères, c’est-à-dire sans espace entre les deux.\nIl existe différents stringprefixes en Python, nous vous montrons ici les deux qui nous apparaissent les plus importants.\n•\nLe préfixe mis pour raw string, qui force la non-interprétation des caractères spéciaux :\nr\n1 >>> s = \"Voici un retour à la ligne\\nEt là une autre ligne\"\n2\n>>> s\n3 'Voici un retour à la ligne\\nEt là une autre ligne'\n4 >>> print(s)\n5\nVoici un retour à la ligne\n6 Et là une autre ligne\n7\n>>> s = r\"Voici un retour à la ligne\\nEt là une autre ligne\"\n8 >>> s\n9\n'Voici un retour à la ligne\\\\nEt là une autre ligne'\n10 >>> print(s)\n11\nVoici un retour à la ligne\\nEt là une autre ligne\nL’ajout du va forcer Python à ne pas interpréter le comme un retour à la ligne, mais comme un backslash littéral\nr \\n\nsuivi d’un n. Quand on demande à l’interpréteur d’aﬀicher cette chaîne de caractères, celui-ci met deux backslashes\npour signifier qu’il s’agit d’un backslash littéral (le premier échappe le second). Finalement, l’utilisation de la syntaxe\nrenvoie une chaîne de caractères normale, puisqu’on\nr\"Voici un retour à la ligne\\nEt là une autre ligne\"\nvoit ensuite que le a disparu lorsqu’on demande à Python d’aﬀicher le contenu de la variable . Comme dans\nr s var = 2\n, d’abord Python évalue . Puis ce résultat est affecté à la variable . Enfin, on notera que seule l’utilisation\n+ 2 2 + 2 var\ndu mène à l’interprétation des caractères spéciaux comme , comme expliqué dans la rubrique précédente.\nprint() \\n\nLes caractères spéciaux non interprétés dans les raw strings sont de manière générale tout ce dont le backslash modifie\nla signification, par exemple un , un , etc.\n\\n \\t\n•\nLe préfixe mis pour formatted string, qui met en place l’écriture formatée comme vue au chapitre 3 Aﬀichage :\nf\n1 >>> animal = \"renard\"\n2\n>>> animal2 = \"poulain\"\n3 >>> s = f\"Le {animal} est un animal gentil\\nLe {animal2} aussi\"\n4\n>>> s\n5 'Le renard est un animal gentil\\nLe poulain aussi'\n6\n>>> print(s)\n7 Le renard est un animal gentil\n8\nLe poulain aussi\n9 >>> s = \"Le {animal} est un animal gentil\\nLe {animal2} aussi\"\n10 >>> s\n11\n'Le {animal} est un animal gentil\\nLe {animal2} aussi'\n12 >>> print(s)\n13\nLe {animal} est un animal gentil\n14 Le {animal2} aussi\nLa f-string remplace le contenu des variables situées entre les accolades et interprète le comme un retour à la\n\\n\nligne. Pour rappel, consultez le chapitre 3 si vous souhaitez plus de détails sur le fonctionnement des f-strings.\nConseil\nIl existe de nombreux autres détails concernant les préfixes qui vont au-delà de ce cours. Pour en savoir plus, vous\n2\npouvez consulter la documentations oﬀicielle .\n2. https://docs.python.org/fr/3/reference/lexical_analysis.html#grammar-token-stringprefix\n104 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n11.5. Méthodes associées aux chaînes de caractères Chapitre 11. Plus sur les chaînes de caractères"
  },
  {
    "title": "Méthodes associées aux chaînes de caractères",
    "content": "3\nVoici quelques méthodes spécifiques aux objets de type :\nstr\n1\n>>> x = \"girafe\"\n2 >>> x.upper()\n3\n'GIRAFE'\n4 >>> x\n5\n'girafe'\n6 >>> 'TIGRE'.lower()\n7\n'tigre'\nLes méthodes et renvoient un texte en minuscule et en majuscule respectivement. On remarque\n.lower() .upper()\nque l’utilisation de ces méthodes n’altère pas la chaîne de caractères de départ, mais renvoie une chaîne de caractères\ntransformée.\nPour mettre en majuscule la première lettre seulement, vous pouvez faire :\n1 >>> x[0].upper() + x[1:]\n2\n'Girafe'\nou plus simplement utiliser la méthode adéquate :\n1 >>> x.capitalize()\n2\n'Girafe'\nIl existe une méthode associée aux chaînes de caractères qui est particulièrement pratique, la méthode :\n.split()\n1 >>> animaux = \"girafe tigre singe souris\"\n2\n>>> animaux.split()\n3 ['girafe', 'tigre', 'singe', 'souris']\n4\n>>> for animal in animaux.split():\n5 ... print(animal)\n6\n...\n7 girafe\n8 tigre\n9\nsinge\n10 souris\nLa méthode découpe une chaîne de caractères en plusieurs éléments appelés champs, en utilisant comme\n.split()\nséparateur n’importe quelle combinaison « d’espace(s) blanc(s) ».\nDéfinition\n4\nUn espace blanc (whitespace en anglais) correspond aux caractères qui sont invisibles à l’œil, mais qui occupent de\nl’espace dans un texte. Les espaces blancs les plus classiques sont l’espace, la tabulation et le retour à la ligne.\nIl est possible de modifier le séparateur de champs, par exemple :\n1 >>> animaux = \"girafe:tigre:singe::souris\"\n2\n>>> animaux.split(\":\")\n3 ['girafe', 'tigre', 'singe', '', 'souris']\nAttention, dans cet exemple, le séparateur est un seul caractères « » (et non pas une combinaison de un ou plusieurs\n:\n) conduisant ainsi à une chaîne vide entre et .\n: singe souris\nIl est également intéressant d’indiquer à le nombre de fois qu’on souhaite découper la chaîne de caractères\n.split()\navec l’argument :\nmaxsplit\n1 >>> animaux = \"girafe tigre singe souris\"\n2\n>>> animaux.split(maxsplit=1)\n3 ['girafe', 'tigre singe souris']\n4\n>>> animaux.split(maxsplit=2)\n5 ['girafe', 'tigre', 'singe souris']\n3.\nhttps://docs.python.org/fr/3/library/string.html\n4. https://en.wikipedia.org/wiki/Whitespace_character\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 105\nChapitre 11. Plus sur les chaînes de caractères 11.5. Méthodes associées aux chaînes de caractères\nLa méthode , quant à elle, recherche une chaîne de caractères passée en argument :\n.find()\n1\n>>> animal = \"girafe\"\n2 >>> animal.find(\"i\")\n3\n1\n4 >>> animal.find(\"afe\")\n5\n3\n6 >>> animal.find(\"z\")\n7 -1\n8\n>>> animal.find(\"tig\")\n9 -1\nSi l’élément recherché est trouvé, alors l’indice du début de l’élément dans la chaîne de caractères est renvoyé. Si\nl’élément n’est pas trouvé, alors la valeur est renvoyée.\n-1\nSi l’élément recherché est trouvé plusieurs fois, seul l’indice de la première occurrence est renvoyé :\n1 >>> animaux = \"girafe tigre\"\n2\n>>> animaux.find(\"i\")\n3 1\nOn trouve aussi la méthode qui substitue une chaîne de caractères par une autre :\n.replace()\n1\n>>> animaux = \"girafe tigre\"\n2 >>> animaux.replace(\"tigre\", \"singe\")\n3\n'girafe singe'\n4 >>> animaux.replace(\"i\", \"o\")\n5\n'gorafe togre'\nLa méthode compte le nombre d’occurrences d’une chaîne de caractères passée en argument :\n.count()\n1 >>> animaux = \"girafe tigre\"\n2 >>> animaux.count(\"i\")\n3\n2\n4 >>> animaux.count(\"z\")\n5\n0\n6 >>> animaux.count(\"tigre\")\n7\n1\nLa méthode vérifie si une chaîne de caractères commence par une autre chaîne de caractères :\n.startswith()\n1 >>> chaine = \"Bonjour monsieur le capitaine !\"\n2\n>>> chaine.startswith(\"Bonjour\")\n3 True\n4\n>>> chaine.startswith(\"Au revoir\")\n5 False\nCette méthode est particulièrement utile lorsqu’on lit un fichier et que l’on veut récupérer certaines lignes commençant\npar un mot-clé. Par exemple dans un fichier PDB, les lignes contenant les coordonnées des atomes commencent par le\nmot-clé .\nATOM\nEnfin, la méthode permet de « nettoyer les bords » d’une chaîne de caractères :\n.strip()\n1 >>> chaine = \" Comment enlever les espaces au début et à la fin ? \"\n2\n>>> chaine.strip()\n3 'Comment enlever les espaces au début et à la fin ?'\nLa méthode enlève les espaces situés sur les bords de la chaîne de caractère mais pas ceux situés entre des\n.strip()\ncaractères visibles. En réalité, cette méthode enlève n’importe quel combinaison « d’espace(s) blanc(s) » sur les bords,\npar exemple :\n1\n>>> chaine = \" \\tfonctionne avec les tabulations et les retours à la ligne\\n\"\n2 >>> chaine.strip()\n3\n'fonctionne avec les tabulations et les retours à la ligne'\nCette méthode est utile pour se débarrasser des retours à la ligne quand on lit un fichier.\n106 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n11.6. Extraction de valeurs numériques d’une chaîne de caractères Chapitre 11. Plus sur les chaînes de caractères"
  },
  {
    "title": "Extraction de valeurs numériques d’une chaîne de caractères",
    "content": "Une tâche courante en Python est de lire une chaîne de caractères (provenant par exemple d’un fichier), d’en extraire\ndes valeurs pour ensuite les manipuler.\nOn considère par exemple la chaîne de caractères :\nchaine1\n1 >>> chaine1 = \"3.4 17.2 atom\"\nOn souhaite extraire les valeurs et pour ensuite les additionner.\n3.4 17.2\nD’abord, on découpe la chaîne de caractères avec la méthode :\n.split()\n1\n>>> liste1 = chaine1.split()\n2 >>> liste1\n3\n['3.4', '17.2', 'atom']\n4 >>> nb1, nb2, nom = liste1\n5\n>>> nb1\n6 '3.4'\n7 >>> nb2\n8 '17.2'\nOn obtient alors une liste de chaînes de caractères . Avec l’affectation multiple, on récupère les nombres\nliste1\nsouhaités dans et , mais ils sont toujours sous forme de chaîne de caractères. Il faut ensuite les convertir en floats\nnb1 nb2\npour pouvoir les additionner :\n1\n>>> float(nb1) + float(nb2)\n2 20.599999999999998\nRemarque\nRetenez bien l’utilisation des instructions précédentes pour extraire des valeurs numériques d’une chaîne de caractères.\nElles sont régulièrement employées pour analyser des données extraites d’un fichier."
  },
  {
    "title": "Fonction map()",
    "content": "Conseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nLa fonction permet d’appliquer une fonction à plusieurs éléments d’un objet itérable. Par exemple, si on a une\nmap()\nchaîne de caractères avec trois entiers séparés par des espaces, on peut extraire et convertir les trois nombres en entier\nen une seule ligne. La fonction produit un objet de type map qui est itérable et transformable en liste :\nmap()\n1\n>>> ligne = \"67 946 -45\"\n2 >>> ligne.split()\n3\n['67', '946', '-45']\n4 >>> map(int, ligne.split())\n5\n<map object at 0x7fa34e573b20>\n6 >>> for entier in map(int, ligne.split()):\n7\n... print(entier)\n8 ...\n9\n67\n10 946\n11\n-45\n12 >>> list(map(int, ligne.split()))\n13 [67, 946, -45]\nRemarque\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 107\nChapitre 11. Plus sur les chaînes de caractères 11.8. Test d’appartenance\nLa fonction prend deux arguments. Le second est un objet itérable, souvent une liste comme dans notre\nmap()\nexemple. Le premier argument est le nom d’une fonction qu’on souhaite appliquer à chaque élément de la liste, mais sans\nles parenthèses (ici et non pas ). Une fonction passée en argument d’une autre fonction est appelée fonction\nint int()\n5\nde rappel ou callback en anglais. Nous reverrons cette notion dans le chapitre 25 Fenêtres graphiques et Tkinter (en\nligne).\nLa fonction est particulièrement utile lorsqu’on lit un fichier de valeurs numériques. Par exemple, si on a un\nmap()\nfichier contenant trois colonnes de nombres, en conjonction avec permet de séparer les trois\ndata.dat map() .split()\nnombres puis de les convertir en float en une seule ligne de code :\n1 with open(\"data.dat\", \"r\") as filin:\n2\nfor line in filin:\n3 x, y, z = map(float, line.split())\n4\nprint(x + y + z)\nSans , il aurait fallu une ligne pour séparer les données et une autre pour les\nmap() x, y, z = line.split()\ntransformer en float .\nx, y, z = float(x), float(y), float(z)\nEnfin, on peut utiliser avec ses propres fonctions :\nmap()\n1\n>>> def calc_cube(x):\n2 ... return x**3\n3\n...\n4 >>> list(map(calc_cube, [1, 2, 3, 4]))\n5\n[1, 8, 27, 64]"
  },
  {
    "title": "Test d’appartenance",
    "content": "L’opérateur teste si une chaîne de caractères fait partie d’une autre chaîne de caractères :\nin\n1 >>> chaine = \"Néfertiti\"\n2 >>> \"toto\" in chaine\n3\nFalse\n4 >>> \"titi\" in chaine\n5\nTrue\n6 >>> \"ti\" in chaine\n7\nTrue\nNotez que la chaîne testée peut-être présente à n’importe quelle position dans l’autre chaîne. Par ailleurs, le test est\nvrai si elle est présente une ou plusieurs fois.\nLa variation avec l’opérateur booléen permet de vérifier qu’une chaîne n’est pas présente dans une autre chaîne :\nnot\n1\n>>> not \"toto\" in chaine\n2 True\n3\n>>> not \"fer\" in chaine\n4 False"
  },
  {
    "title": "ractères",
    "content": "On a vu dans le chapitre 2 Variables la conversion d’un type simple (entier, float et chaîne de caractères) en un\nautre avec les fonctions , et . La conversion d’une liste de chaînes de caractères en une chaîne de\nint() float() str()\ncaractères est moins intuitive. Elle fait appelle à la méthode :\n.join()\n5. https://fr.wikipedia.org/wiki/Fonction_de_rappel\n108 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n11.10. Method chaining Chapitre 11. Plus sur les chaînes de caractères\n1\n>>> seq = [\"A\", \"T\", \"G\", \"A\", \"T\"]\n2 >>> seq\n3\n['A', 'T', 'G', 'A', 'T']\n4 >>> \"-\".join(seq)\n5\n'A-T-G-A-T'\n6 >>> \" \".join(seq)\n7 'A T G A T'\n8\n>>> \"\".join(seq)\n9 'ATGAT'\nLes éléments de la liste initiale sont concaténés les uns à la suite des autres et intercalés par un séparateur, qui peut\nêtre n’importe quelle chaîne de caractères. Ici, on a utilisé un tiret, un espace et rien (une chaîne de caractères vide).\nAttention, la méthode ne s’applique qu’à une liste de chaînes de caractères :\n.join()\n1 >>> maliste = [\"A\", 5, \"G\"]\n2\n>>> \" \".join(maliste)\n3 Traceback (most recent call last):\n4\nFile \"<stdin>\", line 1, in <module>\n5 TypeError: sequence item 1: expected str instance, int found\nOn espère qu’après ce petit tour d’horizon vous serez convaincu de la richesse des méthodes associées aux chaînes de\ncaractères. Pour avoir une liste exhaustive de l’ensemble des méthodes associées à une variable particulière, vous pouvez\nutiliser la fonction :\ndir()\n1 >>> animaux = \"girafe tigre\"\n2 >>> dir(animaux)\n3 ['__add__', '__class__', '__contains__', '__delattr__', '__dir__',\n4 ...,\n5\n'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition',\n6 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip',\n7\n'swapcase', 'title', 'translate', 'upper', 'zfill']\nPour l’instant, vous pouvez ignorer les méthodes qui commencent et qui se terminent par deux tirets bas (underscores)\n. Nous n’avons pas mis l’ensemble de la sortie de cette commande pour ne pas surcharger le texte, mais n’hésitez\n__ dir()\npas à la tester dans l’interpréteur.\nVous pouvez également accéder à l’aide et à la documentation d’une méthode particulière avec , par exemple\nhelp()\npour la méthode :\n.split()\n>>> help(animaux.split)\nHelp on built-in function split:\nsplit(...)\nS.split([sep [,maxsplit]]) -> list of strings\nReturn a list of the words in the string S, using sep as the\ndelimiter string. If maxsplit is given, at most maxsplit\nsplits are done. If sep is not specified or is None, any\nwhitespace string is a separator.\n(END)\nAttention à ne pas mettre les parenthèses à la suite du nom de la méthode. L’instruction correcte est\nhelp(animaux\net non pas .\n.split) help(animaux.split())"
  },
  {
    "title": "Method chaining",
    "content": "Il existe de nombreuses méthodes pour traiter les chaînes de caractères. Ces méthodes renvoient la plupart du temps\nune chaîne de caractères modifiée.\nPar exemple, si on souhaite mettre une majuscule à tous les mots d’une chaîne de caractères, puis remplacer un mot\npar un autre, puis transformer cette chaîne de caractères en une liste de chaînes de caractères, on peut écrire :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 109\nChapitre 11. Plus sur les chaînes de caractères 11.11. Exercices\n1\n>>> message = \"salut patrick salut pierre\"\n2 >>> message1 = message.title()\n3\n>>> message1\n4 'Salut Patrick Salut Pierre'\n5\n>>> message2 = message1.replace(\"Salut\", \"Bonjour\")\n6 >>> message2\n7 'Bonjour Patrick Bonjour Pierre'\n8\n>>> message2.split()\n9 ['Bonjour', 'Patrick', 'Bonjour', 'Pierre']\nOn a créé deux variables intermédiaires et pour stocker les chaînes de caractères modifiées par\nmessage1 message2\nles méthodes et .\n.title() .replace()\nIl est possible de faire la même chose en une seule ligne, en utilisant le chaînage de méthodes ou method chaining :\n1 >>> message = \"salut patrick salut pierre\"\n2\n>>> message.title().replace(\"Salut\", \"Bonjour\").split()\n3 ['Bonjour', 'Patrick', 'Bonjour', 'Pierre']\nOn évite ainsi de créer des variables intermédiaires.\nLe method chaining peut créer des lignes de code très longues. On peut couper une ligne de code en plusieurs lignes\nen utilisant le caractère en fin de ligne :\n\\\n1 >>> message = \"salut patrick salut pierre\"\n2\n>>> message.title() \\\n3 ... .replace(\"Salut\", \"Bonjour\") \\\n4\n... .title()\n5 'Bonjour Patrick Bonjour Pierre'\nOn peut aussi utiliser des parenthèses pour couper une ligne de code en plusieurs lignes :\n1 >>> message = \"salut patrick salut pierre\"\n2 >>> (message\n3\n... .title()\n4 ... .replace(\"Salut\", \"Bonjour\")\n5\n... .split()\n6 ... )\n7\n['Bonjour', 'Patrick', 'Bonjour', 'Pierre']\nL’utilisation de parenthèses permet aussi de couper une chaîne de caractères en plusieurs lignes :\n1 >>> ma_chaine = (\n2\n... \"voici une chaine de caractères \"\n3 ... \"très longue \"\n4\n... \"sur plusieurs lignes\")\n5 >>> ma_chaine\n6\n'voici une chaine de caractères très longue sur plusieurs lignes'\nNous reverrons le method chaining dans le chapitre 22 Module Pandas."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n11.11.1 Parcours d’une liste de chaînes de caractères\nSoit la liste . Avec une boucle, aﬀichez chaque élément ainsi que sa\n['girafe', 'tigre', 'singe', 'souris']\ntaille (nombre de caractères).\n110 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n11.11. Exercices Chapitre 11. Plus sur les chaînes de caractères\n11.11.2 Lecture d’une séquence à partir d’un fichier FASTA\n6\nLe fichier contient une séquence d’ADN au format FASTA.\nUBI4_SCerevisiae.fasta\nCréez une fonction qui prend comme argument le nom d’un fichier FASTA sous la forme d’une chaîne\nlit_fasta()\nde caractères, lit la séquence dans le fichier FASTA et la renvoie sous la forme d’une chaîne de caractères.\nUtilisez ensuite cette fonction pour récupérer la séquence d’ADN dans la variable puis pour aﬀicher les\nsequence\ninformations suivantes :\n•\nle nom du fichier FASTA,\n•\nla longueur de la séquence (c’est-à-dire le nombre de bases qu’elle contient),\n•\nun message vérifiant que le nombre de bases est (ou non) un multiple de 3,\n•\nle nombre de codons (on rappelle qu’un codon est un bloc de 3 bases),\n•\nles 10 premières bases,\n•\nles 10 dernières bases.\nLa sortie produite par le script devrait ressembler à ça :\nUBI4_SCerevisiae.fasta\nLa séquence contient WWW bases\nLa longueur de la séquence est un multiple de 3 bases\nLa séquence possède XXX codons\n10 premières bases : YYYYYYYYYY\n10 dernières bases : ZZZZZZZZZZ\noù et sont des entiers et et sont des bases.\nWWW XXX YYYYYYYYYY ZZZZZZZZZZ\nConseil\nVous trouverez des explications sur le format FASTA et des exemples de code dans l’annexe A Quelques formats de\ndonnées en biologie.\n11.11.3 Fréquence des bases dans une séquence d’ADN\nSoit la séquence d’ADN . On souhaite calculer la fréquence de chaque\nATATACGGATCGGCTGTTGCCTGCGTAGTAGCGT\nbase A, T, C et G dans cette séquence et aﬀicher le résultat à l’écran.\nCréez pour cela une fonction à laquelle vous passez en argument votre séquence d’ADN sous\ncalc_composition()\nforme d’une chaîne de caractères, et qui renvoie une liste de quatre floats indiquant respectivement la fréquence en bases\n, , et .\nA T G C\n11.11.4 Distance de Hamming\n7\nLa distance de Hamming mesure la différence entre deux séquences de même taille en comptant le nombre de\npositions qui, pour chaque séquence, ne correspondent pas au même acide aminé.\nCréez la fonction qui prend en argument deux chaînes de caractères et qui renvoie la distance de\ndist_hamming()\nHamming (sous la forme d’un entier) entre ces deux chaînes de caractères.\nCalculez la distance de Hamming entre les séquences : et\nAGWPSGGASAGLAIL IGWPSAGASAGLWIL\npuis entre les séquences : et .\nATTCATACGTTACGATT ATACTTACGTAACCATT\n11.11.5 Moyenne de notes\n8\nLe fichier contient des noms d’étudiant ainsi que leurs notes dans différentes matières. Chaque donnée\nnotes.csv\nest séparée par une virgule. On trouve dans l’ordre le nom de l’étudiant, la note en géographie, la note en sport, la note\nen anglais.\nJason,17,3,1\nWilliam,9,18,15\nSusan,3,8,10\n[...]\n6. https://python.sdv.u-paris.fr/data-files/UBI4_SCerevisiae.fasta\n7.\nhttps://fr.wikipedia.org/wiki/Distance_de_Hamming\n8. https://python.sdv.u-paris.fr/data-files/notes.csv\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 111\nChapitre 11. Plus sur les chaînes de caractères 11.11. Exercices\nCréez un programme qui lit chaque ligne du fichier et construit une liste de dictionnaire du style\n[{\"nom\": \"Jason\",\n. Utilisez si possible la fonction pour convertir les nombres\n\"geo\": 17, \"sport\": 3, \"anglais\": 1}, ...] map()\nlus dans le fichier en entiers. Réalisez ensuite une boucle sur cette liste de dictionnaires, et aﬀichez le nom de l’étudiant,\nsa note en sport et sa note en anglais. Aﬀichez ensuite la moyenne des notes de sport et de géographie pour tous les\nétudiants.\n11.11.6 Conversion des acides aminés du code à trois lettres au code à une lettre\nCréez une fonction qui prend en argument une chaîne de caractères avec des\nconvert_3_lettres_1_lettre()\nacides aminés en code à trois lettres et renvoie une chaîne de caractères avec les acides aminés en code à une lettre.\nVous pourrez tenter d’utiliser le method chaining dans cette fonction.\nUtilisez cette fonction pour convertir la séquence protéique .\nALA GLY GLU ARG TRP TYR SER GLY ALA TRP\nRappel de la nomenclature des acides aminés :\nAcide aminé Code 3-lettres Code 1-lettre Acide aminé Code 3-lettres Code 1-lettre\nAlanine Ala A Leucine Leu L\nArginine Arg R Lysine Lys K\nAsparagine Asn N Méthionine Met M\nAspartate Asp D Phénylalanine Phe F\nCystéine Cys C Proline Pro P\nGlutamate Glu E Sérine Ser S\nGlutamine Gln Q Thréonine Thr T\nGlycine Gly G Tryptophane Trp W\nHistidine His H Tyrosine Tyr Y\nIsoleucine Ile I Valine Val V\n11.11.7 Palindrome\nUn palindrome est un mot ou une phrase dont l’ordre des lettres reste le même si on le lit de gauche à droite ou de\ndroite à gauche. Par exemple, « ressasser » et « engage le jeu que je le gagne » sont des palindromes.\nCréez la fonction qui prend en argument une chaîne de caractères et qui renvoie un booléen\nest_palindrome()\n( si l’argument est un palindrome, si ce n’est pas le cas). Dans le programme principal, aﬀichez\nTrue False xxx est\nsi la fonction renvoie sinon . Pensez à\nun palindrome est_palindrome() True xxx n'est pas un palindrome\nvous débarrasser au préalable des majuscules, des signes de ponctuations et des espaces.\nTestez ensuite si les expressions suivantes sont des palindromes :\n•\nRadar\n•\nNever odd or even\n•\nKarine alla en Iran\n•\nUn roc si biscornu\n•\nEt la marine ira vers Malte\n•\nDeer Madam, Reed\n•\nrotator\n•\nWas it a car or a cat I saw?\nConseil\nPour le nettoyage de la chaîne de caractères (retrait des majuscules, signes de ponctations et espaces), essayer d’utiliser\nle method chaining.\n11.11.8 Mot composable\nUn mot est composable à partir d’une séquence de lettres si la séquence contient toutes les lettres du mot. Chaque\nlettre de la séquence ne peut être utilisée qu’une seule fois. Par exemple, « coucou » est composable à partir de «\nuocuoceokzefhu ».\n112 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n11.11. Exercices Chapitre 11. Plus sur les chaînes de caractères\nCréez la fonction , qui prend en argument un mot (sous la forme d’une chaîne de caractères) et\nest_composable()\nune séquence de lettres (aussi comme une chaîne de caractères), et qui renvoie si le mot est composable à partir\nTrue\nde la séquence, sinon .\nFalse\nDans le programme principal, créez une liste de tuples contenant les couples mot / séquence, de la forme\n[('mot1',\n. Utilisez ensuite une boucle sur tous les couples mot / séquence, et\n'sequence1'), ('mot2', 'sequence2'), ...]\nappelez à chaque itération la fonction . Aﬀichez enfin\nest_composable() Le mot xxx est composable à partir\nsi le mot est composable à partir de la séquence de lettres ( ). Aﬀichez\nde yyy xxx yyy Le mot xxx n'est pas\nsi ce n’est pas le cas.\ncomposable à partir de yyy\nTestez cette fonction avec les mots et les séquences suivantes :\nMot Séquence\npython aophrtkny\npython aeiouyhpq\ncoucou uocuoceokzezh\nfonction nhwfnitvkloco\n11.11.9 Alphabet et pangramme\nLes codes ASCII des lettres minuscules de l’alphabet vont de 97 (lettre « a ») à 122 (lettre « z »). La fonction\nchr()\nprend en argument un code ASCII sous la forme d’un entier et renvoie le caractère correspondant (sous la forme d’une\nchaîne de caractères). Ainsi renvoie , renvoie et ainsi de suite.\nchr(97) 'a' chr(98) 'b'\nCréez la fonction qui utilise une boucle et la fonction et qui renvoie une chaîne de caractères\nget_alphabet() chr()\ncontenant toutes les lettres de l’alphabet.\n9\nUn pangramme est une phrase comportant au moins une fois chaque lettre de l’alphabet. Par exemple, « Portez ce\nvieux whisky au juge blond qui fume » est un pangramme.\nCréez la fonction qui utilise la fonction précédente, qui prend en argument une\nest_pangramme() get_alphabet()\nchaîne de caractères , et qui renvoie si la phrase est un pangramme et sinon.\nxxx True False\nLe programme aﬀichera finalement ou . Pensez à vous\nxxx est un pangramme xxx n'est pas un pangramme\ndébarrasser des majuscules le cas échéant.\nTestez ensuite si les expressions suivantes sont des pangrammes :\n•\nPortez ce vieux whisky au juge blond qui fume\n•\nMonsieur Jack vous dactylographiez bien mieux que votre ami Wolf\n•\nBuvez de ce whisky que le patron juge fameux\n•\nCeci n’est pas un pangramme\n11.11.10 Lecture d’une séquence à partir d’un fichier GenBank (exercice +++)\nOn cherche à récupérer la séquence d’ADN du chromosome I de la levure Saccharomyces cerevisiae contenu dans le\n10\nfichier au format GenBank .\nNC_001133.gbk\nLe format GenBank est présenté en détail dans l’annexe A Quelques formats de données en biologie. Pour cet exercice,\nvous devez savoir que la séquence démarre après la ligne commençant par le mot et se termine avant la ligne\nORIGIN\ncommençant par les caractères :\n//\nORIGIN\n1 ccacaccaca cccacacacc cacacaccac accacacacc acaccacacc cacacacaca\n61 catcctaaca ctaccctaac acagccctaa tctaaccctg gccaacctgt ctctcaactt\n[...]\n230101 tgttagtgtt agtattaggg tgtggtgtgt gggtgtggtg tgggtgtggg tgtgggtgtg\n230161 ggtgtgggtg tgggtgtggt gtggtgtgtg ggtgtggtgt gggtgtggtg tgtgtggg\n//\nPour extraire la séquence d’ADN, nous vous proposons d’utiliser un algorithme de « drapeau », c’est-à-dire une variable\nqui sera à lorsqu’on lira les lignes contenant la séquence et à pour les autres lignes.\nTrue False\n9.\nhttp://fr.wikipedia.org/wiki/Pangramme\n10. https://python.sdv.u-paris.fr/data-files/NC_001133.gbk\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 113\nChapitre 11. Plus sur les chaînes de caractères 11.11. Exercices\nCréez une fonction qui prend comme argument le nom d’un fichier GenBank sous la forme d’une\nlit_genbank()\nchaîne de caractères, lit la séquence dans le fichier GenBank et la renvoie sous la forme d’une chaîne de caractères.\nUtilisez ensuite cette fonction pour récupérer la séquence d’ADN dans la variable dans le programme\nsequence\nprincipal. Le script aﬀichera :\nNC_001133.gbk\nLa séquence contient XXX bases\n10 premières bases : YYYYYYYYYY\n10 dernières bases : ZZZZZZZZZZ\noù est un entier et et sont des bases.\nXXX YYYYYYYYYY ZZZZZZZZZZ\nVous avez toutes les informations pour effectuer cet exercice. Si toutefois vous coincez sur la mise en place du drapeau,\nvoici l’algorithme en pseudo-code pour vous aider :\ndrapeau <- Faux\nseq <- chaîne de caractères vide\nLire toutes les lignes du fichier:\nsi la ligne contient //:\ndrapeau <- Faux\nsi drapeau est Vrai:\non ajoute à seq la ligne (sans espace, chiffre et retour à la ligne)\nsi la ligne contient ORIGIN:\ndrapeau <- Vrai\n11.11.11 Aﬀichage des carbones alpha d’une structure de protéine\n11 12\nTéléchargez le fichier qui correspond à la structure tridimensionnelle de la protéine barstar sur le site\n1bta.pdb\nde la Protein Data Bank (PDB).\nCréez la fonction qui prend en argument le nom d’un fichier PDB (sous la forme d’une chaîne de\ntrouve_calpha()\ncaractères), qui sélectionne uniquement les lignes contenant des carbones alpha, qui stocke ces lignes dans une liste et\nles renvoie sous la forme d’une liste de chaînes de caractères.\nUtilisez la fonction pour aﬀicher à l’écran les carbones alpha des deux premiers résidus (acides\ntrouve_calpha()\naminés).\nConseil\nVous trouverez des explications sur le format PDB et des exemples de code pour lire ce type de fichier en Python\ndans l’annexe A Quelques formats de données en biologie.\n11.11.12 Calcul des distances entre les carbones alpha consécutifs d’une structure de pro-\ntéine (exercice +++)\nEn utilisant la fonction précédente, calculez la distance interatomique entre les carbones alpha\ntrouve_calpha()\ndes deux premiers résidus (avec deux chiffres après la virgule).\nRappel : la distance euclidienne d entre deux points A et B de coordonnées cartésiennes respectives (x ,y ,z ) et\nA A A\n(x ,y ,z ) se calcule comme suit :\nB B B\n√\n− − −\nd = (x x )2 +(y y )2 +(z z )2\nB A B A B A\nCréez ensuite la fonction qui prend en argument la liste renvoyée par la fonction\ncalcule_distance() trouve_calpha\n, qui calcule les distances interatomiques entre carbones alpha consécutifs et aﬀiche ces distances sous la forme :\n()\nnumero_calpha_1 numero_calpha_2 distance\nLes numéros des carbones alpha seront aﬀichés sur deux caractères. La distance sera aﬀichée avec deux chiffres après\nla virgule. Voici un exemple avec les premiers carbones alpha :\n11.\nhttps://files.rcsb.org/download/1BTA.pdb\n12. http://www.rcsb.org/pdb/explore.do?structureId=1BTA\n114 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n11.11. Exercices Chapitre 11. Plus sur les chaînes de caractères\n1 2 3.80\n2 3 3.80\n3 4 3.83\n4 5 3.82\nModifiez maintenant la fonction pour qu’elle aﬀiche à la fin la moyenne des distances.\ncalcule_distance()\nLa distance inter-carbone alpha dans les protéines est très stable et de l’ordre de 3,8 angströms. Observez avec attention\nles valeurs que vous avez calculées pour la protéine barstar. Repérez une valeur surprenante. Essayez de l’expliquer.\nConseil\nVous trouverez des explications sur le format PDB et des exemples de code pour lire ce type de fichier en Python\ndans l’annexe A Quelques formats de données en biologie.\n11.11.13 Compteur de gènes dans un fichier GenBank\n13\nDans cet exercice, on souhaite compter le nombre de gènes du fichier GenBank NC_001133.gbk (chromosome I\nde la levure Saccharomyces cerevisiae) et aﬀicher la longueur de chaque gène. Pour cela, il faudra récupérer les lignes\ndécrivant la position des gènes. Voici par exemple les cinq premières lignes concernées dans le fichier NC_001133.gbk :\ngene complement(<1807..>2169)\ngene <2480..>2707\ngene complement(<7235..>9016)\ngene complement(<11565..>11951)\ngene <12046..>12426\n[...]\nLorsque la ligne contient le mot le gène est situé sur le brin complémentaire, sinon il est situé sur le brin\ncomplement\ndirect. Votre code devra récupérer le premier et le second nombre indiquant respectivement la position du début et de\nfin du gène. Attention à bien les convertir en entier afin de pouvoir calculer la longueur du gène. Notez que les caractères\net doivent être ignorés, et que les servent à séparer la position de début et de fin.\n> < ..\nOn souhaite obtenir une sortie de la forme :\ngène 1 complémentaire -> 362 bases\ngène 2 direct -> 227 bases\ngène 3 complémentaire -> 1781 bases\n[...]\ngène 99 direct -> 611 bases\ngène 100 direct -> 485 bases\ngène 101 direct -> 1403 bases\nConseil\nVous trouverez des explications sur le format GenBank dans l’annexe A Quelques formats de données en biologie.\n13. https://python.sdv.u-paris.fr/data-files/NC_001133.gbk\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 115"
  },
  {
    "title": "Plus sur les listes",
    "content": "Nous avons vu les listes dès le chapitre 4 et les avons largement utilisées depuis le début de ce cours. Dans ce chapitre,\nnous allons plus loin avec les méthodes associées aux listes, ainsi que d’autres caractéristiques très puissantes telles que\nles tests d’appartenance ou les listes de compréhension."
  },
  {
    "title": "Méthodes associées aux listes",
    "content": "Comme pour les chaînes de caractères, les listes possèdent de nombreuses méthodes qui leurs sont propres. On\nrappelle qu’une méthode est une fonction qui agit sur l’objet auquel elle est attachée par un point.\n12.1.1\n.append()\nLa méthode , que l’on a déjà vu au chapitre 4 Listes, ajoute un élément à la fin d’une liste :\n.append()\n1\n>>> liste1 = [1, 2, 3]\n2 >>> liste1.append(5)\n3\n>>> liste1\n4 [1, 2, 3, 5]\nqui est équivalent à :\n1 >>> liste1 = [1, 2, 3]\n2\n>>> liste1 = liste1 + [5]\n3 >>> liste1\n4\n[1, 2, 3, 5]\nConseil\nPréférez la version avec qui est plus compacte et facile à lire.\n.append()\n12.1.2\n.insert()\nLa méthode insère un objet dans une liste à un indice déterminé :\n.insert()\n116\n12.1. Méthodes associées aux listes Chapitre 12. Plus sur les listes\n1\n>>> liste1 = [1, 2, 3]\n2 >>> liste1.insert(2, -15)\n3\n>>> liste1\n4 [1, 2, -15, 3]\n12.1.3\ndel\nL’instruction supprime un élément d’une liste à un indice déterminé :\ndel\n1\n>>> liste1 = [1, 2, 3]\n2 >>> del liste1[1]\n3\n>>> liste1\n4 [1, 3]\nRemarque\nContrairement aux méthodes associées aux listes présentées dans cette rubrique, est une instruction générale de\ndel\nPython, utilisable pour d’autres objets que des listes. Celle-ci ne prend pas de parenthèse.\n12.1.4 .remove()\nLa méthode supprime un élément d’une liste à partir de sa valeur :\n.remove()\n1 >>> liste1 = [1, 2, 3]\n2\n>>> liste1.remove(3)\n3 >>> liste1\n4\n[1, 2]\nS’il y a plusieurs fois la même valeur dans la liste, seule la première est retirée. Il faut appeler la méthode\n.remove()\nautant de fois que nécessaire pour retirer toutes les occurences d’un même élément :\n1\n>>> liste1 = [1, 2, 3, 4, 3]\n2 >>> liste1.remove(3)\n3\n>>> liste1\n4 [1, 2, 4, 3]\n5 >>> liste1.remove(3)\n6\n>>> liste1\n7 [1, 2, 4]\n12.1.5 .sort()\nLa méthode trie les éléments d’une liste du plus petit au plus grand :\n.sort()\n1 >>> liste1 = [3, 1, 2]\n2\n>>> liste1.sort()\n3 >>> liste1\n4\n[1, 2, 3]\nL’argument spécifie le tri inverse, c’est-à-dire du plus grand au plus petit élément :\nreverse=True\n1 >>> liste1 = [3, 1, 2]\n2\n>>> liste1.sort(reverse=True)\n3 >>> liste1\n4\n[3, 2, 1]\n12.1.6 sorted()\nLa fonction trie également une liste. Contrairement à la méthode précédente , cette fonction\nsorted() .sort()\nrenvoie la liste triée et ne modifie pas la liste initiale :\n1\n>>> liste1 = [3, 1, 2]\n2 >>> sorted(liste1)\n3\n[1, 2, 3]\n4 >>> liste1\n5\n[3, 1, 2]\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 117\nChapitre 12. Plus sur les listes 12.1. Méthodes associées aux listes\nLa fonction supporte aussi l’argument :\nsorted() reverse=True\n1\n>>> liste1 = [3, 1, 2]\n2 >>> sorted(liste1, reverse=True)\n3\n[3, 2, 1]\n4 >>> liste1\n5\n[3, 1, 2]\n12.1.7 .reverse()\nLa méthode inverse une liste :\n.reverse()\n1\n>>> liste1 = [3, 1, 2]\n2 >>> liste1.reverse()\n3\n>>> liste1\n4 [2, 1, 3]\n12.1.8\n.count()\nLa méthode compte le nombre d’éléments (passés en argument) dans une liste :\n.count()\n1 >>> liste1 = [1, 2, 4, 3, 1, 1]\n2\n>>> liste1.count(1)\n3 3\n4\n>>> liste1.count(4)\n5 1\n6\n>>> liste1.count(23)\n7 0\n12.1.9 Particularités des méthodes associées aux listes\nDe nombreuses méthodes mentionnées précédemment ( , , etc.) modifient la liste, mais ne ren-\n.append() .sort()\nvoient pas d’objet récupérable dans une variable. Il s’agit d’un exemple d’utilisation de méthode (donc de fonction\nparticulière) qui fait une action, mais qui ne renvoie rien. Pensez-y dans vos utilisations futures des listes. Ainsi, même si\nl’instruction est une instruction Python valide, ne contiendra que c’est-à-dire un\nvar = liste1.reverse() var None\nobjet vide en Python, préférez-lui directement l’instruction :\nliste1.reverse()\n1 >>> liste1 = [1, 2, 3]\n2\n>>> var = liste1.reverse()\n3 >>> var\n4\n>>> print(var)\n5 None\n6\n>>> liste1\n7 [3, 2, 1]\n8\n>>> liste2 = [5, 6, 7]\n9 >>> liste2.reverse()\n10 >>> liste2\n11\n[7, 6, 5]\nRemarque\nPour exprimer la même idée, la documentation parle de modification de la liste « sur place » (in place en anglais) :\n1\n>>> liste1 = [1, 2, 3]\n2 >>> help(liste1.reverse)\n3 Help on built-in function reverse:\n4\n5 reverse() method of builtins.list instance\n6\nReverse *IN PLACE*.\nCela signifie que la liste est modifiée « sur place », c’est-à-dire dans la méthode au moment où elle s’exécute. La liste\nétant modifiée « en dur » dans la méthode, cette dernière ne renvoie donc rien. L’explication du mécanisme sous-jacent\nvous sera donnée dans la rubrique 13.4 Portée des listes du chapitre 13 Plus sur les fonctions.\nPar ailleurs, certaines méthodes ou instructions des listes décalent les indices d’une liste (par exemple ,\n.insert()\n118 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n12.2. Construction d’une liste par itération Chapitre 12. Plus sur les listes\n, etc.).\ndel\nEnfin, pour obtenir une liste exhaustive des méthodes disponibles pour les listes, utilisez la fonction\ndir(liste1)\n( étant une liste).\nliste1"
  },
  {
    "title": "Construction d’une liste par itération",
    "content": "La méthode est très pratique car on peut l’utiliser pour construire une liste au fur et à mesure des\n.append()\nitérations d’une boucle.\nPour cela, il est commode de définir préalablement une liste vide avec l’instruction . Voici un exemple\nliste1 = []\noù une chaîne de caractères est convertie en liste :\n1 >>> seq = \"CAAAGGTAACGC\"\n2\n>>> seq_list = []\n3 >>> seq_list\n4\n[]\n5 >>> for base in seq:\n6\n... seq_list.append(base)\n7 ...\n8\n>>> seq_list\n9 ['C', 'A', 'A', 'A', 'G', 'G', 'T', 'A', 'A', 'C', 'G', 'C']\nRemarquez que dans cet exemple, vous pouvez aussi utiliser directement la fonction qui prend n’importe quel\nlist()\nobjet séquentiel (liste, chaîne de caractères, etc.) et qui renvoie une liste :\n1 >>> seq = \"CAAAGGTAACGC\"\n2 >>> list(seq)\n3\n['C', 'A', 'A', 'A', 'G', 'G', 'T', 'A', 'A', 'C', 'G', 'C']\nCette méthode est certes plus simple, mais il arrive parfois qu’on doive utiliser des boucles tout de même, comme\nlorsqu’on lit un fichier. Nous vous rappellons que l’instruction convertit un objet de type chaîne de caractères\nlist(seq)\nen un objet de type liste (il s’agit donc d’une opération de casting). De même que convertit un objet\nlist(range(10))\nde type en un objet de type .\nrange list"
  },
  {
    "title": "Test d’appartenance",
    "content": "L’opérateur teste si un élément fait partie d’une liste :\nin\n1 liste1 = [1, 3, 5, 7, 9]\n2\n>>> 3 in liste1\n3 True\n4 >>> 4 in liste1\n5\nFalse\n6 >>> 3 not in liste1\n7\nFalse\n8 >>> 4 not in liste1\n9\nTrue\nLa variation avec permet, a contrario, de vérifier qu’un élément n’est pas dans une liste.\nnot"
  },
  {
    "title": "zip()",
    "content": "Conseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nLa fonction de Python permet d’itérer sur plusieurs listes en parallèle :\nzip()\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 119\nChapitre 12. Plus sur les listes 12.4. Fonction\nzip()\n1\n>>> animaux = [\"poulain\", \"renard\", \"python\"]\n2 >>> couleurs = [\"alezan\", \"roux\", \"vert\"]\n3\n>>> zip(animaux, couleurs)\n4 <zip object at 0x7f6cf954a480>\n5\n>>> type(zip(animaux, couleurs))\n6 <class 'zip'>\n7 >>> for element in zip(animaux, couleurs):\n8\n... print(element)\n9 ...\n10\n('poulain', 'alezan')\n11 ('renard', 'roux')\n12\n('python', 'vert')\n13 >>> for animal, couleur in zip(animaux, couleurs):\n14\n... print(f\"le {animal} est {couleur}\")\n15 ...\n16\nle poulain est alezan\n17 le renard est roux\n18\nle python est vert\nLignes 3 et 6. On passe en argument deux listes à qui génère un nouvel objet de type zip. Comme pour les\nzip()\nobjets de type map vu au chapitre 11 Plus sur les chaînes de caractères, les objets zip sont itérables.\nLignes 7 à 12. Lorsqu’on itère sur un objet zip, la variable d’itération est un tuple. À la première itération, on a un\ntuple avec le premier élément de chaque liste utilisée pour générer l’objet zip, à la deuxième itération, ce sera le deuxième\nélément, et ainsi de suite.\nLignes 13 à 18. Avec l’affectation multiple, on peut affecter à la volée les éléments à des variables différentes, comme\non l’a fait avec la fonction (chapitre 5 Boucles) et la méthode des dictionnaires (chapitre 8\nenumerate() .items()\nDictionnaires et tuples).\nUn objet zip est aussi utile pour générer facilement une liste de tuples.\n1\n>>> list(zip(animaux, couleurs))\n2 [('poulain', 'alezan'), ('renard', 'roux'), ('python', 'vert')]\nSi une des listes passée en argument n’a pas la même longueur, l’objet zip s’arrête sur la liste la plus courte :\n1\n>>> animaux = [\"poulain\", \"renard\", \"python\", \"orque\"]\n2 >>> couleurs = [\"alezan\", \"roux\", \"vert\"]\n3\n>>> list(zip(animaux, couleurs))\n4 [('poulain', 'alezan'), ('renard', 'roux'), ('python', 'vert')]\nOn peut empêcher ce comportement avec l’argument par mot-clé , qui renvoie une erreur si les listes n’ont\nstrict\npas la même longueur :\n1\n>>> list(zip(animaux, couleurs, strict=True))\n2 Traceback (most recent call last):\n3\nFile \"<stdin>\", line 1, in <module>\n4 ValueError: zip() argument 2 is shorter than argument 1\nEnfin, il est possible de créer des objets zip avec autant de listes que l’on veut :\n1\n>>> animaux = [\"poulain\", \"renard\", \"python\"]\n2 >>> couleurs = [\"alezan\", \"roux\", \"vert\"]\n3\n>>> numero = [1, 2, 3]\n4 >>> list(zip(numero, animaux, couleurs))\n5\n[(1, 'poulain', 'alezan'), (2, 'renard', 'roux'), (3, 'python', 'vert')]\nRemarque\nLa fonction fonctionne sur n’importe quel objet itérable : listes, tuples, dictionnaires, objets range, etc.\nzip()\nConseil\nPour les débutants, vous pouvez sauter cette remarque.\n120 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n12.5. Copie de listes Chapitre 12. Plus sur les listes\nUn objet comme présenté plus haut est ce qu’on appelle un itérateur. Cela implique un mode de fonctionnement\nzip()\nparticulier, notamment le fait qu’on ne peut l’utiliser qu’une fois lorsqu’on l’a créé. Vous trouverez plus d’explications sur\nla définition et le fonctionnement d’un itérateur dans le chapitre 26 Remarques complémentaires."
  },
  {
    "title": "Copie de listes",
    "content": "Il est très important de savoir que l’affectation d’une liste (à partir d’une liste préexistante) crée en réalité une\nréférence et non une copie :\n1 >>> liste1 = [1, 2, 3]\n2 >>> liste2 = liste1\n3 >>> liste2\n4 [1, 2, 3]\n5\n>>> liste1[1] = -15\n6 >>> liste1\n7\n[1, -15, 3]\n8 >>> liste2\n9\n[1, -15, 3]\nVous voyez que la modification de modifie aussi ! Pour comprendre ce qu’il se passe, nous allons de\nliste1 liste2\nnouveau utiliser le site Python Tutor avec cet exemple (Figure 12.1) :\nFigure 12.1 – Copie de liste.\nTechniquement, Python utilise des pointeurs (comme dans le langage de programmation C) vers les mêmes objets.\nPython Tutor l’illustre avec des flèches qui partent des variables et et qui pointent vers la même liste.\nliste1 liste2\nDonc, si on modifie la liste , la liste est modifiée de la même manière. Rappelez-vous de ceci dans vos\nliste1 liste2\nfuturs programmes, car cela pourrait avoir des effets désastreux !\nPour éviter ce problème, il va falloir créer une copie explicite de la liste initiale. Observez cet exemple :\n1 >>> liste1 = [1, 2, 3]\n2 >>> liste2 = liste1[:]\n3\n>>> liste1[1] = -15\n4 >>> liste2\n5\n[1, 2, 3]\nL’instruction a créé une copie « à la volée » de la liste . Vous pouvez utiliser aussi la fonction\nliste1[:] liste1\n, qui renvoie explicitement une liste :\nlist()\n1\n>>> liste1 = [1, 2, 3]\n2 >>> liste2 = list(liste1)\n3\n>>> liste1[1] = -15\n4 >>> liste2\n5\n[1, 2, 3]\nSi on regarde à nouveau dans Python Tutor (Figure 12.2), on voit clairement que l’utilisation d’une tranche ou\n[:]\nde la fonction crée des copies explicites. Chaque flèche pointe vers une liste différente, indépendante des autres.\nlist()\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 121\nChapitre 12. Plus sur les listes 12.6. Initialisation d’une liste de listes\nFigure 12.2 – Copie de liste avec une tranche et la fonction .\n[:] list()\nAttention, les deux astuces précédentes ne fonctionnent que pour les listes à une dimension, autrement dit les listes\nqui ne contiennent pas elles-mêmes d’autres listes. Voyez par exemple :\n1\n>>> liste1 = [[1, 2], [3, 4]]\n2 >>> liste1\n3\n[[1, 2], [3, 4]]\n4 >>> liste2 = liste1[:]\n5\n>>> liste1[1][1] = 55\n6 >>> liste1\n7\n[[1, 2], [3, 55]]\n8 >>> liste2\n9\n[[1, 2], [3, 55]]\net\n1\n>>> liste2 = list(liste1)\n2 >>> liste1[1][1] = 77\n3\n>>> liste1\n4 [[1, 2], [3, 77]]\n5\n>>> liste2\n6 [[1, 2], [3, 77]]\nLa méthode de copie qui fonctionne à tous les coups consiste à appeler la fonction du module copy :\ndeepcopy()\n1 >>> import copy\n2\n>>> liste1 = [[1, 2], [3, 4]]\n3 >>> liste1\n4\n[[1, 2], [3, 4]]\n5 >>> liste2 = copy.deepcopy(liste1)\n6\n>>> liste1[1][1] = 99\n7 >>> liste1\n8\n[[1, 2], [3, 99]]\n9 >>> liste2\n10\n[[1, 2], [3, 4]]"
  },
  {
    "title": "Initialisation d’une liste de listes",
    "content": "Un dernier écueil que vous pourrez rencontrer concerne l’initialisation d’une liste de listes avec l’opérateur . Imaginons\n*\nque l’on souhaite représenter un tableau de nombre et l’initialiser avec des 0. Nous pourrions être tentés d’utiliser la\nduplication de listes :\n1 >>> liste1 = [[0, 0, 0]] * 5\n2\n>>> liste1\n3 [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\nLe problème est que si on modifie un élément d’une des sous-listes :\n122 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n12.7. Liste de compréhension Chapitre 12. Plus sur les listes\n1\n>>> liste1[2][0] = -12\n2 >>> liste1\n3\n[[-12, 0, 0], [-12, 0, 0], [-12, 0, 0], [-12, 0, 0], [-12, 0, 0]]\nVous constatez qu’il est modifié dans chaque sous-liste ! À l’aide de Python Tutor on voit que Python crée une\nréférence vers la même sous-liste (Figure 12.3) :\nFigure 12.3 – Initialisation d’une liste de listes avec l’opérateur de duplication.\n1\nComme disent les auteurs dans la documentation oﬀicielle : Note that items in the sequence are not copied ; they\nare referenced multiple times. This often haunts new Python programmers. Pour éviter le problème, on peut utiliser une\nboucle :\n1 >>> liste1 = []\n2 >>> for i in range(5):\n3 ... liste1.append([0, 0, 0])\n4 ...\n5\n>>> liste1\n6 [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n7\n>>> liste1[2][0] = -12\n8 >>> liste1\n9\n[[0, 0, 0], [0, 0, 0], [-12, 0, 0], [0, 0, 0], [0, 0, 0]]\nOn verra dans la rubrique suivante une manière très compacte de faire cela avec les listes de compréhension.\nAttention\nMême si une liste de listes peut représenter un tableau de nombres, il ne faut pas la voir comme un objet mathématique\n2\nde type matrice . En effet, le concept de lignes et colonnes n’est pas défini clairement, on ne peut pas faire d’opérations\nmatricielles simplement, etc. On verra dans le chapitre 20 Module Numpy qu’il existe des objets appelés arrays qui sont\nfaits pour ça."
  },
  {
    "title": "Liste de compréhension",
    "content": "Conseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nEn Python, la notion de liste de compréhension (ou compréhension de listes) représente une manière originale et très\npuissante de générer des listes. La syntaxe de base consiste au moins en une boucle au sein de crochets précédés\nfor\nd’une variable (qui peut être la variable d’itération ou pas) :\n1.\nhttps://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range\n2. https://fr.wikipedia.org/wiki/Matrice\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 123\nChapitre 12. Plus sur les listes 12.7. Liste de compréhension\n1\n>>> [i for i in range(10)]\n2 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n3\n>>> [2 for i in range(10)]\n4 [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n3 4\nPour plus de détails, consultez à ce sujet le site de Python et celui de Wikipédia .\nVoici quelques exemples illustrant la puissance des listes de compréhension.\n12.7.1 Initialisation d’une liste de listes\nUne liste de compréhension permet l’initialisation d’une liste de listes en une ligne sans avoir l’inconvénient de faire\nune référence vers la même sous-liste (voir rubrique précédente) :\n1 >>> liste1 = [[0, 0, 0] for i in range(5)]\n2 >>> liste1\n3\n[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\n4 >>> liste1[2][0] = -12\n5\n>>> liste1\n6 [[0, 0, 0], [0, 0, 0], [-12, 0, 0], [0, 0, 0], [0, 0, 0]]\n12.7.2 Nombres pairs compris entre 0 et 30\n1 >>> print([i for i in range(31) if i % 2 == 0])\n2\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]\n12.7.3 Jeu sur la casse des mots d’une phrase\n1 >>> message = \"C'est sympa la BioInfo\"\n2 >>> msg_lst = message.split()\n3 >>> print([[m.upper(), len(m)] for m in msg_lst])\n4 [[\"C'EST\", 5], ['SYMPA', 5], ['LA', 2], ['BIOINFO', 7]]\n12.7.4 Formatage d’une séquence avec 60 caractères par ligne\nExemple d’une séquence constituée de 150 alanines :\n1\n# Exemple d'une séquence de 150 alanines.\n2 >>> seq = \"A\" * 150\n3\n>>> width = 60\n4 >>> seq_split = [seq[i:i+width] for i in range(0, len(seq), width)]\n5\n>>> print(\"\\n\".join(seq_split))\n6 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n7\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n8 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n12.7.5 Formatage FASTA d’une séquence\nExemple d’une séquence constituée de 150 alanines :\n1\n>>> com = \"Séquence de 150 alanines\"\n2 >>> seq = \"A\" * 150\n3\n>>> width = 60\n4 >>> seq_split = [seq[i:i+width] for i in range(0, len(seq), width)]\n5\n>>> print(\">\"+com+\"\\n\"+\"\\n\".join(seq_split))\n6 >séquence de 150 alanines\n7 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n8\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n9 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n3.\nhttp://www.python.org/dev/peps/pep-0202/\n4. http://fr.wikipedia.org/wiki/Comprehension_de_liste\n124 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n12.8. Tris puissants de listes Chapitre 12. Plus sur les listes\n12.7.6 Sélection des carbones alpha dans un fichier PDB\n5\nExemple avec la structure de la barstar :\n1 >>> with open(\"1bta.pdb\", \"r\") as f_pdb:\n2\n... CA_lines = [\n3 ... line for line in f_pdb\n4\n... if line.startswith(\"ATOM\") and line[12:16].strip() == \"CA\"\n5 ... ]\n6\n...\n7 >>> print(len(CA_lines))\n8\n89\nConseil\nPour plus de lisiblité, il est possible de répartir la liste de compréhension sur plusieurs lignes.\n12.7.7 Portée des variables dans une liste de compréhension\nContrairement à une boucle , la variable d’itération d’une liste de compréhension n’est pas accessible en dehors\nfor\nde la liste de compréhension elle-même. Par exemple :\n1\n>>> liste_a = []\n2 >>> for idx_a in range(10):\n3 ... liste_a.append(idx_a)\n4\n...\n5 >>> print(liste_a)\n6\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n7 >>> print(idx_a)\n8\n9\n9 >>>\n10\n>>> liste_b = [idx_b for idx_b in range(10)]\n11 >>> print(liste_b)\n12\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n13 >>> print(idx_b)\n14\nTraceback (most recent call last):\n15 File \"<stdin>\", line 1, in <module>\n16 NameError: name 'idx_b' is not defined. Did you mean: 'idx_a'?\nLa variable d’itération reste disponible en dehors de la boucle . Par contre, la variable d’itération\nidx_a for idx_b\nn’est pas disponible en dehors de la liste de compréhension, car elle est créée « à la volée » par Python puis éliminée une\nfois l’instruction exécutée."
  },
  {
    "title": "Tris puissants de listes",
    "content": "Conseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nUn peu plus haut nous avons évoqué la méthode qui trie une liste sur place, ainsi que la fonction\n.sort() sorted()\nqui renvoie une nouvelle liste triée. Nous avons également vu qu’elles supportaient l’argument par mot-clé pour\nreverse\ntrier dans le sens inverse (décroissant ou anti-ASCII). Il existe un autre argument par mot-clé nommé permettant un\nkey\ntri avec des règles alternatives que nous pouvons customiser. On doit passer à une fonction callback (nous avions\nkey\ndéjà croisé cette notion avec la fonction dans le chapitre 11 Plus sur les chaînes de caractères, pour une définition\nmap()\nvoir le chapitre 25 Fenêtres graphiques et Tkinter (en ligne)), c’est-à-dire, un nom de fonction sans les parenthèses. Par\nexemple, si on passe la callback comme ça :\nlen\n5. http://www.rcsb.org/pdb/explore.do?structureId=1BTA\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 125\nChapitre 12. Plus sur les listes 12.9. Exercices\n1\n>>> mots = [\"babar\", \"bar\", \"ba\", \"bababar\"]\n2 >>> sorted(mots, key=len)\n3\n['ba', 'bar', 'babar', 'bababar']\nPython trie la liste en considérant la longeur de chaque élément, donc ici le nombre de lettres de chaque chaîne\nmots\nde caractères. Si plusieurs mots ont la même longueur ( et dans l’exemple suivant), les laisse dans\nbar bam sorted()\nl’ordre de la liste initiale.\n1 >>> mots = [\"bar\", \"babar\", \"bam\", \"ba\", \"bababar\"]\n2\n>>> sorted(mots, key=len)\n3 ['ba', 'bar', 'bam', 'babar', 'bababar']\nLà où va se révéler puissant est quand nous allons lui passer une fonction « maison ». Voici une exemple :\nkey\n1 >>> def compte_b(chaine):\n2\n... return chaine.count(\"b\")\n3 ...\n4\n>>> compte_b(\"babar\")\n5 2\n6\n>>> mots = [\"bar\", \"babar\", \"bam\", \"ba\", \"bababar\"]\n7 >>> sorted(mots, key=compte_b)\n8\n['bar', 'bam', 'ba', 'babar', 'bababar']\n•\nLignes 1 à 5. Comme son nom l’indique, la fonction compte les lettres dans une chaîne de\ncompte_b() b\ncaractères.\n•\nLignes 7 et 8. En donnant (notez l’absence de parenthèses) à l’argument , Python trie en fonction\ncompte_b key\ndu nombre de lettres dans chaque mot ! Comme pour , si plusieurs mots ont un nombre de lettres identiques,\nb len b\nil conserve l’ordre de la liste initiale.\nRemarque\nL’argument fonctionne de la même manière entre et la méthode qui trie sur place. Cet\nkey sorted() .sort()\nargument existe aussi avec les fonctions et . Par exemple :\nmin() max()\n1 >>> mots = [\"bar\", \"babar\", \"bam\", \"ba\", \"bababar\"]\n2\n>>> min(mots, key=len)\n3 'ba'\n4\n>>> max(mots, key=len)\n5 'bababar'\nPython renverra le premier élément avec ou le dernier élément avec après un tri sur la longueur de\nmin() max()\nchaque mot.\nPour aller plus loin\nEn Python, trier avec une fonction maison passée à l’argument se fait plutôt avec ce qu’on appelle une fonction\nkey\nlambda. Il s’agit d’une « petite » fonction que l’on écrit sur une ligne. Si vous voulez en savoir plus, vous pouvez consulter\nle chapitre 26 Remarques complémentaires."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n126 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n12.9. Exercices Chapitre 12. Plus sur les listes\n12.9.1 Tri de liste\nSoit la liste de nombres . Triez les nombres de cette liste par ordre croissant,\n[8, 3, 12.5, 45, 25.5, 52, 1]\nsans utiliser la fonction . Les fonctions et méthodes , et vous seront utiles.\nsort() min() .append() .remove()\n12.9.2 Séquence d’ADN aléatoire\nCréez une fonction qui prend comme argument un entier positif représentant le nombre de bases\nseq_alea() taille\nde la séquence et qui renvoie une séquence d’ADN aléatoire sous forme d’une chaîne de caractères. Utilisez la fonction\nprésentée dans le chapitre 9 Modules.\nrandom.choices()\nUtilisez la fonction pour générer aléatoirement une séquence d’ADN de 15 bases.\nseq_alea()\n12.9.3 Séquence d’ADN complémentaire inverse\nCréez une fonction qui prend comme argument une séquence d’ADN sous la forme d’une chaîne de\ngen_comp_inv()\ncaractères, qui renvoie la séquence complémentaire inverse sous la forme d’une autre chaîne de caractères et qui utilise\ndes méthodes associées aux listes. Dans cette fonction, utilisez un dictionnaire\n{\"A\": \"T\", \"T\": \"A\", \"G\": \"C\",\ndonnant la correspondance entre nucléotides des brins direct et complémentaire.\n\"C\": \"G\"}\nUtilisez cette fonction pour transformer la séquence d’ADN en sa séquence complémentaire\nTCTGTTAACCATCCACTTCG\ninverse.\nRappel : la séquence complémentaire inverse doit être « inversée ». Par exemple, la séquence complémentaire inverse\nde la séquence est .\nATCG CGAT\n12.9.4 Doublons\nSoit la liste de nombres . À partir de , créez une nouvelle\nliste1 = [5, 1, 1, 2, 5, 6, 3, 4, 4, 4, 2] liste1\nliste sans les doublons, triez-la et aﬀichez-la.\n12.9.5 Séquence d’ADN aléatoire 2\nCréez une fonction qui prend comme argument un entier et quatre floats, représentant respective-\nseq_alea_2()\nment la longueur de la séquence et les pourcentages de chacune des quatre bases A, T, G et C. La fonction générera\naléatoirement une séquence d’ADN qui prend en compte les contraintes fournies en arguments et renverra la séquence\nsous forme d’une chaîne de caractères.\nUtilisez cette fonction pour générer aléatoirement une séquence d’ADN de 50 bases contenant 10 % de A, 30 % de\nT, 50 % de G et 10 % de C.\nConseil\nUtilisez la fonction avec les paramètres et . Le paramètre spécifie le nombre de\nrandom.choises() k weights k\ntirages aléatoires à réaliser et le paramètre indique les probabilités de tirage.\nweights\nPar exemple, pour réaliser 10 tirages aléatoires entre les lettres et avec 80% de et 20% de , on utilise la\nA B A B\nfonction de la manière suivante :\nrandom.choices()\n1 >>> import random\n2\n>>> random.choices(\"AB\", k=10, weights=[80, 20])\n3 ['A', 'A', 'A', 'A', 'A', 'A', 'A', 'B', 'A', 'B']\n6\nN’hésitez pas à consulter la documentation de la fonction pour plus de détails.\nrandom.choices()\n12.9.6 Le nombre mystère\nTrouvez le nombre mystère qui répond aux conditions suivantes :\n•\nIl est composé de trois chiffres.\n•\nIl est strictement inférieur à 300.\n•\nIl est pair.\n•\nDeux de ses chiffres sont identiques.\n6. https://docs.python.org/fr/3/library/random.html#random.choices\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 127\nChapitre 12. Plus sur les listes 12.9. Exercices\n•\nLa somme de ses chiffres est égale à 7.\nOn vous propose d’employer une méthode dite « brute force », c’est-à-dire d’utiliser une boucle et à chaque itération\nde tester les différentes conditions.\n12.9.7 Codes une et trois lettres des acides aminés\nOn donne les deux listes suivantes décrivant quelques acides aminés en code une et trois lettres :\n1\ncode_1_lettre = [\"A\", \"V\", \"L\", \"M\", \"P\"]\n2 code_3_lettres = [\"Ala\", \"Val\", \"Leu\", \"Met\", \"Pro\"]\nAvec la fonction et une boucle, générez la sortie suivante :\nzip()\nL'acide aminé se note A ou Ala\nL'acide aminé se note V ou Val\nL'acide aminé se note L ou Leu\nL'acide aminé se note M ou Met\nL'acide aminé se note P ou Pro\n12.9.8 Triangle de Pascal (exercice +++)\nVoici le début du triangle de Pascal :\n1\n1 1\n1 2 1\n1 3 3 1\n1 4 6 4 1\n1 5 10 10 5 1\n[...]\nDéduisez comment une ligne est construite à partir de la précédente. Par exemple, à partir de la ligne 2 ( ),\n1 1\nconstruisez la ligne suivante (ligne 3 : ) et ainsi de suite.\n1 2 1\nImplémentez cette construction en Python. Généralisez à l’aide d’une boucle.\nÉcrivez dans un fichier les 10 premières lignes du triangle de Pascal.\npascal.out\n128 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Plus sur les fonctions",
    "content": "Avant d’aborder ce chapitre, nous vous conseillons de relire le chapitre 10 Fonctions et de bien en assimiler toutes les\nnotions (et aussi d’en faire les exercices). Nous avons vu dans ce chapitre 10 le concept incontournable que représentent\nles fonctions. Nous avons également introduit la notion de variables locales et globales.\nDans ce chapitre, nous allons aller un peu plus loin sur la visibilité de ces variables dans et hors des fonctions, et\naussi voir ce qui se passe lorsque ces variables sont des listes. Attention, la plupart des lignes de code ci-dessous sont\ndonnées à titre d’exemple pour bien comprendre ce qui se passe, mais nombre d’entre elles sont des aberrations en terme\nde programmation. Nous ferons un récapitulatif des bonnes pratiques à la fin du chapitre. Enfin, nous vous conseillons\n1\nde tester tous les exemples ci-dessous avec le site Python Tutor afin de suivre l’état des variables lors de l’exécution des\nexemples."
  },
  {
    "title": "Appel d’une fonction dans une fonction",
    "content": "Dans le chapitre 10, nous avons vu des fonctions qui étaient appelées depuis le programme principal. Il est en fait\npossible d’appeler une fonction depuis une autre fonction. Et plus généralement, on peut appeler une fonction de n’importe\noù à partir du moment où elle est visible par Python (c’est-à-dire chargée dans la mémoire). Observez cet exemple :\n1\n# Définition des fonctions.\n2 def est_pair(x):\n3\nif x % 2 == 0:\n4 return True\n5\nelse:\n6 return False\n7\n8\ndef calc_somme_nb_pairs(debut, fin):\n9 somme = 0\n10\nfor nombre in range(debut, fin+1):\n11 if est_pair(nombre):\n12\nsomme += nombre\n13\n14\n# Programme principal.\n15 somme = calc_somme_nb_pairs(1, 5)\n16\nprint(f\"La somme des nombres pairs de 1 à 5 est {somme}\")\nNous appelons la fonction depuis le programme principal, puis à l’intérieur de celle-ci nous\ncalc_somme_nb_pairs()\n1. http://www.pythontutor.com/\n129\nChapitre 13. Plus sur les fonctions 13.2. Fonctions récursives\nappelons l’autre fonction . Regardons ce que Python Tutor nous montre lorsque la fonction\nest_pair() calc_somme_nb_pairs\nest exécutée dans la Figure 13.1.\n()\nFigure 13.1 – Appel d’une fonction dans une fonction.\nL’espace mémoire alloué à est grisé, indiquant que cette fonction est en cours d’exécution. La fonction\nest_pair()\nappelante est toujours là (sur un fond blanc) car son exécution n’est pas terminée. Elle est\ncalc_somme_nb_pairs()\nen quelque sorte figée dans le même état qu’avant l’appel de , et on pourra ainsi noter que ses variables\nest_pair()\nlocales ( , ) sont toujours là. De manière générale, les variables locales d’une fonction ne seront détruites que\ndebut fin\nlorsque l’exécution de celle-ci sera terminée. Dans notre exemple, les variables locales de ne\ncalc_somme_nb_pairs()\nseront détruites que lorsque la boucle sera terminée et que la variable sera retournée au programme principal.\nsomme\nEnfin, notez bien que la fonction appelle la fonction à chaque itération de la\ncalc_somme_nb_pairs() est_pair()\nboucle.\nAinsi, le programmeur est libre de faire tous les appels qu’il souhaite. Une fonction peut appeler une autre fonction,\ncette dernière peut appeler une autre fonction et ainsi de suite (et autant de fois qu’on le veut). Une fonction peut même\ns’appeler elle-même, cela s’appelle une fonction récursive (voir la rubrique suivante). Attention toutefois à retrouver vos\npetits si vous vous perdez dans les appels successifs !\nConseil\nDans la fonction on teste si le nombre est pair et on renvoie , sinon on renvoie . Cette\nest_pair() True False\nfonction pourrait être écrite de manière plus compacte :\n1\ndef est_pair(x):\n2 return x % 2\nComme l’expression renvoie un booléen directement, elle revient au même que le / ci-dessus. C’est\nx % 2 if else\nbien sûr cette dernière notation plus compacte que nous vous recommandons."
  },
  {
    "title": "Fonctions récursives",
    "content": "Conseil\n130 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n13.2. Fonctions récursives Chapitre 13. Plus sur les fonctions\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nUne fonction récursive est une fonction qui s’appelle elle-même. Les fonctions récursives permettent d’obtenir une\n2\neﬀicacité redoutable dans la résolution de certains algorithmes, comme le tri rapide (en anglais, quicksort).\nOublions la recherche d’eﬀicacité pour l’instant et concentrons-nous sur l’exemple de la fonction mathématique\nfactorielle. Nous vous rappelons que la factorielle s’écrit avec un et se définit de la manière suivante :\n!\n× ×\n3! = 3 2 1 = 6\n× × ×\n4! = 4 3 2 1 = 30\n...\n× − × × ×\nn = n n ...\n! 1 2 1\nVoici le code Python avec une fonction récursive :\n1 def calc_factorielle(nb):\n2\nif nb == 1:\n3 return 1\n4\nelse:\n5 return nb * calc_factorielle(nb - 1)\n6\n7\n# Programme principal.\n8 print(calc_factorielle(4))\nPas si facile à comprendre, n’est-ce pas ? À nouveau, aidons nous de Python Tutor pour visualiser ce qui se passe\ndans la figure 13.2 (nous vous conseillons bien sûr de tester vous-même cet exemple) :\nFigure 13.2 – Fonction récursive : factorielle.\nLigne 8, on appelle la fonction en passant comme argument l’entier 4. Dans la fonction, la\ncalc_factorielle()\nvariable locale qui récupère cet argument est . Au sein de la fonction, celle-ci se rappelle elle-même (ligne 5), mais cette\nnb\nfois-ci en passant la valeur 3. Au prochain appel, ce sera avec la valeur 2, puis finalement 1. Dans ce dernier cas, le test\n2. https://fr.wikipedia.org/wiki/Tri_rapide\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 131\nChapitre 13. Plus sur les fonctions 13.3. Portée des variables\nest vrai et l’instruction sera exécutée. À ce moment précis de l’exécution, les appels successifs\nif nb == 1: return 1\nforment une sorte de pile (voir la figure 13.2). La valeur 1 sera ainsi renvoyée au niveau de l’appel précédent, puis le\n×\nrésultat 2 1 = 2 (où 2 correspond à et 1 provient de , soit 1) va être renvoyé à l’appel\nnb calc_factorielle(nb - 1)\n×\nprécédent, puis = (où 3 correspond à et 2 provient de , soit 2) va être renvoyé\n3 2 6\nnb calc_factorielle(nb - 1)\n×\nà l’appel précédent, pour finir par 4 6 = 24 (où 4 correspond à et 6 provient de , soit\nnb calc_factorielle(nb - 1)\n6), soit la valeur de . Les appels successifs vont donc se « dépiler » et nous reviendrons dans le programme principal.\n4!\nMême si les fonctions récursives peuvent être ardues à comprendre, notre propos est ici de vous illustrer qu’une\nfonction qui en appelle une autre (ici il s’agit d’elle-même) reste « figée » dans le même état, jusqu’à ce que la fonction\nappelée lui renvoie une valeur."
  },
  {
    "title": "Portée des variables",
    "content": "Il est très important lorsque l’on manipule des fonctions de connaître la portée des variables (scope en anglais),\nc’est-à-dire savoir là où elles sont visibles. On a vu que les variables créées au sein d’une fonction ne sont pas visibles à\nl’extérieur de celle-ci car elles étaient locales à la fonction. Observez le code suivant :\n1\n>>> def ma_fonction():\n2 ... x = 2\n3\n... print(f\"x vaut {x} dans la fonction\")\n4 ...\n5\n>>> ma_fonction()\n6 x vaut 2 dans la fonction\n7 >>> print(x)\n8\nTraceback (most recent call last):\n9 File \"<stdin>\", line 1, in <module>\n10\nNameError: name 'x' is not defined\nLorsque Python exécute le code de la fonction, il connaît le contenu de la variable . Par contre, de retour dans le\nx\nmodule principal (dans ce cas, il s’agit de l’interpréteur Python), il ne la connaît plus, d’où le message d’erreur.\nDe même, une variable passée en argument est considérée comme locale lorsqu’on arrive dans la fonction :\n1 >>> def ma_fonction(x):\n2\n... print(f\"x vaut {x} dans la fonction\")\n3 ...\n4 >>> ma_fonction(2)\n5\nx vaut 2 dans la fonction\n6 >>> print(x)\n7\nTraceback (most recent call last):\n8 File \"<stdin>\", line 1, in <module>\n9\nNameError: name 'x' is not defined\nLorsqu’une variable est déclarée dans le programme principal, elle est visible dans celui-ci ainsi que dans toutes les\nfonctions. On a vu qu’on parlait de variable globale :\n1 >>> def ma_fonction():\n2\n... print(x)\n3 ...\n4\n>>> x = 3\n5 >>> ma_fonction()\n6 3\n7\n>>> print(x)\n8 3\nDans ce cas, la variable est visible dans le module principal et dans toutes les fonctions du module. Toutefois,\nx\nPython ne permet pas la modification d’une variable globale dans une fonction :\n1\n>>> def ma_fonction():\n2 ... x = x + 1\n3\n...\n4 >>> x = 1\n5\n>>> ma_fonction()\n6 Traceback (most recent call last):\n7\nFile \"<stdin>\", line 1, in <module>\n8 File \"<stdin>\", line 2, in ma_fonction\n9\nUnboundLocalError: cannot access local variable 'x' where it is not associated with a value\n132 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n13.4. Portée des listes Chapitre 13. Plus sur les fonctions\nL’erreur renvoyée montre que Python pense que est une variable locale qui n’a pas été encore assignée. Si on veut\nx\nvraiment modifier une variable globale dans une fonction, il faut utiliser le mot-clé :\nglobal\n1\n>>> def ma_fonction():\n2 ... global x\n3 ... x = x + 1\n4\n...\n5 >>> x = 1\n6\n>>> ma_fonction()\n7 >>> x\n8\n2\nDans ce dernier cas, le mot-clé a forcé la variable à être globale plutôt que locale au sein de la fonction.\nglobal x"
  },
  {
    "title": "Portée des listes",
    "content": "Attention\nLes exemples de cette partie représentent des absurdités en termes de programmation. Ils sont donnés à titre indicatif\npour comprendre ce qui se passe, mais il ne faut surtout pas s’en inspirer !\nSoyez extrêmement attentifs avec les types modifiables (tels que les listes) car vous pouvez les changer au sein d’une\nfonction :\n1 >>> def ma_fonction():\n2\n... liste1[1] = -127\n3 ...\n4\n>>> liste1 = [1,2,3]\n5 >>> ma_fonction()\n6\n>>> liste1\n7 [1, -127, 3]\nDe même, si vous passez une liste en argument, elle est modifiable au sein de la fonction :\n1 >>> def ma_fonction(liste_tmp):\n2\n... liste_tmp[1] = -15\n3 ...\n4\n>>> liste1 = [1,2,3]\n5 >>> ma_fonction(liste1)\n6 >>> liste1\n7 [1, -15, 3]\n3\nPour bien comprendre l’origine de ce comportement, utilisons à nouveau le site Python Tutor . La figure 13.3 vous\nmontre le mécanisme à l’oeuvre lorsqu’on passe une liste à une fonction.\nL’instruction dans la fonction est une instruction Python qui ne fait rien. Elle est là car une fonction ne peut\npass\nêtre vide et doit contenir au moins une instruction Python valide.\nOn voit très clairement que la variable passée en argument lors de l’appel de la fonction d’une part, et la\nliste1\nvariable locale au sein de la fonction d’autre part, pointent vers le même objet dans la mémoire. Ainsi,\nliste_tmp\nsi on modifie , on modifie aussi . C’est exactement le même mécanisme que pour la copie de listes\nliste_tmp liste1\n(cf. rubrique 11.4 Copie de listes du chapitre 12 Plus sur les listes).\nSi vous voulez éviter les problèmes de modification malencontreuse d’une liste dans une fonction, utilisez des tuples (ils\nont présentés dans le chapitre 8 Dictionnaires et tuples), Python renverra une erreur car ces derniers sont non modifiables.\nUne autre solution pour éviter la modification d’une liste, lorsqu’elle est passée comme argument à une fonction, est\nde la passer explicitement (comme nous l’avons fait pour la copie de liste) afin qu’elle reste intacte dans le programme\nprincipal :\n3. http://www.pythontutor.com/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 133\nChapitre 13. Plus sur les fonctions 13.5. Règle LGI\nFigure 13.3 – Passage d’une liste à une fonction.\n1 >>> def ma_fonction(liste_tmp):\n2\n... liste_tmp[1] = -15\n3 ...\n4 >>> liste1 = [1, 2, 3]\n5\n>>> ma_fonction(liste1[:])\n6 >>> liste1\n7\n[1, 2, 3]\n8 >>> ma_fonction(liste1(y))\n9\n>>> liste1\n10 [1, 2, 3]\nDans ces deux derniers exemples, une copie de est créée à la volée lorsqu’on appelle la fonction, ainsi la liste du\ny y\nmodule principal reste intacte.\nD’autres suggestions sur l’envoi de liste dans une fonction vous sont données dans la rubrique Recommandations\nci-dessous."
  },
  {
    "title": "Règle LGI",
    "content": "Lorsque Python rencontre une variable, il va traiter la résolution de son nom avec des priorités particulières. D’abord\nil va regarder si la variable est locale, puis si elle n’existe pas localement, il vérifiera si elle est globale et enfin si elle\nn’est pas globale, il testera si elle est interne (par exemple la fonction est considérée comme une fonction interne\nlen()\nà Python, elle existe à chaque fois que vous lancez Python). On appelle cela la règle LGI pour locale, globale, interne.\nEn voici un exemple :\n1\n>>> def ma_fonction():\n2 ... x = 4\n3\n... print(f\"Dans la fonction x vaut {x}\")\n4 ...\n5 >>> x = -15\n6\n>>> ma_fonction()\n7 Dans la fonction x vaut 4\n8\n>>> print(f\"Dans le module principal x vaut {x}\")\n9 Dans le module principal x vaut -15\nDans la fonction, a pris la valeur qui lui était définie localement en priorité sur la valeur définie dans le module\nx\nprincipal.\nConseil\nMême si Python accepte qu’une variable ait le même nom que ses propres fonctions ou variables internes, évitez\n134 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n13.6. Recommandations Chapitre 13. Plus sur les fonctions\nd’utiliser de tels noms, car ceci rendra votre code confus !\nDe manière générale, la règle LGI découle de la manière dont Python gère ce que l’on appelle « les espaces de noms ».\nC’est cette gestion qui définit la portée (visibilité) de chaque variable. Nous en parlerons plus longuement dans le chapitre\n24 Avoir plus la classe avec les objets (en ligne)."
  },
  {
    "title": "Recommandations",
    "content": "13.6.1 Évitez les variables globales\nDans ce chapitre nous avons joué avec les fonctions (et les listes) afin de vous montrer comment Python réagissait.\nToutefois, notez bien que l’utilisation de variables globales est à bannir définitivement de votre pratique de la\nprogrammation.\nParfois on veut faire vite et on crée une variable globale visible partout dans le programme (donc dans toutes les\nfonctions), car « Ça va plus vite, c’est plus simple ». C’est un très mauvais calcul, ne serait-ce que parce que vos fonctions\nne seront pas réutilisables dans un autre contexte si elles utilisent des variables globales ! Ensuite, arriverez-vous à vous\n4\nrelire dans six mois ? Quelqu’un d’autre pourrait-il comprendre votre programme ? Il existe de nombreuses autres raisons\nque nous ne développerons pas ici, mais libre à vous de consulter de la documentation externe.\nHeureusement, Python est orienté objet et permet « d’encapsuler » des variables dans des objets et de s’affranchir\ndéfinitivement des variables globales (nous verrons cela dans le chapitre 23 Avoir la classe avec les objets). En attendant,\net si vous ne souhaitez pas aller plus loin sur les notions d’objet (on peut tout à fait « pythonner » sans cela), retenez la\nchose suivante sur les fonctions et les variables globales :\nConseil\nPlutôt que d’utiliser des variables globales, passez vos variables explicitement aux fonctions comme des argument(s).\n13.6.2 Modification d’une liste dans une fonction\nConcernant les fonctions qui modifient une liste, nous vous conseillons de l’indiquer clairement dans votre code. Pour\ncela, faites en sorte que la fonction renvoie la liste modifiée et de récupérer cette liste renvoyée dans une variable portant\nle même nom. Par exemple :\n1 def ajoute_un(liste):\n2 for indice in range(len(liste)):\n3\nliste[indice] += 1\n4 return liste\n5\n6 # Programme principal.\n7\nliste_notes = [10, 8, 16, 7, 15]\n8 liste_notes = ajoute_un(liste_notes)\n9\nprint(liste_notes)\nLa ligne 8 indique que la liste passée à la fonction est écrasée par la liste renvoyée par la fonction.\nliste_notes\nLe code suivant produirait la même sortie :\n1\ndef ajoute_un(liste):\n2 for indice in range(len(liste)):\n3\nliste[indice] += 1\n4\n5 # Programme principal.\n6\nliste_notes = [10, 8, 16, 7, 15]\n7 ajoute_un(liste_notes)\n8\nprint(liste_notes)\nCela reste toutefois moins intuitif, car il n’est pas évident de comprendre que la liste est modifiée dans la fonction\nen lisant la ligne 7. Dans un tel cas, il serait essentiel d’indiquer dans la documentation de la fonction que la liste est\n4. http://wiki.c2.com/?GlobalVariablesAreBad\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 135\nChapitre 13. Plus sur les fonctions 13.7. Exercices\nmodifiée « sur place » (in place en anglais) dans la fonction. Vous verrez dans le chapitre 15 Création de modules\ncomment documenter vos fonctions.\nConseil\nPour les raisons évoquées ci-dessus, nous vous conseillons de privilégier la première version :\n1\nliste_notes = ajoute_un(liste_notes)\n13.6.3 Conclusion\nVous connaissez maintenant les fonctions sous tous leurs angles. Comme indiqué en introduction du chapitre 10, elles\nsont incontournables et tout programmeur se doit de les maîtriser. Voici les derniers conseils que nous pouvons vous\ndonner :\n•\nLorsque vous débutez un nouveau projet de programmation, posez-vous la question : « Comment pourrais-je\ndécomposer en blocs chaque tâche à effectuer, chaque bloc pouvant être une fonction ? ». Et n’oubliez pas que si\nune fonction s’avère trop complexe, vous pouvez la décomposer en d’autres fonctions.\n•\nAu risque de nous répéter, forcez-vous à utiliser des fonctions en permanence. Pratiquez, pratiquez… et pratiquez\nencore !"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour le second exercice, créez un script puis exécutez-le dans un shell.\n13.7.1 Prédire la sortie\nPrédisez le comportement des codes suivants, sans les recopier dans un script ni dans l’interpréteur Python :\n13.7.1.1 Code 1\n1\ndef hello(prenom):\n2 print(f\"Bonjour {prenom}\")\n3\n4\n5\n# Programme principal.\n6 hello(\"Patrick\")\n7\nprint(x)\n13.7.1.2 Code 2\n1 def hello(prenom):\n2\nprint(f\"Bonjour {prenom}\")\n3\n4\n5 # Programme principal.\n6\nx = 10\n7 hello(\"Patrick\")\n8\nprint(x)\n136 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n13.7. Exercices Chapitre 13. Plus sur les fonctions\n13.7.1.3 Code 3\n1 def hello(prenom):\n2 print(f\"Bonjour {prenom}\")\n3 print(x)\n4\n5\n6 # Programme principal.\n7\nx = 10\n8 hello(\"Patrick\")\n9\nprint(x)\n13.7.1.4 Code 4\n1\ndef hello(prenom):\n2 x = 42\n3\nprint(f\"Bonjour {prenom}\")\n4 print(x)\n5\n6\n7\n# Programme principal.\n8 x = 10\n9\nhello(\"Patrick\")\n10 print(x)\n13.7.2 Passage de liste à une fonction\nCréez une fonction qui prend en argument une liste et qui ajoute un nombre entier aléatoire\najoute_nb_alea()\nentre -10 et 10 (inclus) à chaque élément. La fonction aﬀichera à l’écran cette nouvelle liste modifiée.\nDans le programme principal, effectuez les actions suivantes :\n1. Créez une variable .\nma_liste = [7, 3, 8, 4, 5, 1, 9, 10, 2, 6]\n2. Aﬀichez à l’écran.\nma_liste\n3. Appelez la fonction en lui passant en argument.\najoute_nb_alea() ma_liste\n4. Aﬀichez à nouveau à l’écran.\nma_liste\nComment expliquez-vous le résultat obtenu ?\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 137"
  },
  {
    "title": "Conteneurs",
    "content": "Dans ce chapitre, nous allons aborder la notion de conteneur, revenir sur certaines propriétés avancées des dictionnaires\net tuples, et enfin aborder les types set et frozenset. Pour les débutants, ce chapitre aborde des notions relativement\navancées. Avant de vous lancer, nous vous conseillons vivement de bien maitriser les chapitres 4 Listes et 12 Plus sur les\nlistes, ainsi que le chapitre 8 Dictionnaires et tuples, d’avoir effectué un maximum d’exercices, et de vous sentir à l’aise\navec toutes les notions abordées jusque là."
  },
  {
    "title": "Généralités",
    "content": "14.1.1 Définition et propriétés\nDéfinition\nUn conteneur (container en anglais) est un nom générique pour définir un objet Python qui contient une collection\nd’autres objets.\nLes conteneurs que nous connaissons depuis le début de ce cours sont les listes, les chaînes de caractères, les diction-\nnaires et les tuples. Même si on ne l’a pas vu explicitement, les objets de type range sont également des conteneurs.\nDans la suite de cette rubrique, nous allons examiner les différentes propriétés des conteneurs. À la fin de ce chapitre,\nnous ferons un tableau récapitulatif de ces propriétés.\nExaminons d’abord les propriétés qui caractérisent tous les types de conteneur.\n•\nCapacité à supporter le test d’appartenance. Souvenez-vous, il permet de vérifier si un élément était présent dans\nune liste. Cela fonctionne donc aussi sur les chaînes de caractères ou tout autre conteneur :\n1 >>> liste1 = [4, 5, 6]\n2\n>>> 4 in liste1\n3 True\n4\n>>> \"to\" in \"toto\"\n5 True\n•\nCapacité à supporter la fonction renvoyant la longueur du conteneur.\nlen()\nVoici d’autres propriétés générales que nous avons déjà croisées. Un conteneur peut être :\n•\nOrdonné (ordered en anglais) : il y a un ordre précis des éléments ; cet ordre correspond à celui utilisé lors de la\ncréation ou de la modification du conteneur (si cela est permis) ; ce même ordre est utilisé lorsqu’on itère dessus.\n138\n14.1. Généralités Chapitre 14. Conteneurs\n•\nIndexable (subscriptable en anglais) : on peut retrouver un élément par son indice (c’est-à-dire sa position dans le\nconteneur) ou plusieurs éléments avec une tranche ; en général, tout conteneur indexable est ordonné.\n•\nItérable (iterable en anglais) : on peut faire une boucle dessus.\nCertains conteneurs sont appelés objets séquentiels ou séquence.\nDéfinition\nUn objet séquentiel ou séquence est un conteneur itérable, ordonné et indexable. Les objets séquentiels sont les\nlistes, les chaînes de caractères, les objets de type range, ainsi que les tuples.\nUne autre propriété importante que l’on a déjà croisée, et qui nous servira dans ce chapitre, concerne la possibilité\nou non de modifier un objet.\n•\nUn objet est dit non modifiable lorsqu’on ne peut pas le modifier, ou lorsqu’on ne peut pas en modifier un de\n1\nses éléments si c’est un conteneur. On parle aussi d’objet immuable (immutable object en anglais). Cela signifie\nqu’une fois créé, Python ne permet plus de le modifier par la suite.\nQu’en est-il des objets que nous connaissons ? Les listes sont modifiables, on peut modifier un ou plusieurs de ses\néléments et ajouter ou retirer un élément. Les dictionnaires sont modifiables : pour une clé donnée, on peut changer la\nvaleur correspondante et ajouter ou retirer un couple clé/valeur. Tous les autres types que nous avons vus précédemment\nsont quant à eux non modifiables : les chaînes de caractères ou strings, les tuples, les objets de type range, mais également\ndes objets qui ne sont pas des conteneurs comme les entiers, les floats et les booléens.\nOn comprend bien l’immutabilité des strings comme vu au chapitre 11 Plus sur les chaînes de caractères, mais c’est\nmoins évident pour les entiers, floats ou booléens. Nous allons démontrer cela, mais avant nous avons besoin de définir\nla notion d’identifiant d’un objet.\nDéfinition\nL’identifiant d’un objet est un nombre entier qui est garanti constant pendant toute la durée de vie de l’objet. Cet\nidentifiant est en général unique pour chaque objet. Toutefois, pour des raisons d’optimisation, Python crée parfois le\nmême identifiant pour deux objets non modifiables différents qui ont la même valeur. L’identifiant peut être assimilé\nà l’adresse mémoire de l’objet qui, elle aussi, est unique. En Python, on utilise la fonction interne qui prend en\nid()\nargument un objet et renvoie son identifiant.\nMaintenant que l’identifiant est défini, regardons l’exemple suivant qui montre l’immutabilité des entiers :\n1 >>> var = 4\n2\n>>> id(var)\n3 140318876873440\n4\n>>> var = 5\n5 >>> id(var)\n6\n140318876873472\nLigne 1 on définit l’entier puis on regarde son identifiant. Ligne 4, on pourrait penser que l’on modifie .\nvar var\nToutefois, on voit que son identifiant ligne 6 est différent de la ligne 3. En fait, l’affectation ligne 4 écrase\nvar = 5\nl’ancienne variable et en crée une nouvelle, ce n’est pas la valeur de qui a été changée puisque l’identifiant n’est\nvar var\nplus le même. Le même raisonnement peut être tenu pour les autres types numériques comme les floats et booléens. Si\non regarde maintenant ce qu’il se passe pour une liste :\n1 >>> liste1 = [1, 2, 3]\n2\n>>> id(liste1)\n3 140318850324832\n4\n>>> liste1[1] = -15\n5 >>> id(liste1)\n6\n140318850324832\n7 >>> liste1.append(5)\n8\n>>> id(liste1)\n9 140318850324832\n1. https://fr.wikipedia.org/wiki/Objet_immuable\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 139\nChapitre 14. Conteneurs 14.1. Généralités\nLa liste a été modifiée ligne 4 (changement de l’élément d’indice 1) et ligne 7 (ajout d’un élément). Pour\nliste1\nautant, l’identifiant de cette liste est resté identique tout du long. Ceci démontre la mutabilité des listes : quelle que soit\nla manière dont on modifie une liste, celle-ci garde le même identifiant.\n•\nUne dernière propriété importante est la capacité d’un conteneur (ou tout autre objet Python) à être hachable.\nDéfinition\nUn objet Python est dit hachable (hashable en anglais) s’il est possible de calculer une valeur de hachage sur celui-ci\navec la fonction interne . En programmation, la valeur de hachage peut être vue comme une empreinte numérique\nhash()\nde l’objet. Elle est obtenue en passant l’objet dans une fonction de hachage et dépend du contenu de l’objet. En Python,\ncette empreinte est, comme dans la plupart des langages de programmation, un entier. Au sein d’une même session\nPython, deux objets hachables qui ont un contenu identique auront strictement la même valeur de hachage.\nAttention\nLa valeur de hachage d’un objet renvoyée par la fonction n’a pas le même sens que son identifiant renvoyé\nhash()\npar la fonction . La valeur de hachage est obtenue en « moulinant » le contenu de l’objet dans une fonction de\nid()\nhachage. L’identifiant est quant à lui attribué par Python à la création de l’objet. Il est constant tout le long de la durée\nde vie de l’objet, un peu comme une carte d’identité. Tout objet a un identifiant, mais il doit être hachable pour avoir\nune valeur de hachage.\nPour aller plus loin\n2\nPour aller plus loin, vous pouvez consulter la page Wikipedia sur les fonctions de hachage .\nPourquoi évoquer cette propriété de hachabilité ? D’abord, parce qu’elle est étroitement liée à l’immutabilité. En effet,\nun objet non modifiable est la plupart du temps hachable. Cela permet de l’identifier en fonction de son contenu. Par\nailleurs, l’hachabilité est une implémentation qui permet un accès rapide aux éléments des conteneurs de type dictionnaire\nou set (cf. rubriques suivantes).\nLes objets hachables sont les chaînes de caractères, les entiers, les floats, les booléens, les objets de type range, les\ntuples (sous certaines conditions) et les frozensets ; par contre, les listes, les sets et les dictionnaires sont non hachables.\nLes sets et frozensets seront vus plus bas dans ce chapitre.\nVoici un exemple :\n1 >>> hash(\"Plouf\")\n2\n5085648805260210718\n3 >>> hash(5)\n4\n5\n5 >>> hash(3.14)\n6\n322818021289917443\n7 >>> hash([1, 2, 3])\n8\nTraceback (most recent call last):\n9 File \"<stdin>\", line 1, in <module>\n10 TypeError: unhashable type: 'list'\nLes valeurs de hachage renvoyées par la fonction de Python sont systématiquement des entiers. Par contre,\nhash()\nPython renvoie une erreur pour une liste, car elle est non hachable.\n14.1.2 Conteneurs de type range\nRevenons rapidement sur les objets de type range. Jusqu’à maintenant, on s’en est servi pour faire des boucles ou\ngénérer des listes de nombres. Toutefois, on a vu ci-dessus qu’ils étaient aussi des conteneurs. Ils sont ordonnés, indexables,\nitérables, hachables et non modifiables :\n2. https://fr.wikipedia.org/wiki/Fonction_de_hachage\n140 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.2. Plus sur les dictionnaires Chapitre 14. Conteneurs\n1\n>>> range1 = range(3)\n2 >>> range1[0]\n3\n0\n4 >>> range1[0:1]\n5\nrange(0, 1)\n6 >>> for element in range1:\n7 ... print(element)\n8\n...\n9 0\n10\n1\n11 2\n12\n>>> range1[2] = 10\n13 Traceback (most recent call last):\n14\nFile \"<stdin>\", line 1, in <module>\n15 TypeError: 'range' object does not support item assignment\n16\n>>> hash(range1)\n17 5050907061201647097\nLa tentative de modification d’un élément ligne 12 conduit à la même erreur que lorsqu’on essaie de modifier un\ncaractère d’une chaîne de caractères. Comme pour la plupart des objets Python non modifiables, les objets de type range\nsont hachables."
  },
  {
    "title": "Plus sur les dictionnaires",
    "content": "Nous revenons sur les dictionnaires qui, on l’a vu, sont des conteneurs de correspondance où chaque valeur est associée\nà une clé plutôt qu’un indice. Nous allons voir certaines propriétés avancées des dictionnaires, notamment comment trier\npar clé ou par valeur.\n14.2.1 Objets utilisables comme clé\nToutes les clés de dictionnaire vues dans le chapitre 8 Dictionnaires et tuples et utilisées jusqu’à présent étaient des\nchaînes de caractères. Toutefois, on peut utiliser d’autres types d’objets comme des entiers, des floats, voire des tuples,\ncela peut s’avérer parfois très utile. Une règle est toutefois requise : les objets utilisés comme clé doivent être hachables\n(voir la rubrique précédente pour la définition).\nPourquoi les clés doivent être des objets hachables ? C’est la raison d’être des dictionnaires qui d’ailleurs sont aussi\n3\nappelés table de hachage dans d’autres langages, comme Perl. Convertir chaque clé en sa valeur de hachage permet\nun accès très rapide à chacun des éléments du dictionnaire, ainsi que des comparaisons de clés entre dictionnaires\nextrêmement eﬀicaces. Même si on a vu que deux objets pouvaient avoir la même valeur de hachage, par exemple\na = 5\net , on ne peut mettre qu’une seule fois la clé . Ceci assure que deux clés d’un même dictionnaire ont forcément\nb = 5 5\nune valeur de hachage différente.\nPouvoir utiliser autre chose qu’une chaîne de caractères comme clé peut se révéler très pratique. Par exemple, pour\nune protéine ou un peptide, on pourrait concevoir d’utiliser comme clé le numéro de résidu, et comme valeur le nom de\nrésidu. Imaginons par ailleurs que nous commencions à compter le premier acide aminé à 3 (souvent les fichiers PDB ne\ncommence pas à 1 pour le premier acide aminé). Par exemple :\n1 >>> sequence = {3: 'S', 4: 'E', 5: 'Q', 6: 'P', 7: 'E', 8: 'P', 9: 'T'}\n2\n>>> sequence[5]\n3 'Q'\n4\n>>> sequence[9]\n5 'T'\n6\n>>> for num, res in sequence.items():\n7 ... print(num, res)\n8\n...\n9 3 S\n10\n4 E\n11 5 Q\n12 6 P\n13\n7 E\n14 8 P\n15\n9 T\n3. https://fr.wikipedia.org/wiki/Table_de_hachage\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 141\nChapitre 14. Conteneurs 14.2. Plus sur les dictionnaires\nVous voyez l’énorme avantage, d’utiliser comme clé le numéro de résidu. Avec une liste ou une chaîne de caractère,\nl’indiçage commence à zéro. Ainsi, il faudrait utiliser les indices 2 et 6 pour retrouver respectivement les acides aminés 5\net 9 :\n1 >>> sequence = ['S', 'E', 'Q', 'P', 'E', 'P', 'T']\n2\n>>> sequence[2]\n3 'Q'\n4\n>>> sequence[6]\n5 'T'\n14.2.2 Destruction d’une paire clé/valeur\nComme pour tous les objets Python, l’instruction permet de détruire un couple clé/valeur :\ndel\n1\n>>> dico = {'nom': 'girafe', 'taille': 5.0, 'poids': 1100}\n2 >>> del dico[\"nom\"]\n3\n>>> dico\n4 {'taille': 5.0, 'poids': 1100}\nPour les listes, on utilise l’indice entre crochet pour détruire l’élément, par exemple . Ici, on utilise la\ndel liste[2]\nclé.\n14.2.3 Tri par clés\nOn peut utiliser la fonction vue précédemment avec les listes pour trier un dictionnaire par ses clés :\nsorted()\n1 >>> ani2 = {'nom': 'singe', 'taille': 1.75, 'poids': 70}\n2\n>>> sorted(ani2)\n3 ['nom', 'poids', 'taille']\nLes clés sont triées ici par ordre alphabétique.\n14.2.4 Tri par valeurs\nPour trier un dictionnaire par ses valeurs, il faut utiliser la fonction avec l’argument :\nsorted() key\n1 >>> dico = {\"a\": 15, \"b\": 5, \"c\":20}\n2\n>>> sorted(dico, key=dico.get)\n3 ['b', 'a', 'c']\nL’argument indique explicitement qu’il faut réaliser le tri par les valeurs du dictionnaire. On retrouve\nkey=dico.get\nla méthode vue au chapitre 8 Dictionnaires et tuples, mais sans les parenthèses : , mais pas\n.get() key=dico.get key\n. Une fonction ou méthode passée en argument sans les parenthèses est appelée callback, nous reverrons\n=dico.get()\ncela en détail dans le chapitre 25 Fenêtres graphiques et Tkinter (en ligne).\nAttention, ce sont les clés du dictionnaire qui sont renvoyées, pas les valeurs. Ces clés sont cependant renvoyées dans\nun ordre qui permet d’obtenir les clés triées par ordre croissant :\n1\n>>> dico = {\"a\": 15, \"b\": 5, \"c\":20}\n2 >>> for key in sorted(dico, key=dico.get):\n3\n... print(key, dico[key])\n4 ...\n5\nb 5\n6 a 15\n7\nc 20\nEnfin, l’argument fonctionne également :\nreverse=True\n1\n>>> dico = {\"a\": 15, \"b\": 5, \"c\":20}\n2 >>> sorted(dico, key=dico.get, reverse=True)\n3\n['c', 'a', 'b']\nRemarque\nLorsqu’on trie un dictionnaire par ses valeurs, il faut être sûr que cela soit possible. Ce n’est pas le cas lorsqu’on a un\nmélange de valeurs numériques et chaînes de caractères :\n142 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.2. Plus sur les dictionnaires Chapitre 14. Conteneurs\n1\n>>> ani2 = {'nom': 'singe', 'poids': 70, 'taille': 1.75}\n2 >>> sorted(ani2, key=ani2.get)\n3\nTraceback (most recent call last):\n4 File \"<stdin>\", line 1, in <module>\n5\nTypeError: '<' not supported between instances of 'int' and 'str'\nOn obtient ici une erreur, car Python ne sait pas comparer une chaîne de caractères ( ) avec des valeurs\nsinge\nnumériques ( et ).\n70 1.75\n14.2.5 Clé associée au minimum ou au maximum des valeurs\nLes fonctions et , que vous avez déjà manipulées dans les chapitres précédents, acceptent également\nmin() max()\nl’argument . On peut ainsi obtenir la clé associée au minimum ou au maximum des valeurs d’un dictionnaire :\nkey=\n1 >>> dico = {\"a\": 15, \"b\": 5, \"c\":20}\n2\n>>> max(dico, key=dico.get)\n3 'c'\n4\n>>> min(dico, key=dico.get)\n5 'b'\n14.2.6 Fonction dict()\nLa fonction va convertir l’argument qui lui est passé en dictionnaire. Il s’agit donc d’une fonction de casting,\ndict()\ncomme , , etc. Toutefois, l’argument qui lui est passé doit avoir une forme particulière : un objet séquentiel\nint() str()\ncontenant d’autres objets séquentiels de deux éléments. Par exemple, une liste de listes de deux éléments :\n1 >>> liste_animaux = [[\"girafe\", 2], [\"singe\", 3]]\n2 >>> dict(liste_animaux)\n3\n{'girafe': 2, 'singe': 3}\nOu un tuple de tuples de deux éléments, ou encore une combinaison liste et tuple :\n1 >>> tuple_animaux = ((\"girafe\", 2), (\"singe\", 3))\n2\n>>> dict(tuple_animaux)\n3 {'girafe': 2, 'singe': 3}\n4\n>>>\n5 >>> dict([(\"girafe\", 2), (\"singe\", 3)])\n6\n{'girafe': 2, 'singe': 3}\nSi un des sous-éléments a plus de deux éléments (ou moins), Python renvoie une erreur :\n1\n>>> dict([(\"girafe\", 2), (\"singe\", 3, 4)])\n2 Traceback (most recent call last):\n3\nFile \"<stdin>\", line 1, in <module>\n4 ValueError: dictionary update sequence element #1 has length 3; 2 is required\nAttention\nUne manière intuitive utilise simplement des arguments par mot-clés, qui deviendront des clés sous forme de chaîne\nde caractères :\n1 >>> dict(un=1, deux=2, trois=3)\n2\n{'un': 1, 'deux': 2, 'trois': 3}\nNous vous déconseillons toutefois cette manière de faire, car on ne peut pas mettre d’arguments par mot-clé variables,\non doit les écrire explicitement.\nUne dernière manière puissante pour générer des dictionnaires combine les fonctions et . On se souvient\ndict() zip()\nque la fonction peut générer une liste de tuples :\nzip()\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 143\nChapitre 14. Conteneurs 14.3. Plus sur les tuples\n1\n>>> animaux = [\"poulain\", \"renard\", \"python\"]\n2 >>> couleurs = [\"alezan\", \"roux\", \"vert\"]\n3\n>>> list(zip(animaux, couleurs))\n4 [('poulain', 'alezan'), ('renard', 'roux'), ('python', 'vert')]\nSi on utilise l’objet zip avec la fonction , on obtient un dictionnaire.\ndict()\n1 >>> dict(zip(animaux, couleurs))\n2 {'poulain': 'alezan', 'renard': 'roux', 'python': 'vert'}\nAttention à ne passer que deux listes à la fonction , sinon Python renvoie une erreur :\nzip()\n1 >>> dict(zip([1, 2, 3], animaux, couleurs))\n2\nTraceback (most recent call last):\n3 File \"<stdin>\", line 1, in <module>\n4\nValueError: dictionary update sequence element #0 has length 3; 2 is required"
  },
  {
    "title": "Plus sur les tuples",
    "content": "Nous revenons sur les tuples, que nous avons défini dans le chapitre 8 Dictionnaires et tuples et que nous avons\ncroisé à de nombreuses reprises, notamment avec les fonctions. Les tuples sont des objets séquentiels correspondant aux\nlistes, donc ils sont itérables, ordonnés et indexables, mais ils sont toutefois non modifiables. On verra plus bas qu’ils\nsont hachables sous certaines conditions. L’intérêt des tuples par rapport aux listes réside dans leur immutabilité. Cela\naccélère considérablement la manière dont Python accède à chaque élément et ils prennent moins de place en mémoire.\nPar ailleurs, on ne risque pas de modifier un de ses éléments par mégarde.\n14.3.1 Immutabilité\nNous avions vu que les tuples étaient immuables :\n1 >>> tuple1 = (1, 2, 3)\n2 >>> tuple1[2] = 15\n3 Traceback (most recent call last):\n4\nFile \"<stdin>\", line 1, in <module>\n5 TypeError: 'tuple' object does not support item assignment\nCe message est similaire à celui que nous avions rencontré quand on essayait de modifier une chaîne de caractères\n(voir chapitre 11 Plus sur les chaînes de caractères). De manière générale, Python renverra un message\nTypeError: '\nlorsqu’on essaie de modifier un élément d’un objet non modifiable. Si\n[...]' does not support item assignment\nvous voulez ajouter un élément (ou le modifier), vous devez créer un nouveau tuple :\n1 >>> tuple1 = (1, 2, 3)\n2\n>>> tuple1\n3 (1, 2, 3)\n4\n>>> id(tuple1)\n5 139971081704464\n6\n>>> tuple1 = tuple1 + (2,)\n7 >>> tuple1\n8\n(1, 2, 3, 2)\n9 >>> id(tuple1)\n10 139971081700368\nLa fonction montre que le tuple créé ligne 6 est bien différent de celui créé ligne 4, bien qu’ils aient le même\nid()\nnom. Comme on a vu plus haut, ceci est dû à l’opérateur d’affectation utilisé ligne 6 ( ) qui\ntuple1 = tuple1 + (2,)\ncrée un nouvel objet distinct de celui de la ligne 1. Cet exemple montre que les tuples sont peu adaptés lorsqu’on a besoin\nd’ajouter, retirer, modifier des éléments. La création d’un nouveau tuple à chaque étape s’avère lourde et il n’y a aucune\nméthode pour faire cela, puisque les tuples sont non modifiables.\nConseil\nPour ce genre de tâche, les listes sont clairement mieux adaptées que les tuples.\n144 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.3. Plus sur les tuples Chapitre 14. Conteneurs\n14.3.2 Affectation multiple et fonctions\nDans le chapitre 8 Dictionnaires et tuples, nous avons abordé l’affectation multiple. Pour rappel, elle permet d’effectuer\nsur une même ligne plusieurs affectations en même temps, par exemple : . On a vu qu’il était possible\nx, y, z = 1, 2, 3\nde le faire également avec les listes : . Toutefois, cette syntaxe étant alourdie par la présence\n[x, y, z] = [1, 2, 3]\ndes crochets, on préfèrera toujours la première syntaxe avec les tuples sans parenthèses.\nConcernant les fonctions, nous avions croisé l’importance de l’affectation multiple dans le chapitre 10 lorsqu’une\nfonction renvoyait plusieurs valeurs :\n1 >>> def ma_fonction():\n2\n... return 3, 14\n3 ...\n4\n>>> x, y = ma_fonction()\n5 >>> print(x, y)\n6\n3 14\nLa syntaxe permet de récupérer les deux valeurs renvoyées par la fonction et de les affecter\nx, y = ma_fonction()\nà la volée dans deux variables différentes. Cela évite l’opération laborieuse de récupérer d’abord le tuple, puis de créer les\nvariables en utilisant l’indiçage :\n1\n>>> resultat = ma_fonction()\n2 >>> resultat\n3\n(3, 14)\n4 >>> x = resultat[0]\n5\n>>> y = resultat[1]\n6 >>> print(x, y)\n7\n3 14\nConseil\nLorsqu’une fonction renvoie plusieurs valeurs sous forme de tuple, privilégiez toujours la forme\nx, y = ma_fonction\n.\n()\n14.3.3 Affectation multiple et nom de variable\n_\nQuand une fonction renvoie plusieurs valeurs, mais que l’on ne souhaite pas les utiliser toutes dans la suite du code,\non peut utiliser le nom de variable (caractère underscore) pour indiquer que certaines valeurs ne nous intéressent pas :\n_\n1\n>>> def ma_fonction():\n2 ... return 1, 2, 3, 4\n3\n...\n4 >>> x, _, y, _ = ma_fonction()\n5\n>>> x\n6 1\n7\n>>> y\n8 3\nCela envoie le message à la personne qui lit le code « je ne m’intéresse pas aux valeurs récupérées dans les variables\n». Notez que l’on peut utiliser une ou plusieurs variables underscore(s). Dans l’exemple ci-dessus, la 2e et la 4e variable\n_\nrenvoyées par la fonction seront ignorées dans la suite du code. Cela présente le mérite d’éviter de polluer l’attention de\nla personne qui lit le code.\nRemarque\nDans l’interpréteur interactif, la variable a une signification différente. Elle prend automatiquement la dernière valeur\n_\naﬀichée :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 145\nChapitre 14. Conteneurs 14.3. Plus sur les tuples\n1\n>>> 3\n2 3\n3\n>>> _\n4 3\n5\n>>> \"mésange\"\n6 'mésange'\n7 >>> _\n8\n'mésange'\nAttention, ceci n’est vrai que dans l’interpréteur !\nRemarque\nLe caractère underscore ( ) est couramment utilisé dans les noms de variable pour séparer les mots et être explicite,\n_\npar exemple ou . On verra dans le chapitre 16 Bonnes pratiques en programmation\nseq_ADN liste_listes_residus\nPython que ce style de nommage est appelé snake_case. Toutefois, il faut éviter d’utiliser les underscores en début et/ou\nen fin de nom de variable (leading et trailing underscores en anglais), par exemple : , , , . On\n_var var_ __var __var__\nverra au chapitre 23 Avoir la classe avec les objets que ces underscores ont aussi une signification particulière.\n14.3.4 Tuples contenant des listes\nOn a vu que les tuples étaient non modifiables. Que se passe-t-il alors si on crée un tuple contenant des objets\nmodifiables comme des listes ? Examinons le code suivant :\n1\n>>> liste1 = [1, 2, 3]\n2 >>> tuple1 = (liste1, \"Plouf\")\n3 >>> tuple1\n4\n([1, 2, 3], 'Plouf')\n5 >>> liste1[0] = -15\n6\n>>> tuple1[0].append(-632)\n7 >>> tuple1\n8\n([-15, 2, 3, -632], 'Plouf')\nSi on modifie un élément de la liste (ligne 5) ou bien qu’on ajoute un élément à (ligne 6), Python\nliste1 tuple1[0]\ns’exécute et ne renvoie pas de message d’erreur. Or nous avions dit qu’un tuple était non modifiable… Comment cela\nest-il possible ? Commençons d’abord par regarder comment les objets sont agencés avec Python Tutor.\nFigure 14.1 – Tuple contenant une liste.\nLa liste pointe vers le même objet que l’élément du tuple d’indice 0. Comme pour la copie de liste (par\nliste1\nexemple ), ceci est attendu car, par défaut, Python crée une copie par référence (voir le chapitre\nliste_b = liste_a\n12 Plus sur les listes). Ainsi, qu’on raisonne en tant que premier élément du tuple ou bien en tant que liste , on\nliste1\npointe vers la même liste. Or, rappelez-vous, nous avons expliqué au début de ce chapitre que lorsqu’on modifiait un\n146 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.3. Plus sur les tuples Chapitre 14. Conteneurs\nélément d’une liste, celle-ci gardait le même identifiant. C’est toujours le cas ici, même si celle-ci se trouve dans un tuple.\nRegardons cela :\n1\n>>> liste1 = [1, 2, 3]\n2 >>> tuple1 = (liste1, \"Plouf\")\n3\n>>> tuple1\n4 ([1, 2, 3], 'Plouf')\n5\n>>> id(liste1)\n6 139971081980816\n7\n>>> id(tuple1[0])\n8 139971081980816\nNous confirmons ici le schéma de Python Tutor, c’est bien la même liste que l’on considère ou\nliste1 tuple1[0]\npuisqu’on a le même identifiant. Maintenant, on modifie cette liste via la variable ou :\nliste1 tuple1[0]\n1\n>>> liste1[2] = -15\n2 >>> tuple1[0].append(-632)\n3\n>>> tuple1\n4 ([1, 2, -15, -632], 'Plouf')\n5 >>> id(liste1)\n6\n139971081980816\n7 >>> id(tuple1[0])\n8\n139971081980816\nMalgré la modification de cette liste, l’identifiant n’a toujours pas changé puisque la fonction nous renvoie la\nid()\nmême valeur depuis le début. Même si la liste a été modifiée « de l’intérieur », Python considère que c’est toujours la\nmême liste, puisqu’elle n’a pas changé d’identifiant. Si au contraire on essaie de remplacer cette sous-liste par autre\nchose, Python renvoie une erreur :\n1 >>> tuple1[0] = \"Plif\"\n2\nTraceback (most recent call last):\n3 File \"<stdin>\", line 1, in <module>\n4\nTypeError: 'tuple' object does not support item assignment\nCette erreur s’explique par le fait que le nouvel objet n’a pas le même identifiant que la sous-liste initiale. En\n\"Plif\"\nfait, l’immutabilité selon Python signifie qu’un objet créé doit toujours garder le même identifiant. Cela est valable pour\ntout objet non modifiable, comme un élément d’un tuple, un caractère dans une chaîne de caractères, etc.\nConseil\nCette digression avait pour objectif de vous faire comprendre ce qu’il se passe lorsqu’on met une liste dans un tuple.\nToutefois, pouvoir modifier une liste en tant qu’élément d’un tuple va à l’encontre de l’intérêt d’un objet non modifiable.\nDans la mesure du possible, nous vous déconseillons de créer des listes dans des tuples afin d’éviter les déconvenues.\n14.3.5 Fonction tuple()\nNous avions vu également la fonction , qui permet de convertir un objet séquentiel en tuple (opération de\ntuple()\ncasting). Cela est possible seulement si l’objet passé en argument est itérable :\n1\n>>> tuple([1, 3])\n2 (1, 3)\n3\n>>> tuple(\"a\")\n4 ('a',)\n5\n>>> tuple(2)\n6 Traceback (most recent call last):\n7\nFile \"<stdin>\", line 1, in <module>\n8 TypeError: 'int' object is not iterable\n9\n>>> tuple(True)\n10 Traceback (most recent call last):\n11\nFile \"<stdin>\", line 1, in <module>\n12 TypeError: 'bool' object is not iterable\nBien sûr, un entier ou un booléen ne sont pas itérables.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 147\nChapitre 14. Conteneurs 14.4. Sets et frozensets\n14.3.6 Hachabilité des tuples\nLes tuples sont hachables s’ils ne contiennent que des éléments hachables. Si un tuple contient un ou plusieurs objet(s)\nnon hachable(s), comme une liste, il devient non hachable :\n1 >>> tuple1 = tuple(range(10))\n2 >>> tuple1\n3\n(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n4 >>> hash(tuple1)\n5\n-4181190870548101704\n6 >>> tuple2 = (\"Plouf\", 2, (1, 3))\n7\n>>> tuple2\n8 ('Plouf', 2, (1, 3))\n9\n>>> hash(tuple2)\n10 286288423668065022\n11\n>>> tuple3 = (1, (3, 4), \"Plaf\", [3, 4, 5])\n12 >>> tuple3\n13\n(1, (3, 4), 'Plaf', [3, 4, 5])\n14 >>> hash(tuple3)\n15 Traceback (most recent call last):\n16 File \"<stdin>\", line 1, in <module>\n17 TypeError: unhashable type: 'list'\nLes tuples et sont hachables car ils ne contiennent que des éléments hachables. Par contre,\ntuple1 tuple2 tuple3\nne l’est pas, car un de ses éléments est une liste.\nConseil\nMettre une ou plusieurs liste(s) dans un tuple le rend non hachable. Ceci le rend inutilisable comme clé de dictionnaire\nou, on le verra ci-après, comme élément d’un set ou d’un frozenset. Donc, à nouveau, ne mettez pas de listes dans vos\ntuples !"
  },
  {
    "title": "Sets et frozensets",
    "content": "14.4.1 Définition et propriétés\nLes objets de type set représentent un autre type de conteneur qui peut se révéler très pratique. Ils ont la particularité\nd’être modifiables, non hachables, non ordonnés, non indexables et de ne contenir qu’une seule copie maximum de chaque\nélément. Pour créer un nouveau set on peut utiliser les accolades :\n1\n>>> set1 = {4, 5, 5, 12}\n2 >>> set1\n3\n{12, 4, 5}\n4 >>> type(set1)\n5\n<class 'set'>\nRemarquez que la répétition du chiffre 5 dans la définition du set ligne 1 produit finalement un seul chiffre 5, car\nchaque élément ne peut être présent qu’une seule fois. Comme pour les dictionnaires (jusqu’à la version 3.6), les sets\nsont non ordonnés. La manière dont Python les aﬀiche n’a pas de sens en tant que tel et peut être différente de celle\nutilisée lors de leur création.\nLes sets ne peuvent contenir que des objets hachables. On a déjà eu le cas avec les clés de dictionnaire. Ceci optimise\nl’accès à chaque élément du set. Pour rappel, les objets hachables que nous connaissons sont les chaînes de caractères,\nles tuples, les entiers, les floats, les booléens et les frozensets (voir plus bas). Les objets non hachables que l’on connait\nsont les listes, les sets et les dictionnaires. Si on essaie tout de même de mettre une liste dans un set, Python renvoie\nune erreur :\n1\n>>> set1 = {3, 4, \"Plouf\", (1, 3)}\n2 >>> set1\n3\n{(1, 3), 3, 4, 'Plouf'}\n4 >>> set2 = {3.14, [1, 2]}\n5\nTraceback (most recent call last):\n6 File \"<stdin>\", line 1, in <module>\n7\nTypeError: unhashable type: 'list'\n148 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.4. Sets et frozensets Chapitre 14. Conteneurs\nÀ quoi différencie-t-on un set d’un dictionnaire alors que les deux utilisent des accolades ? Le set sera défini seulement\npar des valeurs alors que le dictionnaire aura toujours des couples clé/valeur\n{valeur_1, valeur_2, ...} {clé_1:\n.\nvaleur_1, clé_2: valeur_2, ...}\nLa fonction interne à Python convertit un objet itérable passé en argument en un nouveau set (opération de\nset()\ncasting) :\n1\n>>> set([1, 2, 4, 1])\n2 {1, 2, 4}\n3\n>>> set((2, 2, 2, 1))\n4 {1, 2}\n5\n>>> set(range(5))\n6 {0, 1, 2, 3, 4}\n7 >>> set({\"clé_1\": 1, \"clé_2\": 2})\n8\n{'clé_1', 'clé_2'}\n9 >>> set([\"ti\", \"to\", \"to\"])\n10\n{'ti', 'to'}\n11 >>> set(\"Maître Corbeau et Maître Renard\")\n12\n{'e', 'd', 'M', 'r', 'n', 't', 'a', 'C', 'î', ' ', 'o', 'u', 'R', 'b'}\nNous avons dit plus haut que les sets ne sont ni ordonnés ni indexables, il est donc impossible de récupérer un élément\npar sa position. Il est également impossible de modifier un de ses éléments par l’indexation.\n1 >>> set1 = set([1, 2, 4, 1])\n2\n>>> set1[1]\n3 Traceback (most recent call last):\n4 File \"<stdin>\", line 1, in <module>\n5 TypeError: 'set' object is not subscriptable\n6 >>> set1[1] = 5\n7\nTraceback (most recent call last):\n8 File \"<stdin>\", line 1, in <module>\n9\nTypeError: 'set' object does not support item assignment\nPar contre, les sets sont itérables :\n1\n>>> for element in set1:\n2 ... print(element)\n3\n...\n4 1\n5\n2\n6 4\nLes sets ne peuvent être modifiés que par des méthodes spécifiques :\n1\n>>> set1 = set(range(5))\n2 >>> set1\n3\n{0, 1, 2, 3, 4}\n4 >>> set1.add(4)\n5\n>>> set1\n6 {0, 1, 2, 3, 4}\n7\n>>> set1.add(472)\n8 >>> set1\n9\n{0, 1, 2, 3, 4, 472}\n10 >>> set1.discard(0)\n11 >>> set1\n12 {1, 2, 3, 4, 472}\nLa méthode ajoute au set l’élément passé en argument. Toutefois, si l’élément est déjà présent dans le set,\n.add()\nil n’est pas ajouté puisqu’on a au plus une copie de chaque élément. La méthode retire du set l’élément\n.discard()\npassé en argument. Si l’élément n’est pas présent dans le set, il ne se passe rien, le set reste intact. Comme les sets ne\nsont pas ordonnés ni indexables, il n’y a pas de méthode pour insérer un élément à une position précise, contrairement\naux listes. Dernier point sur ces méthodes, elles modifient le set sur place (in place, en anglais) et ne renvoient rien, à\nl’instar des méthodes des listes ( , , etc.).\n.append() .remove()\nEnfin, les sets ne supportent pas les opérateurs et .\n+ *\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 149\nChapitre 14. Conteneurs 14.4. Sets et frozensets\n14.4.2 Utilité\nLes conteneurs de type set sont très utiles pour rechercher les éléments uniques d’une suite d’éléments. Cela revient\nà éliminer tous les doublons. Par exemple :\n1 >>> import random\n2\n>>> liste1 = [random.randint(0, 9) for i in range(10)]\n3 >>> liste1\n4\n[7, 9, 6, 6, 7, 3, 8, 5, 6, 7]\n5 >>> set(liste1)\n6\n{3, 5, 6, 7, 8, 9}\nOn peut bien sûr transformer dans l’autre sens un set en liste. Cela permet par exemple d’éliminer les doublons de la\nliste initiale, tout en récupérant une liste à la fin :\n1\n>>> list(set([7, 9, 6, 6, 7, 3, 8, 5, 6, 7]))\n2 [3, 5, 6, 7, 8, 9]\nOn peut faire des choses très puissantes. Par exemple, un compteur de lettres en combinaison avec une liste de\ncompréhension, le tout en une ligne !\n1\n>>> seq = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\"\n2 >>> set(seq)\n3\n{'c', 'g', 't', 'a'}\n4 >>> [(base, seq.count(base)) for base in set(seq)]\n5 [('c', 15), ('g', 10), ('t', 11), ('a', 10)]\nLes sets permettent aussi l’évaluation d’union ou d’intersection mathématiques en conjonction avec les opérateurs,\nrespectivement et :\n| &\n1\n>>> liste1 = [3, 3, 5, 1, 3, 4, 1, 1, 4, 4]\n2 >>> liste2 = [3, 0, 5, 3, 3, 1, 1, 1, 2, 2]\n3\n>>> set(liste1) | set(liste2)\n4 {0, 1, 2, 3, 4, 5}\n5\n>>> set(liste1) & set(liste2)\n6 {1, 3, 5}\nNotez qu’il existe les méthodes et permettant de réaliser ces opérations d’union et\n.union() .intersection\nd’intersection :\n1 >>> set1 = {1, 3, 4, 5}\n2\n>>> set2 = {0, 1, 2, 3, 5}\n3 >>> set1.union(set2)\n4\n{0, 1, 2, 3, 4, 5}\n5 >>> set1.intersection(set2)\n6\n{1, 3, 5}\nL’instruction renvoie sous la forme d’un nouveau set les éléments de qui ne sont\nset1.difference(set2) set1\npas dans . Et inversement pour :\nset2 set2.difference(set1)\n1\n>>> set1.difference(set2)\n2 {4}\n3\n>>> set2.difference(set1)\n4 {0, 2}\nEnfin, deux autres méthodes sont très utiles :\n150 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.5. Récapitulation des propriétés des conteneurs Chapitre 14. Conteneurs\n1\n>>> set1 = set(range(10))\n2 >>> set2 = set(range(3, 7))\n3\n>>> set3 = set(range(15, 17))\n4 >>> set1\n5\n{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n6 >>> set2\n7 {3, 4, 5, 6}\n8\n>>> set3\n9 {16, 15}\n10\n>>> set2.issubset(set1)\n11 True\n12\n>>> set3.isdisjoint(set1)\n13 True\nLa méthode indique si un set est inclus dans un autre set. La méthode indique si un\n.issubset() isdisjoint()\nset est disjoint d’un autre set, c’est-à-dire, s’ils n’ont aucun élément en commun indiquant que leur intersection est nulle.\nIl existe de nombreuses autres méthodes que nous n’abordons pas ici, mais qui peuvent être consultées sur la docu-\n4\nmentation oﬀicielle de Python .\n14.4.3 Frozensets\nLes frozensets sont des sets non modifiables et hachables. Ainsi, un set peut contenir des frozensets mais pas l’inverse.\nÀ quoi servent-ils ? Comme la différence entre tuple et liste, l’immutabilité des frozensets donne l’assurance de ne pas\npouvoir les modifier par erreur. Pour créer un frozenset on utilise la fonction interne , qui prend en argument\nfrozenset()\nun objet itérable et le convertit (opération de casting) :\n1 >>> frozen1 = frozenset([3, 3, 5, 1, 3, 4, 1, 1, 4, 4])\n2\n>>> frozen2 = frozenset([3, 0, 5, 3, 3, 1, 1, 1, 2, 2])\n3 >>> frozen1\n4\nfrozenset({1, 3, 4, 5})\n5 >>> frozen2\n6\nfrozenset({0, 1, 2, 3, 5})\n7 >>> frozen1.add(5)\n8\nTraceback (most recent call last):\n9 File \"<stdin>\", line 1, in <module>\n10 AttributeError: 'frozenset' object has no attribute 'add'\n11\n>>> frozen1.union(frozen2)\n12 frozenset({0, 1, 2, 3, 4, 5})\n13\n>>> frozen1.intersection(frozen2)\n14 frozenset({1, 3, 5})\nLes frozensets ne possèdent bien sûr pas les méthodes de modification des sets ( , , etc.) puisqu’ils\n.add() .discard()\nsont non modifiables. Par contre, ils possèdent toutes les méthodes de comparaisons de sets ( ,\n.union() .intersection\n, etc.).\n()\nConseil\n5 6\nPour aller plus loin sur les sets et les frozensets, voici deux articles sur les sites programiz et towardsdatascience ."
  },
  {
    "title": "Récapitulation des propriétés des conteneurs",
    "content": "Après ce tour d’horizon des différents conteneurs, voici des tableaux qui résument leurs propriétés. La mention «\nin\net » indique que l’on peut tester l’appartenance d’un élément à un conteneur avec l’opérateur , et que l’on peut\nlen() in\nconnaître le nombre d’éléments du conteneur avec la fonction . Les mentions « index. » et « modif. » indiquent\nlen()\nrespectivement « indexable » et « modifiable ».\n14.5.1 Objets séquentiels\n4. https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset\n5.\nhttps://www.programiz.com/python-programming/set\n6. https://towardsdatascience.com/python-sets-and-set-theory-2ace093d1607\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 151\nChapitre 14. Conteneurs 14.6. Dictionnaires et sets de compréhension\nConteneur et itérable ordonné index. modif. hachable\nin len()\nliste oui oui oui oui oui non\nchaîne de caractères oui oui oui oui non oui\nrange oui oui oui oui non oui\n∗\ntuple oui oui oui oui non oui\n∗\ns’il ne contient que des objets hachables\n14.5.2 Objets de mapping\nConteneur et itérable ordonné index. modif. hachable\nin len()\n∗\ndictionnaire oui oui sur les clés oui non oui non\n∗\nà partir de Python 3.7 uniquement\n14.5.3 Objets sets\nConteneur et itérable ordonné index. modif. hachable\nin len()\nsets oui oui non non oui non\nfrozensets oui oui non non non oui\n14.5.4 Types de base\nIl est aussi intéressant de comparer ces propriétés avec celles des types numériques de base qui ne sont pas des\nconteneurs.\nObjet numérique et itérable ordonné index. modif. hachable\nin len()\nentier non non non non non oui\nfloat non non non non non oui\nbooléen non non non non non oui\n14.5.5 Copie de conteneurs\nUn dernier point qu’il peut être utile de mentionner concerne la copie de conteneurs. On avait vu dans le chapitre\n12 Plus sur les listes que la copie de listes se fait par référence. Cela est un mécanisme général pour tous les types de\nconteneurs, sauf pour les chaînes de caractères. Python Tutor nous permet de visualiser cela (Figure 14.2).\nAinsi, il faut toujours faire attention quand on fait une copie d’un conteneur modfiable (liste, dictionnaire, set, etc.).\nOn verra que Python se comporte de la même manière avec les objets arrays (chapitre 20 module Numpy) ou Dataframes\n(chapitre 22 Module pandas), car on peut les considérer également comme des conteneurs."
  },
  {
    "title": "Dictionnaires et sets de compréhension",
    "content": "Nous avons abordé les listes de compréhension dans le chapitre 12 Plus sur les listes. Il est également possible de\ngénérer des dictionnaires de compréhension :\n1\n>>> dico = {\"a\": 10, \"g\": 10, \"t\": 11, \"c\": 15}\n2 >>> dico.items()\n3\ndict_items([('a', 10), ('g', 10), ('t', 11), ('c', 15)])\n4 >>> {key:val*2 for key, val in dico.items()}\n5\n{'a': 20, 'g': 20, 't': 22, 'c': 30}\n6 >>>\n7\n>>> animaux = ((\"singe\", 3), (\"girafe\", 4), (\"rhinocéros\", 2))\n8 >>> {animal:nombre for animal, nombre in animaux}\n9\n{'singe': 3, 'girafe': 4, 'rhinocéros': 2}\n152 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.7. Module collections Chapitre 14. Conteneurs\nFigure 14.2 – Copie de conteneurs.\nLa méthode vue dans le chapitre 8 Dictionnaires et tuples est particulièrement bien adaptée pour créer un\n.items()\ndictionnaire de compréhension, car elle permet d’itérer en même temps sur les clés et valeurs d’un dictionnaire.\nAvec un dictionnaire de compréhension, on peut rapidement compter le nombre de chaque base dans une séquence\nd’ADN :\n1 >>> sequence = \"atctcgatcgatcgcgctagctagctcgccatacgtacgactacgt\"\n2\n>>> {base:seq.count(base) for base in set(sequence)}\n3 {'a': 10, 'g': 10, 't': 11, 'c': 15}\nDe manière générale, tout objet sur lequel on peut faire une double itération du type est\nfor var1, var2 in obj\nutilisable pour créer un dictionnaire de compréhension. Si vous souhaitez aller plus loin, vous pouvez consulter cet article\n7\nsur le site Datacamp .\nIl est également possible de générer des sets de compréhension sur le même modèle que les listes de compréhension :\n1\n>>> {i for i in range(10)}\n2 {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n3\n>>> {i**2 for i in range(10)}\n4 {0, 1, 64, 4, 36, 9, 16, 49, 81, 25}\n5\n>>>\n6 >>> animaux = ((\"singe\", 3), (\"girafe\", 4), (\"rhinocéros\", 2))\n7\n>>> {ani for ani, _ in animaux}\n8 {'girafe', 'singe', 'rhinocéros'}"
  },
  {
    "title": "Module collections",
    "content": "8\nLe module collections contient d’autres types de conteneurs qui peuvent se révéler utiles, c’est une véritable mine\nd’or ! Nous n’aborderons pas tous ces objets ici, mais nous pouvons citer tout de même certains d’entre eux si vous\nsouhaitez aller un peu plus loin :\n• 9\nLes dictionnaires ordonnés , qui se comportent comme les dictionnaires classiques, mais qui sont ordonnés, c’est-à-\ndire que si on les aﬀiche ou on itère dessus, l’ordre sera le même que celui utilisé pour sa création. Avant la version\n7. https://www.datacamp.com/community/tutorials/python-dictionary-comprehension\n8.\nhttps://docs.python.org/fr/3/library/collections.html\n9. https://docs.python.org/fr/3/library/collections.html#collections.OrderedDict\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 153\nChapitre 14. Conteneurs 14.8. Exercices\n3.6 de Python, ces dictionnaires ordonnés avaient un intérêt, car l’ordre des dictionnaires normaux était arbitraire.\nDésormais, les dictionnaires normaux se comportent presque en tout point comme les dictionnaires ordonnés.\n• 10\nLes defaultdicts , qui génèrent des valeurs par défaut quand on demande une clé qui n’existe pas (cela évite que\nPython génère une erreur).\n• 11\nLes compteurs , dont un exemple est présenté ci-dessous.\n•\n12\nLes namedtuples , que nous évoquerons au chapitre 24 Avoir plus la classe avec les objets (en ligne).\nL’objet est particulièrement intéressant et simple à utiliser. Il crée des compteurs à partir\ncollection.Counter()\nd’objets itérables, par exemple :\n1 >>> import collections\n2\n>>> compo_seq = collections.Counter(\"aatctccgatcgatcgatcgatgatc\")\n3 >>> compo_seq\n4\nCounter({'a': 7, 't': 7, 'c': 7, 'g': 5})\n5 >>> type(compo_seq)\n6\n<class 'collections.Counter'>\n7 >>> compo_seq[\"a\"]\n8\n7\n9 >>> compo_seq[\"n\"]\n10 0\nDans cet exemple, Python a automatiquement compté chaque caractère , , et de la chaîne de caractères passée\na t g c\nen argument. Cela crée un objet de type qui se comporte ensuite comme un dictionnaire, à une exception près :\nCounter\nsi on appelle une clé qui n’existe pas dans l’itérable initiale (comme le ci-dessus), la valeur renvoyée est 0.\nn"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n14.8.1 Séquence peptidique et dictionnaire\nLes numéros d’acides aminés commencent rarement à 1 dans les fichiers PDB. Créez un dictionnaire où chaque clé\nest un numéro de résidu de 3 à 9, et chaque valeur est un acide aminé de la séquence peptidique suivante : .\nSEQPEPT\nUtilisez pour cela les fonctions et .\ndict() zip()\n14.8.2 Composition en acides aminés\nEn utilisant un set et la méthode des chaînes de caractères, déterminez le nombre d’occurrences de chaque\n.count()\nacide aminé dans la séquence\n.\nAGWPSGGASAGLAILWGASAIMPGALW\n14.8.3 Mots de deux et trois lettres dans une séquence d’ADN\nCréez une fonction , qui prend comme argument une séquence sous la forme d’une\ncompte_mots_2_lettres()\nchaîne de caractères et qui renvoie tous les mots de deux lettres qui existent dans la séquence sous la forme d’un\ndictionnaire. Par exemple pour la séquence , le dictionnaire renvoyée serait :\nACCTAGCCCTA\n{'AC': 1, 'CC': 3, 'CT': 2, 'TA': 2, 'AG': 1, 'GC': 1}\nCréez une nouvelle fonction , qui a un comportement similaire à\ncompte_mots_3_lettres() compte_mots_2_lettres\n, mais avec des mots de trois lettres.\n()\nUtilisez ces fonctions pour aﬀicher les mots de deux et trois lettres et leurs occurrences trouvés dans la séquence\nd’ADN :\nACCTAGCCATGTAGAATCGCCTAGGCTTTAGCTAGCTCTAGCTAGCTG\nVoici un exemple de sortie attendue :\n10. https://docs.python.org/fr/3/library/collections.html#collections.defaultdict\n11.\nhttps://docs.python.org/fr/3/library/collections.html#collections.Counter\n12. https://docs.python.org/fr/3/library/collections.html#collections.namedtuple\n154 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.8. Exercices Chapitre 14. Conteneurs\nMots de 2 lettres\nAC : 1\nCC : 3\nCT : 8\n[...]\nMots de 3 lettres\nACC : 1\nCCT : 2\nCTA : 5\n[...]\n14.8.4 Mots de deux lettres dans la séquence du chromosome I de Saccharomyces cerevi-\nsiae\nCréez une fonction qui prend comme argument le nom d’un fichier FASTA sous la forme d’une chaîne\nlit_fasta()\nde caractères, lit la séquence dans le fichier FASTA et la renvoie sous la forme d’une chaîne de caractères. Inspirez-vous\nd’un exercice similaire du chapitre 10 Plus sur les chaînes de caractères.\nUtilisez cette fonction et la fonction de l’exercice précédent pour extraire les mots de\ncompte_mots_2_lettres()\ndeux lettres et leurs occurrences dans la séquence du chromosome I de la levure du boulanger Saccharomyces cerevisiae\n13\n(fichier ).\nNC_001133.fna\nLe génome complet est fourni au format FASTA. Vous trouverez des explications sur ce format et des exemples de\ncode dans l’annexe A Quelques formats de données en biologie.\n14.8.5 Mots de n lettres dans un fichier FASTA\nCréez un script qui prend comme arguments le nom d’un fichier FASTA suivi d’un entier compris\nextract-words.py\nentre 1 et 4. Ce script doit extraire du fichier FASTA tous les mots et leurs occurrences, en fonction du nombre de lettres\npassé en option.\nUtilisez pour ce script la fonction de l’exercice précédent. Créez également la fonction\nlit_fasta() compte_mots_n_lettres\nqui prend comme argument une séquence sous la forme d’une chaîne de caractères et le nombre de lettres des mots\n()\nsous la forme d’un entier.\nTestez ce script avec :\n•\n14\nla séquence du chromosome I de la levure du boulanger Saccharomyces cerevisiae (fichier ) ;\nNC_001133.fna\n• 15\nle génome de la bactérie Escherichia coli (fichier ).\nNC_000913.fna\nLes deux fichiers sont au format FASTA.\nCette méthode vous paraît-elle eﬀicace sur un génome assez gros comme celui d’Escherichia coli ?\n14.8.6 Atomes carbone alpha d’un fichier PDB\n16 17\nTéléchargez le fichier , qui correspond à la structure tridimensionnelle de la protéine barstar sur le site\n1bta.pdb\nde la Protein Data Bank (PDB).\nCréez la fonction , qui prend en argument le nom d’un fichier PDB (sous la forme d’une chaîne\ntrouve_calpha()\nde caractères), qui sélectionne uniquement les lignes contenant des carbones alpha et qui les renvoie sous la forme d’une\nliste de dictionnaires. Chaque dictionnaire contient quatre clés :\n•\nle numéro du résidu ( ) avec une valeur entière,\nresid\n•\nla coordonnée atomique x ( ) avec une valeur float,\nx\n•\nla coordonnée atomique y ( ) avec une valeur float,\ny\n•\nla coordonnée atomique z ( ) avec une valeur float.\nz\nUtilisez la fonction pour aﬀicher à l’écran le nombre total de carbones alpha de la barstar ainsi\ntrouve_calpha()\nque les coordonnées atomiques des carbones alpha des deux premiers résidus (acides aminés).\nConseil\n13. https://python.sdv.u-paris.fr/data-files/NC_001133.fna\n14.\nhttps://python.sdv.u-paris.fr/data-files/NC_001133.fna\n15. https://python.sdv.u-paris.fr/data-files/NC_000913.fna\n16.\nhttps://files.rcsb.org/download/1BTA.pdb\n17. http://www.rcsb.org/pdb/explore.do?structureId=1BTA\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 155\nChapitre 14. Conteneurs 14.8. Exercices\nVous trouverez des explications sur le format PDB et des exemples de code pour lire ce type de fichier en Python\ndans l’annexe A Quelques formats de données en biologie.\n14.8.7 Barycentre d’une protéine (exercice +++)\n18 19\nTéléchargez le fichier qui correspond à la structure tridimensionnelle de la protéine barstar sur le site\n1bta.pdb\nde la Protein Data Bank (PDB).\nUn carbone alpha est présent dans chaque résidu (acide aminé) d’une protéine. On peut obtenir une bonne approxi-\nmation du barycentre d’une protéine en calculant le barycentre de ses carbones alpha.\nLe barycentre G de coordonnées (G , G , G ) est obtenu à partir des n carbones alpha (CA) de coordonnées (CA ,\nx y z x\n, ) avec :\nCA CA\ny z\nn\n1"
  },
  {
    "title": "∑",
    "content": "G = CA\n,\nx i x\nn\ni=1\nn\n1"
  },
  {
    "title": "∑",
    "content": "G = CA\ny i,y\nn\ni=1\nn\n1"
  },
  {
    "title": "∑",
    "content": "=\nG CA\nz i,z\nn\ni=1\nCréez une fonction , qui prend comme argument une liste de dictionnaires dont les clés\ncalcule_barycentre()\n( , , et ) sont celles de l’exercice précédent et qui renvoie les coordonnées du barycentre sous la forme d’une\nresid x y z\nliste de floats.\nUtilisez la fonction de l’exercice précédent et la fonction\ntrouve_calpha()\npour aﬀicher, avec deux chiffres significatifs, les coordonnées du barycentre des carbones alpha\ncalcule_barycentre()\nde la barstar.\n14.8.8 Kinases et protéines humaines\nNous avons extrait de la base de données de protéines UniProt la liste des protéines humaines (dans le fichier\n20 21\n) et la liste des kinases (dans le fichier ), qui sont une famille de\nhuman_proteins.txt kinases_proteins.txt\n22\nprotéines enzymatiques impliquées dans la phosphorylation d’autres protéines.\nChaque fichier contient un identifiant de protéine par ligne. Voici un exemple pour le fichier :\nhuman_proteins.txt\nA0A087X1C5\nA0A0B4J2F0\nA0A0B4J2F2\nA0A0C5B5G6\nA0A0K2S4Q6\nA0A0U1RRE5\nA0A1B0GTW7\nA0AV02\nA0AV96\n[...]\nL’objectif de cet exercice est de déterminer quelles sont les protéines humaines qui sont des kinases. Chaque liste de\nprotéines contenant plusieurs milliers d’éléments, il n’est pas possible de la faire à la main. Vous aller utiliser Python et\nles sets pour cela.\n1. Créez un script .\ncompare_proteins.py\n2. Dans ce script, créez une fonction qui prend en argument le nom d’un fichier de protéines\nread_protein_file()\nsous la forme d’une chaîne de caractères et qui renvoie un set contenant la liste des identifiants des protéines\ncontenues dans le fichier passé en argument.\n18. https://files.rcsb.org/download/1BTA.pdb\n19.\nhttp://www.rcsb.org/pdb/explore.do?structureId=1BTA\n20. https://python.sdv.u-paris.fr/data-files/human_proteins.txt\n21.\nhttps://python.sdv.u-paris.fr/data-files/kinase_proteins.txt\n22. https://fr.wikipedia.org/wiki/Kinase\n156 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n14.8. Exercices Chapitre 14. Conteneurs\n3. Aﬀichez ensuite le nombre de protéines listées dans chaque fichier.\n4. En utilisant uniquement des opérations sur les sets, déterminez et aﬀichez :\n•\nle nombre de protéines humaines qui sont des kinases ;\n•\nle nombre de protéines humaines qui ne sont pas des kinases ;\n•\nle nombre de kinases qui ne sont pas des protéines humaines.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 157"
  },
  {
    "title": "Pourquoi créer ses propres modules ?",
    "content": "Dans le chapitre 9 Modules, nous avons découvert quelques modules Python comme random, math, etc. Nous avons\nvu par ailleurs dans les chapitres 10 Fonctions et 13 Plus sur les fonctions que les fonctions sont utiles pour réutiliser\nune fraction de code plusieurs fois au sein d’un même programme, sans avoir à dupliquer ce code. On peut imaginer\nqu’une fonction utile pourrait être judicieusement réutilisée dans un autre programme Python. C’est justement l’intérêt\nde créer un module. On y regroupe un ensemble de fonctions que l’on peut être amené à utiliser souvent. En général, les\nmodules sont regroupés autour d’un thème précis. Par exemple, on pourrait concevoir un module d’analyse de séquences\nbiologiques ou encore de gestion de fichiers PDB."
  },
  {
    "title": "Création d’un module",
    "content": "En Python, la création d’un module est très simple. Il suﬀit d’écrire un ensemble de fonctions (et éventuellement de\nconstantes) dans un fichier, puis d’enregistrer ce dernier avec une extension (comme n’importe quel script Python).\n.py\nÀ titre d’exemple, nous allons créer un module simple que nous enregistrerons sous le nom :\nmessage.py\n1 \"\"\"Module inutile qui affiche des messages.\"\"\"\n2\n3 DATE = \"2024-01-05\"\n4\n5\n6 def bonjour(nom):\n7\n\"\"\"Dit Bonjour.\"\"\"\n8 return f\"Bonjour {nom}\"\n9\n10\n11\ndef ciao(nom):\n12 \"\"\"Dit Ciao.\"\"\"\n13\nreturn f\"Ciao {nom}\"\n14\n15\n16 def hello(nom):\n17\n\"\"\"Dit Hello.\"\"\"\n18 return f\"Hello {nom}\"\nLes chaînes de caractères entre triple guillemets en tête du module et en tête de chaque fonction sont facultatives\nmais elles jouent néanmoins un rôle essentiel dans la documentation du code.\n158\n15.3. Utilisation de son propre module Chapitre 15. Création de modules\nRemarque\nUne constante est, par définition, une variable dont la valeur n’est pas modifiée. Par convention, en Python, le nom\ndes constantes est écrit en majuscules (comme dans notre exemple).\nDATE"
  },
  {
    "title": "Utilisation de son propre module",
    "content": "Pour appeler une fonction ou une variable de ce module, il faut que le fichier soit dans le répertoire\nmessage.py\ncourant (dans lequel on travaille) ou bien dans un répertoire listé par la variable d’environnement de votre\nPYTHONPATH\nsystème d’exploitation. Ensuite, il suﬀit d’importer le module et toutes ses fonctions (et constantes) vous sont alors\naccessibles.\nRemarque\nAvec Mac OS X et Linux, il faut taper la commande suivante depuis un shell Bash pour modifier la variable d’envi-\nronnement :\nPYTHONPATH\nexport PYTHONPATH=$PYTHONPATH:/chemin/vers/mon/super/module\nAvec Windows, mais depuis un shell PowerShell, il faut taper la commande suivante :\n$env:PYTHONPATH += \";C:\\chemin\\vers\\mon\\super\\module\"\nUne fois cette manipulation effectuée, vous pouvez contrôler que le chemin vers le répertoire contenant vos modules\na bien été ajouté à la variable d’environnement :\nPYTHONPATH\n•\nsous Mac OS X et Linux :\necho $PYTHONPATH\n•\nsous Windows :\necho $env:PYTHONPATH\nLe chargement du module se fait avec la commande . Notez que le fichier est bien enregistré avec\nimport message\nune extension , pourtant on ne la précise pas lorsqu’on importe le module. Ensuite, on peut utiliser les fonctions\n.py\ncomme avec un module classique :\n1\n>>> import message\n2 >>> message.hello(\"Joe\")\n3 'Hello Joe'\n4 >>> message.ciao(\"Bill\")\n5 'Ciao Bill'\n6\n>>> message.bonjour(\"Monsieur\")\n7 'Bonjour Monsieur'\n8\n>>> message.DATE\n9 '2024-01-05'\nRemarque\nLa première fois qu’un module est importé, Python crée un répertoire nommé contenant un fichier\n__pycache__\n1\navec une extension qui contient le bytecode , c’est-à-dire le code précompilé du module.\n.pyc"
  },
  {
    "title": "Les docstrings",
    "content": "Lorsqu’on écrit un module, il est important de créer de la documentation pour expliquer ce que fait le module et\ncomment utiliser chaque fonction. Les chaînes de caractères entre triple guillemets, situées en début du module et de\nchaque fonction, sont là pour cela : on les appelle docstrings (« chaînes de documentation » en français). Les docstrings\nseront détaillées dans le chapitre 16 Bonnes pratiques en programmation Python.\nLes docstrings permettent notamment de fournir de l’aide lorsqu’on invoque la commande :\nhelp()\n1. https://docs.python.org/fr/3/glossary.html#term-bytecode\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 159\nChapitre 15. Création de modules 15.5. Visibilité des fonctions dans un module\n1\n>>> import message\n2 >>> help(message)\n3\n4 Help on module message:\n5\n6 NAME\n7 message - Module inutile qui affiche des messages.\n8\n9 FUNCTIONS\n10\nbonjour(nom)\n11 Dit Bonjour.\n12\n13 ciao(nom)\n14\nDit Ciao.\n15\n16\nhello(nom)\n17 Dit Hello.\n18\n19 DATA\n20 DATE = '2024-01-05'\n21\n22 FILE\n23\n/home/pierre/message.py\nRemarque\nPour quitter l’aide, pressez la touche .\nQ\nVous remarquez que Python a généré automatiquement cette page d’aide, tout comme il est capable de le faire pour\nles modules internes à Python (random, math, etc.) et ce grâce aux docstrings. Notez que l’on peut aussi appeler l’aide\npour une seule fonction :\n1 >>> help(message.ciao)\n2\n3 Help on function ciao in module message:\n4\n5\nciao(nom)\n6 Dit Ciao.\nEn résumé, les docstrings sont destinés aux utilisateurs du module. Leur but est différent des commentaires qui, eux,\nsont destinés à celui qui lit le code (pour en comprendre les subtilités). Une bonne docstring de fonction doit contenir\ntout ce dont un utilisateur a besoin pour utiliser cette fonction. Une liste minimale et non exhaustive serait :\n•\nce que fait la fonction,\n•\nce qu’elle prend en argument,\n•\nce qu’elle renvoie.\nPour en savoir plus sur les docstrings et comment les écrire, nous vous recommandons de lire le chapitre 16 Bonnes\npratiques en programmation Python."
  },
  {
    "title": "Visibilité des fonctions dans un module",
    "content": "La visibilité des fonctions au sein des modules suit des règles simples :\n•\nLes fonctions dans un même module peuvent s’appeler les unes les autres.\n•\nLes fonctions dans un module peuvent appeler des fonctions situées dans un autre module s’il a été préalablement\nimporté. Par exemple, si la commande est utilisée dans un module, il est possible d’appeler\nimport autremodule\nune fonction avec .\nautremodule.fonction()\nToutes ces règles viennent de la manière dont Python gère les espaces de noms. De plus amples explications sont\ndonnées sur ce concept dans le chapitre 24 Avoir plus la classe avec les objets (en ligne).\n160 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n15.6. Module ou script ? Chapitre 15. Création de modules"
  },
  {
    "title": "Module ou script ?",
    "content": "Vous avez remarqué que notre module ne contient que des fonctions et une constante. Si on l’exécutait\nmessage\ncomme un script classique, cela n’aﬀicherait rien :\n$ python message.py\n$\nCela s’explique par l’absence de programme principal, c’est-à-dire de lignes de code que l’interpréteur exécute lorsqu’on\nlance le script.\nÀ l’inverse, que se passe-t-il si on importe un script en tant que module alors qu’il contient un programme principal\navec des lignes de code ? Prenons par exemple le script suivant :\nmessage2.py\n1 \"\"\"Script de test.\"\"\"\n2\n3\n4\ndef bonjour(nom):\n5 \"\"\"Dit Bonjour.\"\"\"\n6\nreturn f\"Bonjour {nom}\"\n7\n8\n9 # Programme principal.\n10\nprint(bonjour(\"Joe\"))\nSi on l’importe dans l’interpréteur, on obtient :\n1\n>>> import message2\n2 Bonjour Joe\nCeci n’est pas le comportement voulu pour un module, car on n’attend pas d’aﬀichage particulier lors de son charge-\nment. Par exemple la commande n’aﬀiche rien dans l’interpréteur.\nimport math\nAfin de pouvoir utiliser un code Python en tant que module ou en tant que script, nous vous conseillons la structure\nsuivante :\n1 \"\"\"Script de test.\"\"\"\n2\n3\n4\ndef bonjour(nom):\n5 \"\"\"Dit Bonjour.\"\"\"\n6\nreturn f\"Bonjour {nom}\"\n7\n8\n9 if __name__ == \"__main__\":\n10 print(bonjour(\"Joe\"))\nÀ la ligne 9, l’instruction indique à Python :\nif __name__ == \"__main__\":\n•\nSi le programme est exécuté en tant que script dans un shell, le résultat du test sera alors\nmessage2.py if True\net le bloc d’instructions correspondant (ligne 10) sera exécuté :\n$ python message2.py\nBonjour Joe\n•\nSi le programme est importé en tant que module, le résultat du test sera alors et le bloc\nmessage2.py if False\nd’instructions correspondant ne sera pas exécuté :\n1 >>> import message2\n2\n>>>\nCe comportement est possible grâce à la gestion des espaces de noms par Python (pour plus de détail, consultez le\nchapitre 24 Avoir plus la classe avec les objets (en ligne)). Au delà de la commodité de pouvoir utiliser votre script en\ntant que programme ou en tant que module, cela présente l’avantage de signaler clairement où se situe le programme\nprincipal quand on lit le code.\nConseil\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 161\nChapitre 15. Création de modules 15.7. Exercice\nAinsi, au lieu d’ajouter le commentaire :\n# Programme principal.\ncomme nous vous l’avions suggéré dans les chapitres 10 Fonctions et 13 Plus sur les fonctions, nous vous recomman-\ndons désormais d’utiliser la ligne :\nif __name__ == \"__main__\":"
  },
  {
    "title": "Exercice",
    "content": "Conseil\nPour cet exercice, créez un script puis exécutez-le dans un shell.\n15.7.1 Module ADN\nDans le script , construisez un module qui va contenir les fonctions et constantes suivantes.\nadn.py\n•\nFonction : prend en argument un nom de fichier sous forme d’une chaîne de caractères et renvoie la\nlit_fasta()\nséquence d’ADN lue dans le fichier sous forme d’une chaîne de caractères.\n•\nFonction : prend en argument une taille de séquence sous forme d’un entier et renvoie une séquence\nseq_alea()\naléatoire d’ADN de la taille correspondante sous forme d’une chaîne de caractères.\n•\nFonction : prend en argument une séquence d’ADN sous forme d’une chaîne de caractères et renvoie\ncomp_inv()\nla séquence complémentaire inverse (aussi sous forme d’une chaîne de caractères).\n•\nFonction : prend en argument une séquence d’ADN sous forme d’une chaîne de caractères et renvoie\nprop_gc()\nla proportion en GC de la séquence sous forme d’un float. Nous vous rappelons que la proportion de GC s’obtient\ncomme la somme des bases Guanine (G) et Cytosine (C), divisée par le nombre total de bases (A, T, C, G).\n• → → → →\nConstante : dictionnaire qui contient la complémentarité des bases d’ADN ( , , et ).\nBASE_COMP A T T C G C C G\nCe dictionnaire sera utilisé par la fonction .\ncomp_inv()\nÀ la fin de votre script, proposez des exemples d’utilisation des fonctions que vous aurez créées. Ces exemples\nd’utilisation ne devront pas être exécutés lorsque le script est chargé comme un module.\nConseil\n•\nDans cet exercice, on supposera que toutes les séquences sont manipulées comme des chaînes de caractères en\nmajuscules.\n•\nPour les fonctions et , n’hésitez pas à jeter un œil aux exercices correspondants dans le\nseq_alea() comp_inv()\nchapitre 12 Plus sur les listes.\n•\n2\nVoici un exemple de fichier FASTA pour tester la fonction .\nadn.fasta lit_fasta()\n2. https://python.sdv.u-paris.fr/data-files/adn.fasta\n162 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Bonnes pratiques en programmation Python",
    "content": "Comme vous l’avez constaté dans tous les chapitres précédents, la syntaxe de Python est très permissive. Afin\nd’uniformiser l’écriture de code en Python, la communauté des développeurs Python recommande un certain nombre de\nrègles afin qu’un code soit lisible. Lisible par quelqu’un d’autre, mais également, et surtout, par soi-même. Essayez de\nrelire un code que vous avez écrit « rapidement » il y a un mois, six mois ou un an. Si le code ne fait que quelques lignes,\nil se peut que vous vous y retrouviez, mais s’il fait plusieurs dizaines, voire centaines de lignes, vous serez perdus.\nDans ce contexte, le créateur de Python, Guido van Rossum, part d’un constat simple : « code is read much more\noften than it is written » (« le code est plus souvent lu qu’écrit »). Avec l’expérience, vous vous rendrez compte que cela\nest parfaitement vrai. Alors, plus de temps à perdre, voyons en quoi consistent ces bonnes pratiques.\nPlusieurs choses sont nécessaires pour écrire un code lisible : la syntaxe, l’organisation du code, le découpage en\nfonctions (et possiblement en classes, que nous verrons dans le chapitre 23 Avoir la classe avec les objets), mais souvent,\naussi, le bon sens. Pour cela, les « PEP » peuvent nous aider.\nDéfinition\nAfin d’améliorer le langage Python, la communauté qui développe Python publie régulièrement des Python Enhance-\n1\nment Proposal (PEP), suivi d’un numéro. Il s’agit de propositions concrètes pour améliorer le code, ajouter de nouvelles\nfonctionnalités, mais aussi des recommandations sur la manière d’utiliser Python, bien écrire du code, etc.\nOn va aborder dans ce chapitre sans doute la plus célèbre des PEP, à savoir la PEP 8, qui est incontournable lorsque\nl’on veut écrire du code Python correctement.\nDéfinition\nOn parle de code pythonique lorsque ce dernier respecte les règles d’écriture définies par la communauté Python,\nmais aussi les règles d’usage du langage.\n1. https://www.python.org/dev/peps/\n163\nChapitre 16. Bonnes pratiques en programmation Python 16.1. De la bonne syntaxe avec la PEP 8"
  },
  {
    "title": "De la bonne syntaxe avec la PEP 8",
    "content": "2\nLa PEP 8 Style Guide for Python Code est une des plus anciennes PEP (les numéros sont croissants avec le temps).\nElle consiste en un nombre important de recommandations sur la syntaxe de Python. Il est vivement recommandé de lire\nla PEP 8 en entier au moins une fois pour avoir une bonne vue d’ensemble. On ne présentera ici qu’un rapide résumé de\ncette PEP 8.\n16.1.1 Indentation\nOn a vu que l’indentation est obligatoire en Python pour séparer les blocs d’instructions. Cela vient d’un constat\nsimple : l’indentation améliore la lisibilité d’un code. La PEP 8 recommande d’utiliser quatre espaces pour chaque niveau\nd’indentation. Nous vous recommandons de suivre impérativement cette règle.\nAttention\nAfin de toujours utiliser cette règle des quatre espaces pour l’indentation, il est essentiel de régler correctement votre\n3\néditeur de texte. Consultez pour cela l’annexe Installation de Python disponible en ligne . Avant d’écrire la moindre ligne\nde code, faites en sorte que lorsque vous pressez la touche tabulation, cela ajoute quatre espaces (et non pas un caractère\ntabulation).\n16.1.2 Importation des modules\nComme on l’a vu dans le chapitre 9 Modules, le chargement d’un module est réalisé avec l’instruction\nimport module\nplutôt qu’avec .\nfrom module import *\nSi on souhaite ensuite utiliser une fonction d’un module, la première syntaxe conduit à , ce qui\nmodule.fonction()\nrend explicite la provenance de la fonction. Avec la seconde syntaxe, il faudrait écrire , ce qui peut :\nfonction()\n•\nmener à un conflit si une de vos fonctions a le même nom ;\n•\nrendre diﬀicile la recherche de documentation si on ne sait pas d’où vient la fonction, notamment si plusieurs\nmodules sont chargés avec l’instruction\nfrom module import *\nPar ailleurs, la première syntaxe définit un « espace de noms » spécifique au module (voir le chapitre 24 Avoir plus\nla classe avec les objets (en ligne)).\nDans un script Python, on importe un module par ligne. D’abord les modules internes (classés par ordre alphabétique),\nc’est-à-dire les modules de base de Python, puis les modules externes (ceux que vous avez installés en plus), et enfin, les\nmodules que vous avez créés.\nSi le nom du module est trop long, on peut utiliser un alias. L’instruction est tolérée si vous n’importez que\nfrom\nquelques fonctions clairement identifiées.\nEn résumé :\n1 import module_interne_1\n2\nimport module_interne_2\n3 from module_interne_3 import fonction_spécifique\n4\n5 import module_externe_1\n6\nimport module_externe_2_qui_a_un_nom_long as mod2\n7\n8\nimport module_cree_par_vous\n16.1.3 Règles de nommage\nLes noms de variables, de fonctions et de modules doivent être de la forme :\n1\nma_variable\n2 fonction_test_27()\n3\nmon_module\n2.\nhttps://www.python.org/dev/peps/pep-0008/\n3. https://python.sdv.u-paris.fr/livre-dunod\n164 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n16.1. De la bonne syntaxe avec la PEP 8 Chapitre 16. Bonnes pratiques en programmation Python\nc’est-à-dire en minuscules avec un caractère « souligné » (« tiret du bas », ou underscore en anglais) pour séparer les\ndifférents « mots » dans le nom.\nLes constantes sont écrites en majuscules :\n1\nMA_CONSTANTE\n2 VITESSE_LUMIERE\nLes noms de classes (voir le chapitre 23 Avoir la classe avec les objets) et les exceptions (voir le chapitre 26 Remarques\ncomplémentaires (en ligne)) sont de la forme :\n1 MaClasse\n2 MyException\nRemarque\n•\nLe style recommandé pour nommer les variables et les fonctions en Python est appelé snake_case. Il est différent\ndu CamelCase utilisé pour les noms des classes et des exceptions.\n•\nLa variable est habituellement employée pour stocker des valeurs qui ne seront pas utilisées par la suite. Par\n_\nexemple, dans le cas d’une affectation multiple, on peut utiliser pour stocker une valeur qui ne nous intéresse pas\n_\n(voir chapitre 14 Conteneurs).\nPensez à donner à vos variables des noms qui ont du sens. Évitez autant que possible les , , , , …\na1 a2 i truc toto\nLes noms de variables à un caractère sont néanmoins autorisés pour les indices dans les boucles :\n1 >>> ma_liste = [1, 3, 5, 7, 9, 11]\n2\n>>> for i in range(len(ma_liste)):\n3 ... print(ma_liste[i])\nBien sûr, une écriture plus « pythonique » de l’exemple précédent permet de se débarrasser de l’indice :\ni\n1 >>> ma_liste = [1, 3, 5, 7, 9, 11]\n2\n>>> for entier in ma_liste:\n3 ... print(entier)\nEnfin, des noms de variable à une lettre peuvent être utilisés lorsque cela a un sens mathématique (par exemple, les\nnoms , et évoquent des coordonnées cartésiennes).\nx y z\n16.1.4 Gestion des espaces\nLa PEP 8 recommande d’entourer les opérateurs ( , , , , , , , , , , …) d’un espace avant et\n+ - / * == != >= not in and or\nd’un espace après. Par exemple :\n1 # Code recommandé :\n2\nma_variable = 3 + 7\n3 mon_texte = \"souris\"\n4\nmon_texte == ma_variable\n5 # Code non recommandé :\n6\nma_variable=3+7\n7 mon_texte=\"souris\"\n8\nmon_texte== ma_variable\nIl n’y a, par contre, pas d’espace à l’intérieur de crochets, d’accolades et de parenthèses :\n1\n# Code recommandé :\n2 ma_liste[1]\n3\nmon_dico{\"clé\"}\n4 ma_fonction(argument)\n5\n# Code non recommandé :\n6 ma_liste[ 1 ]\n7\nmon_dico{\"clé\" }\n8 ma_fonction( argument )\nNi juste avant la parenthèse ouvrante d’une fonction ou le crochet ouvrant d’une liste ou d’un dictionnaire :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 165\nChapitre 16. Bonnes pratiques en programmation Python 16.1. De la bonne syntaxe avec la PEP 8\n1\n# Code recommandé :\n2 ma_liste[1]\n3\nmon_dico{\"clé\"}\n4 ma_fonction(argument)\n5\n# Code non recommandé :\n6 ma_liste [1]\n7 mon_dico {\"clé\"}\n8\nma_fonction (argument)\nOn met un espace après les caractères et (mais pas avant) :\n: ,\n1\n# Code recommandé :\n2 ma_liste = [1, 2, 3]\n3\nmon_dico = {\"clé1\": \"valeur1\", \"clé2\": \"valeur2\"}\n4 ma_fonction(argument1, argument2)\n5\n# Code non recommandé :\n6 ma_liste = [1 , 2 ,3]\n7\nmon_dico = {\"clé1\" : \"valeur1\", \"clé2\":\"valeur2\"}\n8 ma_fonction(argument1 ,argument2)\nPar contre, pour les tranches de listes, on ne met pas d’espace autour du\n:\n1\nma_liste = [1, 3, 5, 7, 9, 1]\n2 # Code recommandé :\n3\nma_liste[1:3]\n4 ma_liste[1:4:2]\n5\nma_liste[::2]\n6 # Code non recommandé :\n7\nma_liste[1 : 3]\n8 ma_liste[1: 4:2 ]\n9\nma_liste[ : :2]\nEnfin, on n’ajoute pas plusieurs espaces autour du ou des autres opérateurs pour faire joli :\n=\n1\n# Code recommandé :\n2 x1 = 1\n3\nx2 = 3\n4 x_old = 5\n5\n# Code non recommandé :\n6 x1 = 1\n7 x2 = 3\n8\nx_old = 5\n16.1.5 Longueur de ligne\nUne ligne de code ne doit pas dépasser 79 caractères, pour des raisons tant historiques que de lisibilité.\nOn a déjà vu dans le chapitre 1 Introduction que le caractère permet de couper des lignes trop longues. Par exemple :\n\\\n1\n>>> ma_variable = 3\n2 >>> if ma_variable > 1 and ma_variable < 10 \\\n3\n... and ma_variable % 2 == 1 and ma_variable % 3 == 0:\n4 ... print(f\"ma variable vaut {ma_variable}\")\n5 ...\n6\nma variable vaut 3\nÀ l’intérieur de parenthèses, on peut revenir à la ligne sans utiliser le caractère . C’est particulièrement utile pour\n\\\npréciser les arguments d’une fonction ou d’une méthode, lors de sa création ou lors de son utilisation :\n1 >>> def ma_fonction(argument_1, argument_2,\n2\n... argument_3, argument_4):\n3 ... return argument_1 + argument_2\n4\n...\n5 >>> ma_fonction(\"texte très long\", \"tigre\",\n6 ... \"singe\", \"souris\")\n7\n'texte très longtigre'\nLes parenthèses sont également très pratiques, pour répartir sur plusieurs lignes une chaîne de caractères qui sera\n166 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n16.1. De la bonne syntaxe avec la PEP 8 Chapitre 16. Bonnes pratiques en programmation Python\nensuite aﬀichée sur une seule ligne :\n1 >>> print(\"ATGCGTACAGTATCGATAAC\"\n2 ... \"ATGACTGCTACGATCGGATA\"\n3\n... \"CGGGTAACGCCATGTACATT\")\n4 ATGCGTACAGTATCGATAACATGACTGCTACGATCGGATACGGGTAACGCCATGTACATT\nNotez qu’il n’y a pas d’opérateur pour concaténer les trois chaînes de caractères, et que celles-ci ne sont pas séparées\n+\npar des virgules. À partir du moment où elles sont entre parenthèses, Python les concatène automatiquement.\nOn peut aussi utiliser les parenthèses pour évaluer un expression trop longue :\n1 >>> ma_variable = 3\n2 >>> if (ma_variable > 1 and ma_variable < 10\n3\n... and ma_variable % 2 == 1 and ma_variable % 3 == 0):\n4 ... print(f\"ma variable vaut {ma_variable}\")\n5\n...\n6 ma variable vaut 3\nRemarque\nLes parenthèses sont aussi très utiles lorsqu’on a besoin d’enchaîner des méthodes les unes à la suite des autres. Cette\ntechnique du method chaining a été introduite dans le chapitre 11 Plus sur les chaînes de caractères et sera très utilisée\ndans le chapitre 22 Module Pandas.\nEnfin, il est possible de créer des listes ou des dictionnaires sur plusieurs lignes, en sautant une ligne après une virgule :\n1\n>>> ma_liste = [1, 2, 3,\n2 ... 4, 5, 6,\n3\n... 7, 8, 9]\n4 >>> mon_dico = {\"clé1\": 13,\n5\n... \"clé2\": 42,\n6 ... \"clé3\": -10}\n16.1.6 Lignes vides\nDans un script, les lignes vides sont utiles pour séparer visuellement les différentes parties du code.\nIl est recommandé de laisser deux lignes vides avant la définition d’une fonction ou d’une classe, et de laisser une\nseule ligne vide avant la définition d’une méthode (dans une classe).\nOn peut aussi laisser une ligne vide dans le corps d’une fonction pour séparer les sections logiques de la fonction,\nmais cela est à utiliser avec parcimonie.\n16.1.7 Commentaires\nLes commentaires débutent toujours par le symbole suivi d’un espace. Ils fournissent des explications sur l’utilité\n#\ndu code et permettent de comprendre son fonctionnement.\nLes commentaires sont sur le même niveau d’indentation que le code qu’ils commentent. Les commentaires sont\nconstitués de phrases complètes, avec une majuscule au début (sauf si le premier mot est une variable qui s’écrit sans\nmajuscule) et un point à la fin.\nLa PEP 8 recommande d’écrire les commentaires en anglais, sauf si vous êtes absolument certains que votre code ne\nsera lu que par des francophones. Dans la mesure où vous allez souvent développer des programmes scientifiques, nous\nvous conseillons d’écrire vos commentaires en anglais.\nSoyez également cohérent entre la langue utilisée pour les commentaires et la langue utilisée pour nommer les variables.\nPour un programme scientifique, les commentaires et les noms de variables sont en anglais. Ainsi deviendra\nma_liste\net deviendra (par exemple).\nmy_list ma_fonction my_function\nLes commentaires qui suivent le code sur la même ligne sont à éviter le plus possible et doivent être séparés du code\npar au moins deux espaces :\n1\nvar_x = number / total * 100 # My useful comment.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 167\nChapitre 16. Bonnes pratiques en programmation Python 16.2. Les docstrings et la PEP 257\nRemarque\n4\nLa PEP 8 ne fournit pas de recommandation quant à l’usage de guillemets simples ou de guillemets doubles pour\ndéclarer une chaîne de caractères.\n1\n>>> var_1 = \"Ma chaîne de caractères\"\n2 >>> var_1\n3\n'Ma chaîne de caractères'\n4 >>> var_2 = 'Ma chaîne de caractères'\n5 >>> var_2\n6\n'Ma chaîne de caractères'\n7 >>> var_1 == var_2\n8\nTrue\nVous constatez dans l’exemple ci-dessus que, pour Python, les guillemets simples et doubles sont équivalents. Nous\nvous conseillons cependant d’utiliser les guillemets doubles car ceux-ci sont, de notre point de vue, plus lisibles."
  },
  {
    "title": "Les docstrings et la PEP 257",
    "content": "Les docstrings, que l’on pourrait traduire par « chaînes de documentation » en français, sont un élément essentiel\ndes programmes Python, comme on l’a vu au chapitre 15 Création de modules. À nouveau, les développeurs de Python\n5\nont émis des recommandations dans la PEP 8, et plus exhaustivement dans la PEP 257 , sur la manière de rédiger\ncorrectement les docstrings. En voici un résumé succinct.\n16.2.1 Les principales règles\nDe manière générale, écrivez des docstrings pour les modules, les fonctions, les classes et les méthodes que vous\ndéveloppez.\nLorsque l’explication est courte et compacte, comme dans certaines fonctions ou méthodes simples, utilisez des\ndocstrings d’une ligne :\n1 \"\"\"Docstring simple d'une ligne se finissant par un point.\"\"\"\nLorsque vous avez besoin de décrire plus en détail un module, une fonction, une classe ou une méthode, utilisez une\ndocstring sur plusieurs lignes :\n1\n\"\"\"Docstring de plusieurs lignes, la première ligne est un résumé.\n2\n3\nAprès avoir sauté une ligne, on décrit les détails de cette docstring.\n4 On termine la docstring avec les triples guillemets\n5\nsur la ligne suivante.\n6 \"\"\"\nRemarque\nLa PEP 257 recommande d’écrire des docstrings avec trois doubles guillemets, c’est-à-dire :\n\"\"\"Ceci est une docstring recommandée.\"\"\"\nmais pas :\n'''Ceci n'est pas une docstring recommandée.'''\nComme indiqué dans le chapitre 15 Création de modules, n’oubliez pas que les docstrings sont destinées aux utilisateurs\ndes modules, fonctions, méthodes et classes que vous avez développés. Les éléments essentiels pour les fonctions et les\nméthodes sont :\n1. ce que fait la fonction ou la méthode,\n2. ce qu’elle prend en argument,\n3. ce qu’elle renvoie.\n4.\nhttps://peps.python.org/pep-0008/#string-quotes\n5. https://www.python.org/dev/peps/pep-0257/\n168 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n16.3. Outils de contrôle qualité du code Chapitre 16. Bonnes pratiques en programmation Python\nPour les modules et les classes, on ajoute également des informations générales sur leur fonctionnement.\nPour autant, la PEP 257 ne dit pas explicitement comment organiser les docstrings pour les fonctions et les méthodes.\nPour répondre à ce besoin, deux solutions ont émergées :\n• 6\nla solution Google avec le Google Style Python Docstrings ,\n•\n7\nla solution NumPy avec le NumPy Style Python Docstrings . NumPy est un module complémentaire à Python,\ntrès utilisé en analyse de données et dont on parlera dans le chapitre 20.\n16.2.2 Un exemple concret\nOn illustre ici la solution de docstrings NumPy pour des raisons de goût personnel. Sentez-vous libre d’explorer la\nproposition de Google.\nVoici un exemple pour une fonction qui prend en argument deux entiers et qui renvoie leur produit :\n1\ndef multiplie_nombres(nombre1, nombre2):\n2 \"\"\"Multiplication de deux nombres entiers.\n3\n4 Cette fonction ne sert pas à grand chose.\n5\n6 Parameters\n7\n----------\n8 nombre1 : int\n9\nLe premier nombre entier.\n10 nombre2 : int\n11\nLe second nombre entier,\n12 très important pour cette fonction.\n13\n14 Returns\n15 -------\n16\nint\n17 Le produit des deux nombres.\n18\n\"\"\"\n19 return nombre1 * nombre2\n•\nLignes 6 et 7. La section précise les paramètres de la fonction. Les tirets sur la ligne 7 soulignent le\nParameters\nnom de la section pour la rendre visible.\n•\nLignes 8 et 9. On indique le nom et le type du paramètre, séparés par le caractère deux-points. Le type n’est pas\nobligatoire. En dessous, on indique une description du paramètre en question. La description est indentée.\n•\nLignes 10 à 12. Même chose pour le second paramètre. La description du paramètre peut s’étaler sur plusieurs\nlignes.\n•\nLignes 14 et 15. La section indique ce qui est renvoyé par la fonction (le cas échéant).\nReturns\n•\nLignes 16 et 17. La mention du type renvoyé est obligatoire. En dessous, on indique une description de ce qui est\nrenvoyé par la fonction. Cette description est aussi indentée.\nAttention\nL’être humain a une fâcheuse tendance à la procrastination (le fameux « Bah je le ferai demain…») et écrire de la\ndocumentation peut être un sérieux motif de procrastination. Soyez vigilant sur ce point, et rédigez vos docstrings au\nmoment où vous écrivez vos modules, fonctions, classes ou méthodes. Passer une journée (voire plusieurs) à écrire les\ndocstrings d’un gros projet est particulièrement pénible. Croyez-nous !"
  },
  {
    "title": "Outils de contrôle qualité du code",
    "content": "Pour évaluer la qualité d’un code Python, c’est-à-dire sa conformité avec les recommandations de la PEP 8 et de la\nPEP 257, on peut utiliser les outils , et .\npycodestyle pydocstyle pylint\nCes outils ne sont fournis dans l’installation de base de Python et doivent être installés sur votre machine. Avec la\ndistribution Miniconda, cette étape d’installation se résume à une ligne de commande :\n6.\nhttps://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html\n7. https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 169\nChapitre 16. Bonnes pratiques en programmation Python 16.3. Outils de contrôle qualité du code\n$ conda install -c conda-forge pycodestyle pydocstyle pylint\nDéfinition\nLes outils , et sont des linters, c’est-à-dire des programmes qui vont chercher les\npycodestyle pydocstyle pylint\nsources potentielles d’erreurs dans un code informatique. Ces erreurs peuvent être des erreurs de style (PEP 8 et 257) ou\ndes erreurs logiques (manipulation d’une variable, chargement de module).\n8\nVoici le contenu du script que nous allons analyser par la suite :\nscript_quality_not_ok.py\n1\n\"\"\"Un script de multiplication.\n2 \"\"\"\n3\n4 import os\n5\n6 def Multiplie_nombres(nombre1,nombre2 ):\n7 \"\"\"Multiplication de deux nombres entiers\n8 Cette fonction ne sert pas à grand chose.\n9\n10\nParameters\n11 ----------\n12\nnombre1 : int\n13 Le premier nombre entier.\n14\nnombre2 : int\n15 Le second nombre entier.\n16\nTrès utile.\n17\n18\nReturns\n19 -------\n20\nint\n21 Le produit des deux nombres.\n22\n23\n\"\"\"\n24 return nombre1 *nombre2\n25\n26\n27\nif __name__ == \"__main__\":\n28 print(f\"2 x 3 = {Multiplie_nombres(2, 3)}\")\n29\nprint (f\"4 x 5 = {Multiplie_nombres(4, 5)}\")\nCe script est d’ailleurs parfaitement fonctionnel :\n$ python script_quality_not_ok.py\n2 x 3 = 6\n4 x 5 = 20\nOn va tout d’abord vérifier la conformité avec la PEP 8 grâce à l’outil :\npycodestyle\n$ pycodestyle script_quality_not_ok.py\nscript_quality_not_ok.py:6:1: E302 expected 2 blank lines, found 1\nscript_quality_not_ok.py:6:30: E231 missing whitespace after ','\nscript_quality_not_ok.py:6:38: E202 whitespace before ')'\nscript_quality_not_ok.py:26:21: E225 missing whitespace around operator\nscript_quality_not_ok.py:31:10: E211 whitespace before '('\n•\nLigne 2. Le bloc désigne le nom du script (\nscript_quality_not_ok.py:6:1: script_quality_not_ok.\n), le numéro de la ligne (6) et le numéro de la colonne (1) où se trouve la non-conformité avec la PEP 8.\npy\nEnsuite, fournit un code et un message explicatif. Ici, il faut deux lignes vides avant la fonction\npycodestyle\n.\nMultiplie_nombres()\n•\nLigne 3. Il manque un espace après la virgule qui sépare les arguments et dans la définition de\nnombre1 nombre2\nla fonction à la ligne 6 (colonne 30) du script.\nMultiplie_nombres()\n8. https://python.sdv.u-paris.fr/data-files/script_quality_not_ok.py\n170 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n16.4. Outil de formatage automatique du code Chapitre 16. Bonnes pratiques en programmation Python\n•\nLigne 4. Il y un espace de trop après le second argument dans la définition de la fonction\nnombre2 Multiplie_nombres\nà la ligne 6 (colonne 38) du script.\n()\n•\nLigne 5. Il manque un espace après l’opérateur à la ligne 26 (colonne 21) du script.\n*\n•\nLigne 6. Il y a un espace de trop entre et à la ligne 31 (colonne 10) du script.\nprint (\nAssez curieusement, n’a pas détecté que le nom de la fonction ne respecte\npycodestyle Multiplie_nombres()\npas la convention de nommage (pas de majuscule).\nEnsuite, l’outil va vérifier la conformité avec la PEP 257 et s’intéresser particulièrement aux docstrings :\npydocstyle\n$ pydocstyle script_quality_not_ok.py\nscript_quality_not_ok.py:1 at module level:\nD200: One-line docstring should fit on one line with quotes (found 2)\nscript_quality_not_ok.py:7 in public function `Multiplie_nombres`:\nD205: 1 blank line required between summary line and description (found 0)\nscript_quality_not_ok.py:7 in public function `Multiplie_nombres`:\nD400: First line should end with a period (not 's')\n•\nLignes 2 et 3. indique que la docstring à la ligne 1 du script est sur deux lignes, alors qu’elle devrait\npydocstyle\nêtre sur une seule ligne.\n•\nLignes 4 et 5. Dans la docstring de la fonction (ligne 7 du script), il manque une ligne\nMultiplie_nombres()\nvide entre la ligne résumé et la description plus complète.\n•\nLignes 6 et 7. Dans la docstring de la fonction (ligne 7 du script), il manque un point\nMultiplie_nombres()\nà la fin de la première ligne.\nLes outils et vont simplement vérifier la conformité aux PEP 8 et 257. L’outil\npycodestyle pydocstyle pylint\nva lui aussi vérifier une partie de ces règles mais il va également essayer de comprendre le contexte du code et proposer\ndes éléments d’amélioration. Par exemple :\n$ pylint script_quality_not_ok.py\n************* Module script_quality_not_ok\nscript_quality_not_ok.py:6:0: C0103: Function name \"Multiplie_nombres\"\ndoesn't conform to snake_case naming style (invalid-name)\nscript_quality_not_ok.py:4:0: W0611: Unused import os (unused-import)\n------------------------------------------------------------------\nYour code has been rated at 6.67/10\n•\nLignes 3 et 4. indique que nom de la fonction ne respecte pas la convention\npylint Multiplie_nombres()\nPEP 8 (ligne 6 du script).\n•\nLigne 5. Le module est chargé mais pas utilisé (ligne 4 du script).\nos\n•\nLigne 8. produit également une note sur 10. Ne soyez pas surpris si cette note est très basse (voire\npylint\nnégative) la première fois que vous analysez votre script avec . Cet outil fournit de nombreuses suggestions\npylint\nd’amélioration et la note attribuée à votre script devrait rapidement augmenter. Pour autant, la note de 10 est\nparfois diﬀicile à obtenir. Ne soyez pas trop exigeant.\n9\nUne version améliorée du script précédent est disponible en ligne ."
  },
  {
    "title": "Outil de formatage automatique du code",
    "content": "Se souvenir de toutes les règles PEP 8 est fastidieux. Il existe des outils pour formater automatiquement le code\nPython pour qu’il soit conforme à la PEP 8. L’outil le plus connu est .\nblack\nCet outil n’est pas fourni dans l’installation de base de Python et doit être installé sur votre machine. Avec la\ndistribution Miniconda, cette étape d’installation se résume à une ligne de commande :\n$ conda install -c conda-forge black\nVoici un exemple d’utilisation :\n$ black script_quality_not_ok.py\nreformatted script_quality_not_ok.py\nAll done!\n1 file reformatted.\n9. https://python.sdv.u-paris.fr/data-files/script_quality_ok.py\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 171\nChapitre 16. Bonnes pratiques en programmation Python 16.5. Organisation du code\nLe script a été modifié pour être conforme à la PEP 8, ce qu’on peut vérifier avec\nscript_quality_not_ok.py\n:\npycodestyle\n$ pycodestyle script_quality_not_ok.py\nqui ne renvoie aucune erreur.\npeut modifier votre code de manière significative. Il est donc recommandé de l’utiliser avec l’option\nblack --diff\nau préalable pour aﬀicher les modifications apportées. Par exemple, avec le programme\nscript_quality_not_ok.py\nqui n’aurait pas été modifié :\n$ black --diff script_quality_not_ok.py\n--- script_quality_not_ok.py 2024-02-05 12:07:04.851491+00:00\n+++ script_quality_not_ok.py 2024-02-05 12:07:10.418009+00:00\n@@ -1,11 +1,12 @@\n\"\"\"Un script de multiplication.\n\"\"\"\nimport os\n-def Multiplie_nombres(nombre1,nombre2 ):\n+\n+def Multiplie_nombres(nombre1, nombre2):\n[...]\nConseil\nest très pratique. N’hésitez pas à l’utiliser pour formater automatiquement votre code.\nblack\nAttention\n•\nne fait qu’une entorse à la PEP 8 : il autorise des longueurs de lignes jusqu’à 88 caractères. Si vous souhaitez\nblack\nrespecter strictement la PEP 8, utilisez l’option .\n--line-length 79\n•\nse limite à la PEP 8. Il ne vérifie pas la conformité avec la PEP 257 ni la qualité du code (imports inutiles,\nblack\netc.). Utilisez toujours et en complément.\npydocstyle pylint"
  },
  {
    "title": "Organisation du code",
    "content": "Il est important de toujours structurer son code de la même manière. Ainsi, on sait tout de suite où trouver l’information\net un autre programmeur pourra s’y retrouver. Voici un exemple de code avec les différents éléments dans le bon ordre :\n172 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n16.6. Conseils sur la conception d’un script Chapitre 16. Bonnes pratiques en programmation Python\n1\n\"\"\"Docstring d'une ligne décrivant brièvement ce que fait le programme.\n2\n3\nUsage:\n4 ======\n5\npython nom_de_ce_super_script.py argument1 argument2\n6\n7 argument1: un entier signifiant un truc\n8\nargument2: une chaîne de caractères décrivant un bidule\n9 \"\"\"\n10\n11 __authors__ = (\"Johny B Good\", \"Hubert de la Pâte Feuilletée\")\n12\n__contact__ = (\"johny@bgood.us\", \"hub@pate.feuilletee.fr\")\n13 __copyright__ = \"MIT\"\n14\n__date__ = \"2030-01-01\"\n15 __version__ = \"1.2.3\"\n16\n17 import module_interne\n18\nimport module_interne_2 as mod2\n19\n20 import module_externe\n21\n22 import my_module\n23\n24 UNE_CONSTANTE = valeur\n25\n26\n27\ndef une_fonction_complexe(arg1, arg2, arg3):\n28 \"\"\"Résumé de la docstring décrivant la fonction.\n29\n30 Description détaillée.\n31\n\"\"\"\n32 [...]\n33\nreturn une_chose\n34\n35\n36\ndef une_fonction_simple(arg1, arg2):\n37 \"\"\"Docstring d'une ligne décrivant la fonction.\"\"\"\n38\n[...]\n39 return autre_chose\n40\n41\n42\nif __name__ == \"__main__\":\n43 # Ici débute le programme principal.\n44\n[...]\n•\nLignes 1 à 9. Cette docstring décrit globalement le script. Cette docstring (ainsi que les autres) seront visibles si\non importe le script en tant que module, puis en invoquant la commande (voir chapitre 15 Création de\nhelp()\nmodules).\n•\nLignes 11 à 15. On définit ici un certain nombre de variables avec des doubles underscores donnant quelques\ninformations sur la version du script, les auteurs, etc. Il s’agit de métadonnées que la commande pourra\nhelp()\naﬀicher. Ces métadonnées sont utiles lorsque le code est distribué à la communauté.\n•\nLignes 17 à 22. Importation des modules. D’abord les modules internes à Python (fournis en standard), puis les\nmodules externes (ceux qu’il faut installer en plus), puis les modules créés localement. Un module par ligne.\n•\nLigne 24. Définition des constantes. Le nom des constantes est en majuscule.\n•\nLignes 27 à 39. Définition des fonctions. Avant chaque fonction, on laisse deux lignes vides.\n•\nLignes 42 à 44. On écrit le programme principal. Le test ligne 42 n’est vrai que si le script est utilisé en tant que\nprogramme."
  },
  {
    "title": "Conseils sur la conception d’un script",
    "content": "Voici quelques conseils pour vous aider à concevoir un script Python.\n•\nRéfléchissez avec un papier, un crayon… et un cerveau (voire même plusieurs) ! Reformulez avec vos propres mots\nles consignes qui vous ont été données. Dessinez des schémas si cela vous aide.\n•\nDécoupez en fonctions chaque élément de votre programme. Vous pourrez ainsi tester chaque élément indépen-\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 173\nChapitre 16. Bonnes pratiques en programmation Python 16.7. Pour terminer : la PEP 20\ndamment du reste. Pensez à écrire les docstrings en même temps que vous écrivez vos fonctions.\n•\nDocumentez-vous. L’algorithme dont vous avez besoin existe-t-il déjà dans un autre module ? De quels outils\nmathématiques avez-vous besoin dans votre algorithme ?\n•\nQuand l’algorithme est complexe, commentez votre code pour expliquer votre raisonnement. Utiliser des fonctions\n(ou méthodes) encore plus petites peut aussi être une solution.\n•\nUtilisez des noms de variables explicites, qui signifient quelque chose. En lisant votre code, on doit comprendre\nce que vous faites. Choisir des noms de variables pertinents permet aussi de réduire les commentaires.\n•\nQuand vous construisez une structure de données complexe (par exemple une liste de dictionnaires contenant\nd’autres objets), documentez l’organisation de cette structure de données avec un exemple simple.\n•\nSi vous créez ou manipulez une entité cohérente avec des propriétés propres, essayez de construire une classe.\nReportez-vous, pour cela, au chapitre 23 Avoir la classe avec les objets.\n•\nTestez votre code sur un petit jeu de données, pour comprendre rapidement ce qui se passe et corriger d’éven-\ntuelles erreurs. Par exemple, une séquence d’ADN de 1 000 bases est plus facile à manipuler que le génome humain\n× 9\n(3 10 bases) !\n•\nLorsque votre programme « plante », lisez le message d’erreur. Python tente de vous expliquer ce qui ne va pas.\nLe numéro de la ligne qui pose problème est aussi indiqué.\n•\nDiscutez avec des gens. Faites tester votre programme par d’autres. Les instructions d’utilisation sont-elles\nclaires ?\n•\nEnfin, si vous distribuez votre code :\n— Rédigez une documentation claire.\n10\n— Testez votre programme (jetez un œil aux tests unitaires ).\n11\n— Précisez une licence d’utilisation (voir le site Choose an open source license )."
  },
  {
    "title": "Pour terminer : la PEP 20",
    "content": "La PEP 20 est une sorte de réflexion philosophique avec des phrases simples qui devraient guider tout programmeur.\nComme les développeurs de Python ne manque pas d’humour, celle-ci est accessible sous la forme d’un « œuf de Pâques\n» (easter egg, en anglais) ou encore « fonctionnalité cachée d’un programme » en important un module nommé :\nthis\n1\n>>> import this\n2 The Zen of Python, by Tim Peters\n3\n4 Beautiful is better than ugly.\n5\nExplicit is better than implicit.\n6 Simple is better than complex.\n7\nComplex is better than complicated.\n8 Flat is better than nested.\n9\nSparse is better than dense.\n10 Readability counts.\n11\nSpecial cases aren't special enough to break the rules.\n12 Although practicality beats purity.\n13\nErrors should never pass silently.\n14 Unless explicitly silenced.\n15 In the face of ambiguity, refuse the temptation to guess.\n16\nThere should be one-- and preferably only one --obvious way to do it.\n17 Although that way may not be obvious at first unless you're Dutch.\n18\nNow is better than never.\n19 Although never is often better than *right* now.\n20\nIf the implementation is hard to explain, it's a bad idea.\n21 If the implementation is easy to explain, it may be a good idea.\n22\nNamespaces are one honking great idea -- let's do more of those!\nEt si l’aventure et les easter eggs vous plaisent, testez également la commande\n1 >>> import antigravity\nIl vous faudra un navigateur et une connexion internet.\n10.\nhttps://fr.wikipedia.org/wiki/Test_unitaire\n11. https://choosealicense.com/\n174 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n16.7. Pour terminer : la PEP 20 Chapitre 16. Bonnes pratiques en programmation Python\nPour aller plus loin\n•\n12\nL’article Python Code Quality : Tools & Best Practices du site Real Python est une ressource intéressante pour\nexplorer plus en détail la notion de qualité pour un code Python. De nombreux linters y sont présentés.\n•\n13 14\nLes articles Assimilez les bonnes pratiques de la PEP 8 du site OpenClassrooms et Structuring Python Programs\ndu site Real Python rappellent les règles d’écriture et les bonnes pratiques vues dans ce chapitre.\n12. https://realpython.com/python-code-quality/\n13.\nhttps://openclassrooms.com/fr/courses/4425111-perfectionnez-vous-en-python/4464230-assimilez-les-bonnes-pratiques-de-la-pep-8\n14. https://realpython.com/python-program-structure/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 175"
  },
  {
    "title": "Expressions régulières et parsing",
    "content": "Le module re permet d’utiliser des expressions régulières avec Python. Les expressions régulières sont aussi appelées\nen anglais regular expressions, ou en plus court regex. Dans la suite de ce chapitre, nous utiliserons souvent le mot regex\npour désigner une expression régulière. Les expressions régulières sont puissantes et incontournables en bioinformatique,\nsurtout lorsque vous souhaitez récupérer des informations dans de gros fichiers.\nCette action de recherche de données dans un fichier est appelée généralement parsing (qui signifie littéralement «\nanalyse syntaxique »). Le parsing fait partie du travail quotidien du bioinformaticien, il est sans arrêt en train de « fouiller\n» dans des fichiers pour en extraire des informations d’intérêt, par exemple récupérer les coordonnées 3D des atomes\nd’une protéine dans un fichier PDB, ou encore extraire les gènes d’un fichier GenBank.\nDans ce chapitre, nous ne ferons que quelques rappels sur les expressions régulières. Pour une documentation plus\n1\ncomplète, référez-vous à la page d’aide des expressions régulières sur le site oﬀiciel de Python."
  },
  {
    "title": "Définition et syntaxe",
    "content": "Une expression régulière est une suite de caractères qui a pour but de décrire un fragment de texte. Cette suite de\ncaractères est encore appelée motif (en anglais, pattern), qui est constitué de deux types de caractères :\n•\nles caractères dits normaux ;\n•\nles métacaractères ayant une signification particulière, par exemple le caractère signifie début de ligne, et non\n^\npas le caractère « chapeau » littéral.\nAvant de présenter les regex en Python, nous allons faire un petit détour par Unix. En effet, certains programmes,\ncomme , ou encore , savent interpréter les expressions régulières. Tous ces programmes fonctionnent\negrep sed awk\ngénéralement selon le schéma suivant :\n•\nle programme lit un fichier ligne par ligne ;\n•\npour chaque ligne lue, si l’expression régulière passée en argument est retrouvée dans la ligne, alors le programme\neffectue une action.\nPar exemple, pour le programme :\negrep\n$ egrep \"^DEF\" herp_virus.gbk\nDEFINITION Human herpesvirus 2, complete genome.\nIci, aﬀiche toutes les lignes du fichier du virus de l’herpès ( ) dans lesquelles la regex\negrep herp_virus.gbk ^DEF\n(c’est-à-dire le mot en début de ligne) est retrouvée.\nDEF\n1. https://docs.python.org/fr/3/library/re.html\n176\n17.1. Définition et syntaxe Chapitre 17. Expressions régulières et parsing\nRemarque\nIl est intéressant de faire un point sur le vocabulaire utilisé en anglais et en français. En général, on utilise le verbe\nto match pour indiquer qu’une regex « a fonctionné ». Bien qu’il n’y ait pas de traduction littérale en français, on peut\nutiliser les verbes « retrouver » ou « correspondre ». Par exemple, on pourra traduire l’expression « The regex matches\nthe line » par « La regex est retrouvée dans la ligne » ou encore « La regex correspond dans la ligne ».\nAprès avoir introduit le vocabulaire des regex, voici quelques éléments de syntaxe des métacaractères :\n^ Début de chaîne de caractères ou de ligne.\nExemple : la regex est retrouvée dans la chaîne de caractères mais pas dans la chaîne .\n^ATG ATGCGT CCATGTT\nFin de chaîne de caractères ou de ligne.\n$\nExemple : la regex est retrouvée dans la chaîne de caractères mais pas dans la chaîne .\nATG$ TGCATG CCATGTT\nN’importe quel caractère (mais un caractère quand même).\n.\nExemple : la regex est retrouvée dans , , , mais aussi dans ou dans .\nA.G ATG AtG A4G A-G A G\nLe caractère A ou B ou C (un seul caractère).\n[ABC]\nExemple : la regex est retrouvée dans , ou , mais pas dans .\nT[ABC]G TAG TBG TCG TG\n[A-Z] N’importe quelle lettre majuscule.\nExemple : la regex est retrouvée dans , , …\nC[A-Z]T CAT CBT CCT\n[a-z] N’importe quelle lettre minuscule.\nN’importe quel chiffre.\n[0-9]\nN’importe quel caractère alphanumérique.\n[A-Za-z0-9]\n[^AB] N’importe quel caractère sauf A et B.\nExemple : la regex est retrouvée dans , … mais pas dans ni dans .\nCG[^AB]T CG9T CGCT CGAT CGBT\nCaractère d’échappement (pour protéger certains caractères).\n\\\nExemple : la regex désigne le caractère littéral. La regex est retrouvée dans et non pas dans suivi\n\\+ + A\\.G A.G A\nde n’importe quel caractère, suivi de .\nG\n* 0 à n fois le caractère précédent ou l’expression entre parenthèses précédente.\nExemple : la regex est retrouvée dans , , …\nA(CG)*T AT ACGT ACGCGT\n+ 1 à n fois le caractère précédent ou l’expression entre parenthèses précédente.\nExemple : la regex est retrouvée dans , … mais pas dans .\nA(CG)+T ACGT ACGCGT AT\n0 à 1 fois le caractère précédent ou l’expression entre parenthèses précédente.\n?\nExemple : la regex est retrouvée dans ou .\nA(CG)?T AT ACGT\nn fois le caractère précédent ou l’expression entre parenthèses précédente.\n{n}\nExemple : la regex est retrouvée dans mais pas dans , ou .\nA(CG){2}T ACGCGT ACGT ACGCGCGT ACGCG\n{n,m} n à m fois le caractère précédent ou l’expression entre parenthèses précédente.\nExemple : la regex est retrouvée dans , et mais pas dans , ou .\nA(C){2,4}T ACCT ACCCT ACCCCT ACT ACCCCCT ACCC\n{n,} Au moins n fois le caractère précédent ou l’expression entre parenthèses précédente.\nExemple : la regex est retrouvée dans , et mais pas à ou .\nA(C){2,}T ACCT ACCCT ACCCCT ACT ACCC\n{,m} Au plus m fois le caractère précédent ou l’expression entre parenthèses précédente.\nExemple : la regex est retrouvée dans , et mais pas dans ou .\nA(C){,2}T AT ACT ACCT ACCCT ACC\nLes chaînes de caractères ou .\n(CG|TT)\nCG TT\nExemple : la regex est retrouvée dans ou .\nA(CG|TT)C ACGC ATTC\nEnfin, il existe des caractères spéciaux qui sont bien commodes et qui peuvent être utilisés en tant que métacaractères :\n\\d remplace n’importe quel chiffre (d signifie digit), équivalent à .\n[0-9]\n\\w remplace n’importe quel caractère alphanumérique et le caractère souligné (underscore) (w signifie word character),\néquivalent à .\n[0-9A-Za-z_]\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 177\nChapitre 17. Expressions régulières et parsing 17.2. Quelques ressources en ligne\n\\s remplace n’importe quel « espace blanc » (whitespace) (s signifie space), équivalent à . La notion\n[ \\t\\n\\r\\f]\nd’espace blanc a été abordée dans le chapitre 11 Plus sur les chaînes de caractères. Les espaces blancs les plus\nclassiques sont l’espace , la tabulation , le retour à la ligne , mais il en existe d’autres comme et que nous\n\\t \\n \\r \\f\nne développerons pas ici. est très pratique pour détecter une combinaison d’espace(s) et/ou de tabulation(s).\n\\s\nComme vous le constatez, les métacaractères sont nombreux et leur signification est parfois diﬀicile à maîtriser. Faites\nparticulièrement attention aux métacaractères , et qui, combinés ensemble, peuvent donner des résultats ambigus.\n. + *\nAttention\nIl est important de savoir par ailleurs que les regex sont « avides » (greedy en anglais) lorsqu’on utilise les métaca-\nractères et . Cela signifie que la regex cherchera à « s’étendre » au maximum. Par exemple, si on utilise la regex\n+ * A+\npour faire une recherche dans la chaîne , tous les A de cette chaîne (huit en tout) seront concernés, bien\nTTTAAAAAAAAGC\nque , , etc. « fonctionnent » également avec cette regex.\nAA AAA"
  },
  {
    "title": "Quelques ressources en ligne",
    "content": "Nous vous conseillons de tester systématiquement vos expressions régulières sur des exemples simples. Pour vous\naider, nous vous recommandons plusieurs sites internet :\n•\n2\nRegexOne : tutoriel en ligne très bien fait.\n• 3 4\nRegExr et ExtendsClass : visualisent tous les endroits où une regex est retrouvée dans un texte.\n• 5\npythex.org : interface simple et eﬀicace, dédiée à Python.\n•\n6\nRegular-Expressions.info : documentation exhaustive sur les regex (il y a même une section sur Python).\nN’hésitez pas à explorer ces sites avant de vous lancer dans les exercices ou dans l’écriture de vos propres regex !"
  },
  {
    "title": "Le module re",
    "content": "17.3.1 La fonction\nsearch()\nDans le module re, la fonction est incontournable. Elle permet de rechercher un motif, c’est-à-dire une\nsearch()\nregex, au sein d’une chaîne de caractères avec une syntaxe de la forme . Si est retrouvé\nsearch(motif, chaine) motif\ndans , Python renvoie un objet du type .\nchaine SRE_Match\nSans entrer dans les détails propres au langage orienté objet, si on utilise un objet du type dans un test,\nSRE_Match\nil sera considéré comme vrai. Par exemple, si on recherche le motif dans la chaîne de caractères\ntigre \"girafe tigre\n:\nsinge\"\n1\n>>> import re\n2 >>> animaux = \"girafe tigre singe\"\n3\n>>> re.search(\"tigre\", animaux)\n4 <_sre.SRE_Match object at 0x7fefdaefe2a0>\n5\n>>> if re.search(\"tigre\", animaux):\n6 ... print(\"OK\")\n7\n...\n8 OK\nAttention\nLe motif que vous utilisez comme premier argument de la fonction sera interprété en tant que regex. Ainsi,\nsearch()\ncorrespondra au mot en début de chaîne et pas au caractère littéral suivi du mot .\n^DEF DEF ^ DEF\n2. https://regexone.com/\n3.\nhttps://regexr.com/\n4. https://extendsclass.com/regex-tester.html#python\n5.\nhttps://pythex.org/\n6. https://www.regular-expressions.info\n178 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n17.3. Le module re Chapitre 17. Expressions régulières et parsing\n17.3.2 Les fonctions et\nmatch() fullmatch()\nIl existe aussi la fonction dans le module qui fonctionne sur le modèle de . La différence est\nmatch() re search()\nqu’elle renvoie un objet du type seulement lorsque la regex correspond au début de la chaîne de caractères\nSRE_Match\n(à partir du premier caractère) :\n1 >>> animaux = \"girafe tigre singe\"\n2\n>>> re.search(\"tigre\", animaux)\n3 <_sre.SRE_Match object at 0x7fefdaefe718>\n4 >>> re.match(\"tigre\", animaux)\n5\n>>>\n6 >>> animaux = \"tigre singe\"\n7\n>>> re.match(\"tigre\", animaux)\n8 <_sre.SRE_Match object; span=(0, 5), match='tigre'>\n9\n>>>\nIl existe également la fonction , qui renvoie un objet du type si et seulement si l’expression\nfullmatch() SRE_Match\nrégulière correspond exactement à la chaîne de caractères.\n1 >>> animaux = \"tigre \"\n2 >>> re.fullmatch(\"tigre\", animaux)\n3\n>>> animaux = \"tigre\"\n4 >>> re.fullmatch(\"tigre\", animaux)\n5\n<_sre.SRE_Match object; span=(0, 5), match='tigre'>\nDe manière générale, nous vous recommandons l’usage de la fonction . Si vous souhaitez avoir une cor-\nsearch()\nrespondance avec le début de la chaîne de caractères comme dans la fonction , vous pouvez toujours utiliser\nmatch()\nl’accroche de début de ligne . Si vous voulez une correspondance exacte, comme dans la fonction , vous\n^ fullmatch()\npouvez utiliser les métacaractères et , par exemple .\n^ $ ^tigre$\n17.3.3 Compilation d’expressions régulières\nLorsqu’on a besoin de tester la même expression régulière sur plusieurs milliers de chaînes de caractères, il est pratique\nde compiler préalablement la regex à l’aide de la fonction , qui renvoie un objet de type :\ncompile() SRE_Pattern\n1\n>>> regex = re.compile(\"^tigre\")\n2 >>> regex\n3\n<_sre.SRE_Pattern object at 0x7fefdafd0df0>\nOn peut alors utiliser directement cet objet avec la méthode :\n.search()\n1 >>> animaux = \"girafe tigre singe\"\n2\n>>> regex.search(animaux)\n3 >>> animaux = \"tigre singe\"\n4\n>>> regex.search(animaux)\n5 <_sre.SRE_Match object at 0x7fefdaefe718>\n6\n>>> animaux = \"singe tigre\"\n7 >>> regex.search(animaux)\n17.3.4 Groupes\nL’intérêt de l’objet de type renvoyé par Python lorsqu’une regex trouve une correspondance dans une\nSRE_Match\nchaîne de caractères est de pouvoir ensuite récupérer certaines zones précises :\n1 >>> regex = re.compile(\"([0-9]+)\\.([0-9]+)\")\nDans cet exemple, on recherche un nombre décimal, c’est-à-dire une chaîne de caractères :\n•\nqui débute par un ou plusieurs chiffres ,\n[0-9]+\n•\nsuivi d’un point (le point a d’habitude une signification de métacaractère, donc il faut l’échapper avec pour\n\\. \\\nqu’il retrouve sa signification de point),\n•\net qui se termine encore par un ou plusieurs chiffres .\n[0-9]+\nLes parenthèses dans la regex créent des groupes ( deux fois) qui seront récupérés ultérieurement par la\n[0-9]+\nméthode .\n.group()\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 179\nChapitre 17. Expressions régulières et parsing 17.3. Le module re\n1\n>>> resultat = regex.search(\"pi vaut 3.14\")\n2 >>> resultat.group(0)\n3\n'3.14'\n4 >>> resultat.group(1)\n5\n'3'\n6 >>> resultat.group(2)\n7 '14'\n8\n>>> resultat.start()\n9 8\n10\n>>> resultat.end()\n11 12\nLa totalité de la correspondance est donnée par , le premier élément entre parenthèses est donné par\n.group(0)\net le second par .\n.group(1) .group(2)\nLes méthodes et donnent respectivement la position de début et de fin de la zone qui correspond\n.start() .end()\nà la regex. Notez que la méthode ne renvoie que la première zone qui correspond à l’expression régulière,\n.search()\nmême s’il en existe plusieurs :\n1\n>>> resultat = regex.search(\"pi vaut 3.14 et e vaut 2.72\")\n2 >>> resultat.group(0)\n3\n'3.14'\n17.3.5 La méthode\n.findall()\nPour récupérer chaque zone dans la regex, s’il y en a plusieurs, vous pouvez utiliser la méthode qui\n.findall()\nrenvoie une liste des éléments en correspondance :\n1 >>> regex = re.compile(\"[0-9]+\\.[0-9]+\")\n2\n>>> resultat = regex.findall(\"pi vaut 3.14 et e vaut 2.72\")\n3 >>> resultat\n4\n['3.14', '2.72']\nL’utilisation des groupes entre parenthèses est également possible, ceux-ci sont alors renvoyés sous la forme de tuples :\n1 >>> regex = re.compile(\"([0-9]+)\\.([0-9]+)\")\n2\n>>> resultat = regex.findall(\"pi vaut 3.14 et e vaut 2.72\")\n3 >>> resultat\n4\n[('3', '14'), ('2', '72')]\n17.3.6 La méthode .sub()\nEnfin, la méthode permet d’effectuer des remplacements assez puissants. Par défaut, la méthode\n.sub() .sub(\nremplace toutes les occurrences trouvées par l’expression régulière dans par .\nchaine1, chaine2) chaine2 chaine1\nSi vous souhaitez ne remplacer que les n premières occurrences, utilisez l’argument :\ncount=n\n1 >>> regex = re.compile(\"[0-9]+\\.[0-9]+\")\n2 >>> regex.sub(\"quelque chose\", \"pi vaut 3.14 et e vaut 2.72\")\n3 'pi vaut quelque chose et e vaut quelque chose'\n4 >>> regex.sub(\"quelque chose\", \"pi vaut 3.14 et e vaut 2.72\", count=1)\n5\n'pi vaut quelque chose et e vaut 2.72'\nEncore plus puissant, il est possible d’utiliser dans le remplacement des groupes qui ont été « capturés » avec des\nparenthèses :\n1\n>>> regex = re.compile(\"([0-9]+)\\.([0-9]+)\")\n2 >>> phrase = \"pi vaut 3.14 et e vaut 2.72\"\n3\n>>> regex.sub(\"approximativement \\\\1\", phrase)\n4 'pi vaut approximativement 3 et e vaut vaut approximativement 2'\n5\n>>> regex.sub(\"approximativement \\\\1 (puis .\\\\2)\",phrase)\n6 'pi vaut approximativement 3 (puis .14) et e vaut approximativement 2 (puis .72)'\nSi vous avez capturé des groupes, il suﬀit d’utiliser , (etc.) pour utiliser les groupes correspondants dans la\n\\\\1 \\\\2\nchaîne de caractères substituée. On notera que la syntaxe générale pour récupérer des groupes dans les outils qui gèrent\nles regex est , , etc. Toutefois, Python nous oblige à mettre un deuxième backslash car il y a ici deux niveaux : un\n\\1 \\2\n180 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n17.4. Exercices Chapitre 17. Expressions régulières et parsing\npremier niveau Python où on veut mettre un backslash littéral (donc ), puis un second niveau regex dans lequel on\n\\\\\nveut retrouver . Si cela est confus, retenez seulement qu’il faut mettre un devant le numéro de groupe.\n\\1 \\\\\nEnfin, sachez que la réutilisation d’un groupe précédemment capturé est aussi utilisable lors d’une utilisation classique\nde regex. Par exemple :\n1 >>> re.search(\"(pan)\\\\1\", \"bambi et panpan\")\n2\n<_sre.SRE_Match object; span=(9, 15), match='panpan'>\n3 >>> re.search(\"(pan)\\\\1\", \"le pistolet a fait pan !\")\n4\n>>>\nDans la regex , on capture d’abord le groupe grâce aux parenthèses (il s’agit du groupe 1, puisque\n(pan)\\\\1 (pan)\nc’est le premier jeu de parenthèses), immédiatement suivi du même groupe grâce au . Dans cet exemple, on capture\n\\\\1\ndonc le mot (lignes 1 et 2). Si, par contre, on a une seule occurrence du mot , cette regex ne fonctionne\npanpan pan\npas, ce qui est le cas ligne 3.\nBien sûr, si on avait eu un deuxième groupe, on aurait pu le réutiliser avec , un troisième groupe avec , etc.\n\\\\2 \\\\3\nNous espérons vous avoir convaincu de la puissance du module re et des expressions régulières. Alors, plus de temps\nà perdre, à vos regex !"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n17.4.1 Regex de base\n7\nDans cet exercice, nous allons manipuler le fichier GenBank correspondant au chromosome I de la\nNC_001133.gbk\nlevure Saccharomyces cerevisiae.\nCréez un script :\nregex_genbank.py\n•\nqui recherche le mot en début de ligne dans le fichier GenBank, puis aﬀiche la ligne correspondante ;\nDEFINITION\n•\nqui recherche tous les journaux (mot-clé ) dans lesquels ont été publiés les travaux sur cette séquence,\nJOURNAL\npuis aﬀiche les lignes correspondantes.\nConseil\n•\nUtilisez des regex pour trouver les lignes demandées.\n•\nDes explications sur le format GenBank et des exemples de code sont fournies dans l’annexe A Quelques formats\nde données en biologie.\n17.4.2 Enzyme de restriction\nUne enzyme de restriction est une protéine capable de couper une molécule d’ADN. Cette coupure se fait sur le site\nde restriction de l’ADN qui correspond à une séquence particulière de nucléotides (bases).\nPour chacune des enzymes ci-dessous, déterminez les expressions régulières qui décrivent leurs sites de restriction. Le\nsymbole N correspond aux bases A, T, C ou G. W correspond à A ou T. Y correspond à C ou T. R correspond à A ou G.\nEnzyme Site de restriction\nHinFI GANTC\nEcoRII CCWGG\nBbvBI GGYRCC\nBcoI CYCGRG\nPsp5II RGGWCCY\n7. https://python.sdv.u-paris.fr/data-files/NC_001133.gbk\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 181\nChapitre 17. Expressions régulières et parsing 17.4. Exercices\nEnzyme Site de restriction\nBbvAI GAANNNNTTC\n17.4.3 Nettoyeur d’espaces\n8\nLe fichier contient la célèbre fable de Jean de la Fontaine. Malheureusement, la personne qui\ncigale_fourmi.txt\nl’a recopié a parfois mis plusieurs espaces au lieu d’un seul entre les mots.\nCréez un script qui, grâce à une regex et à la fonction , remplace plusieurs espaces par un\ncigale_fourmi.py sub()\nseul dans le texte ci-dessus. Le nouveau texte, ainsi nettoyé, sera enregistré dans un fichier .\ncigale_fourmi_propre.txt\n17.4.4 Liste des protéines humaines\n9\nTéléchargez le fichier qui contient le protéome humain, c’est-à-dire les séquences de\nhuman-proteome.fasta\nl’ensemble des protéines chez l’Homme. Ce fichier est au format FASTA.\nOn souhaite lister toutes ces protéines et les indexer avec un numéro croissant.\nCréez un script qui :\nliste_proteome.py\n•\nlit le fichier ;\nhuman-proteome.fasta\n•\nextrait, avec une regex, le numéro d’accession de la protéine de toutes les lignes de commentaires des séquences ;\n•\naﬀiche le mot , suivi d’un numéro qui s’incrémente, suivi du numéro d’accession.\nprotein\nVoici un exemple de sortie attendue :\nprotein 00001 O95139\nprotein 00002 O75438\nprotein 00003 Q8N4C6\n[...]\nprotein 20371 Q8IZJ1\nprotein 20372 Q9UKP6\nprotein 20373 Q96HZ7\nConseil\n•\nDes explications sur le format FASTA et des exemples de code sont fournis dans l’annexe A Quelques formats de\ndonnées en biologie.\n•\nLa ligne de commentaire d’une séquence au format FASTA est de la forme\n>sp|O95139|NDUB6_HUMAN NADH dehydrogenase [...]\nElle débute toujours pas le caractère . Le numéro d’accession se situe entre le premier et le second symbole\n> O95139\n(symbole pipe). Attention, il faudra « échapper » ce symbole car il a une signification particulière dans une regex.\n|\n•\nLe numéro qui s’incrémente débutera à 1 et sera aﬀiché sur 5 caractères, avec des 0 à sa gauche si nécessaires\n(formatage ).\n{:05d}\n17.4.5 Le défi du dé-HTMLiseur (exercice +++)\nLe format HTML permet d’aﬀicher des pages web dans un navigateur. Il s’agit d’un langage à balise qui fonctionne\navec des balises ouvrantes et des balises fermantes .\n<balise> </balise>\n10\nCréez un script qui lit le fichier au format HTML et qui renvoie\ndehtmliseur.py fichier_a_dehtmliser.html\nà l’écran tout le texte de ce fichier sans les balises HTML.\nNous vous conseillons tout d’abord d’ouvrir le fichier HTML dans un éditeur de texte et de bien l’observer. N’hésitez\npas à vous aider des sites mentionnés dans les ressources en ligne.\n17.4.6 Nettoyeur de doublons (exercice +++)\n11\nTéléchargez le fichier qui contient des mots répétés deux fois. Par exemple :\nbreves_doublons.txt\n8.\nhttps://python.sdv.u-paris.fr/data-files/cigale_fourmi.txt\n9. https://python.sdv.u-paris.fr/data-files/human-proteome.fasta\n10.\nhttps://python.sdv.u-paris.fr/data-files/fichier_a_dehtmliser.html\n11. https://python.sdv.u-paris.fr/data-files/breves_doublons.txt\n182 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n17.4. Exercices Chapitre 17. Expressions régulières et parsing\nLe cinéma est devenu parlant, la radio radio finira en images.\nLa sardine, c'est un petit petit poisson sans tête qui vit dans l'huile.\n[...]\nÉcrivez un script qui lit le fichier et qui supprime tous les doublons à\note_doublons.py breves_doublons.txt\nl’aide d’une regex. Le script aﬀichera le nouveau texte à l’écran.\nConseil\nUtilisez la méthode .\n.sub()\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 183"
  },
  {
    "title": "Jupyter et ses notebooks",
    "content": "Les notebooks Jupyter sont des cahiers électroniques qui, dans le même document, peuvent rassembler du texte,\ndes images, des formules mathématiques, des tableaux, des graphiques et du code informatique exécutable. Ils sont\nmanipulables interactivement dans un navigateur web.\nInitialement développés pour les langages de programmation Julia, Python et R (d’où le nom Jupyter), les notebooks\nJupyter supportent près de 40 langages différents.\nLa cellule est l’élément de base d’un notebook Jupyter. Elle peut contenir du texte formaté au format Markdown ou\ndu code informatique qui pourra être exécuté.\nVoici un exemple de notebook Jupyter (figure 18.1) :\nCe notebook est constitué de cinq cellules : deux avec du texte en Markdown (la première et la dernière) et trois avec\ndu code Python (légèrement grisées)."
  },
  {
    "title": "Installation",
    "content": "Avec la distribution Miniconda, les notebooks Jupyter s’installent avec la commande :\n$ conda install -c conda-forge -y jupyterlab\nPour être exact, la commande précédente installe un peu plus que les notebooks Jupyter, mais nous verrons cela par\nla suite."
  },
  {
    "title": "JupyterLab",
    "content": "En 2018, le consortium Jupyter a lancé JupyterLab, qui est un environnement complet de programmation et d’analyse\nde données.\nPour obtenir cette interface, lancez la commande suivante depuis un shell :\n$ jupyter lab\nUne nouvelle page devrait s’ouvrir dans votre navigateur web et vous devriez obtenir une interface similaire à la figure\n18.2, avec à gauche un navigateur de fichiers et à droite le « Launcher », qui permet de créer un nouveau notebook\nJupyter, de lancer un terminal ou d’éditer un fichier texte, un fichier Mardown, un script Python…\nL’interface proposée par JupyterLab est très riche. On peut y organiser un notebook Jupyter, un éditeur de fichier\ntexte, un terminal… Les possibilités sont nombreuses et nous vous invitons à explorer cette interface par vous-même.\n184\n18.3. Création d’un notebook Chapitre 18. Jupyter et ses notebooks\nFigure 18.1 – Exemple de notebook Jupyter. Les chiffres entourés désignent les différentes cellules."
  },
  {
    "title": "Création d’un notebook",
    "content": "Pour créer un notebook, cliquez sur le bouton Python 3 situé dans la rubrique Notebook dans le Launcher (figure\n18.3).\nLe notebook fraîchement créé ne contient qu’une cellule vide.\nLa première chose à faire est de donner un nom à votre notebook. Pour cela, cliquer avec le bouton droit de la souris\nsur Untitled.ipynb, en haut du notebook. Si le nom de votre notebook est test.ipynb, alors le fichier test.ipynb sera créé\ndans le répertoire depuis lequel vous avez lancé JupyterLab.\nRemarque\nL’extension .ipynb est l’extension de fichier des notebooks Jupyter.\nVous pouvez entrer des instructions Python dans la première cellule. Par exemple :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 185\nChapitre 18. Jupyter et ses notebooks 18.3. Création d’un notebook\nFigure 18.2 – Interface de JupyterLab.\nFigure 18.3 – Création d’un nouveau notebook.\nFigure 18.4 – Nouveau notebook avec une cellule vide.\n1\na = 2\n2 b = 3\n3\nprint(a+b)\n186 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n18.3. Création d’un notebook Chapitre 18. Jupyter et ses notebooks\nPour exécuter le contenu de cette cellule, vous avez plusieurs possibilités :\n•\nCliquer sur le menu Run, puis Run Selected Cells.\n•\nCliquer sur le bouton ￿ dans la barre de menu au dessus du notebook.\n•\nPresser simultanément les touches Ctrl + Entrée.\nDans tous les cas, vous devriez obtenir un résultat similaire à la figure 18.5. La notation à gauche de la cellule\n[1]\nindique qu’il s’agit de la première cellule de code qui a été exécutée.\nFigure 18.5 – Exécution d’une première cellule.\nPour créer une nouvelle cellule, vous avez, ici encore, plusieurs possibilités :\n•\nCliquer sur l’icône + dans la barre de menu au dessus du notebook.\n•\nCliquer sur la 2e icône à partir de la droite (juste à côté de la poubelle), dans les icônes situées à l’intérieur de la\ncellule, à droite.\nUne nouvelle cellule vide devrait apparaître.\nVous pouvez également créer une nouvelle cellule, en positionnant votre curseur dans la première cellule, puis en\npressant simultanément les touches Alt + Entrée. Si vous utilisez cette combinaison de touches, vous remarquerez que\nle numéro à gauche de la première cellule est passée de à , car vous avez exécuté une nouvelle fois la première\n[1] [2]\ncellule puis créé une nouvelle cellule.\nVous pouvez ainsi créer plusieurs cellules les unes à la suite des autres. Un objet créé dans une cellule antérieure sera\ndisponible dans les cellules suivantes. Par exemple, dans la figure 18.6, nous avons quatre cellules.\nFigure 18.6 – Notebook avec plusieurs cellules de code Python.\nDans un notebook Jupyter, il est parfaitement possible de réexécuter une cellule précédente. Par exemple la première\ncellule, qui porte désormais à sa gauche la numérotation (voir figure 18.7).\n[5]\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 187\nChapitre 18. Jupyter et ses notebooks 18.4. Le format Markdown\nFigure 18.7 – Notebook avec une cellule ré-exécutée.\nAttention\nLa possibilité d’exécuter les cellules d’un notebook Jupyter dans un ordre arbitraire peut prêter à confusion, notamment\nsi vous modifiez la même variable dans plusieurs cellules.\nNous vous recommandons de régulièrement relancer complètement l’exécution de toutes les cellules de votre notebook,\nde la première à la dernière, en cliquant sur le menu Kernel puis Restart Kernel and Run All Cells et enfin de valider le\nmessage Restart Kernel ? en cliquant sur le bouton Restart."
  },
  {
    "title": "Le format Markdown",
    "content": "Dans le tout premier exemple (figure 18.1), nous avons vu qu’il était possible de mettre du texte au format Markdown\ndans une cellule.\nIl faut cependant indiquer à Jupyter que cette cellule est au format Markdown en cliquant sur Code, sous la barre de\nmenu au dessus du notebook, puis en choisissant Markdown.\nLe format Markdown permet de rédiger du texte formaté (gras, italique, liens, titres, images, formules mathéma-\ntiques…) avec quelques balises très simples. Voici un exemple dans un notebook Jupyter (figure 18.8 (A)) et le rendu\nlorsque la cellule est exécutée (figure 18.8 (B)). Notez qu’une cellule Markdown est sur fond blanc (comme sur la figure\n18.8 (B)).\nLe format Markdown permet de rédiger du texte structuré rapidement et simplement. Ce cours est par exemple\ncomplètement rédigé en Markdown. Nous vous conseillons d’explorer les possibilités du Markdown en consultant la page\n1 2\nWikipédia ou directement la page de référence ."
  },
  {
    "title": "Des graphiques dans les notebooks",
    "content": "Un autre intérêt des notebooks Jupyter est de pouvoir y incorporer des graphiques réalisés avec la bibliothèque\nmatplotlib (que nous verrons prochainement).\nVoici un exemple, d’un graphique qui sera présenté dans le chapitre 21 Module Matplotlib (figure 18.9).\nL’instruction n’est pas nécessaire dans les versions récentes de JupyterLab. Mais avec d’an-\n%matplotlib inline\nciennes versions, vous pourriez en avoir besoin pour que les graphiques s’aﬀichent dans le notebook.\n1.\nhttps://fr.wikipedia.org/wiki/Markdown\n2. https://daringfireball.net/projects/markdown/syntax\n188 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n18.6. Les magic commands Chapitre 18. Jupyter et ses notebooks\nRemarque\nPour quitter l’interface JupyterLab, il y a plusieurs possibilités :\n•\nDans le menu en haut à gauche de l’interface, cliquer sur File, puis Shut Down, puis confirmer en cliquant sur le\nbouton Shut Down.\n•\nUne méthode plus radicale est de revenir sur le shell depuis lequel JupyterLab a été lancé, puis de presser deux fois\nde suite la combinaison de touches Ctrl + C."
  },
  {
    "title": "Les magic commands",
    "content": "3\nLa commande précédente ( ) est une magic command. Les magic commands apportent des\n%matplotlib inline\nfonctionnalités supplémentaires dans un notebook. Il en existe beaucoup, nous allons en aborder ici quelques unes.\nRemarque\nDans cette rubrique, nous vous montrerons quelques exemples d’utilisation de magic commands exécutées dans un\nnotebook Jupyter.\n1 Les cellules de code apparaitront de cette manière\n2\ndans un notebook Jupyter, avec des numéros de lignes à gauche.\nLes résultats seront affichés de cette manière,\néventuellement sur plusieurs lignes.\n18.6.1 %whos\nLa commande liste tous les objets (variables, fonctions, modules…) utilisés dans un notebook.\n%whos\nSi une cellule précédente contenait le code :\n1\na = 2\n2 b = 3\n3\n4 def ma_fonction(x, y):\n5\nreturn x + y\n6\n7\nresultat_1 = ma_fonction(a, 10)\n8 resultat_2 = ma_fonction(\"Bonjour\", \"Jupyter\")\nalors l’exécution de :\n1\n%whos\nrenvoie :\nVariable Type Data/Info\n-----------------------------------\na int 2\nb int 3\nma_fonction function <function ma_fonction at 0x7f219c2d04a0>\nresultat_1 int 12\nresultat_2 str BonjourJupyter\n18.6.2 %history\nLa commande liste toutes les commandes Python lancées dans un notebook :\n%history\n1\n%history\n3. https://ipython.readthedocs.io/en/stable/interactive/magics.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 189\nChapitre 18. Jupyter et ses notebooks 18.6. Les magic commands\na = 2\nb = 3\nprint(a + b)\ndef ma_fonction(x, y):\nreturn x + y\nma_fonction(a, 10)\nma_fonction(\"Bonjour\", \"Jupyter\")\n%whos\n%history\n18.6.3 %%time\nLa commande (avec deux symboles ) va mesurer le temps d’exécution d’une cellule. C’est très utile pour\n%%time %\nfaire des tests de performance. On peut, par exemple, comparer les vitesses de parcours d’une liste avec une boucle ,\nfor\npar les éléments ou par les indices des éléments.\nAinsi, cette cellule :\n1 %%time\n2 concentrations = [5.5, 7.2, 11.8, 13.6, 19.1, 21.7, 29.4]\n3\nsomme_carres = 0.0\n4 for conc in concentrations:\n5\nsomme_carres += conc**2\nrenvoie :\nCPU times: user 8 µs, sys: 2 µs, total: 10 µs\nWall time: 11.9 µs\net celle-ci :\n1 %%time\n2\nconcentrations = [5.5, 7.2, 11.8, 13.6, 19.1, 21.7, 29.4]\n3 somme_carres = 0.0\n4\nfor idx in range(len(concentrations)):\n5 somme_carres += concentrations[idx]**2\nrenvoie :\nCPU times: user 26 µs, sys: 5 µs, total: 31 µs\nWall time: 37.4 µs\nComme attendu, la première méthode (itération par les éléments) est plus rapide que la seconde (itération par les\nindices des éléments). Les temps obtenus dépendent de la machine sur laquelle vous exécutez ces commandes. Mais, sur\nune même machine, les résultats peuvent fluctuer d’une exécution à l’autre en fonction de l’activité de la machine. Ces\nfluctuations seront d’autant plus importantes que le temps d’exécution est court.\n18.6.4 %%timeit\nPour palier à ce problème, la magic command va exécuter plusieurs fois la cellule et donner une estimation\n%%timeit\ndu temps d’exécution moyen. Python détermine automatiquement le nombre d’itérations et le nombre de répétitions à\neffectuer pour obtenir un temps global d’exécution raisonnable.\nEn reprenant l’exemple précédent, on obtient :\n1 %%timeit\n2\nconcentrations = [5.5, 7.2, 11.8, 13.6, 19.1, 21.7, 29.4]\n3 somme_carres = 0.0\n4\nfor conc in concentrations:\n5 somme_carres += conc**2\n492 ns ± 11.8 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\net\n190 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n18.7. Lancement d’une commande Unix Chapitre 18. Jupyter et ses notebooks\n1\n%%timeit\n2 concentrations = [5.5, 7.2, 11.8, 13.6, 19.1, 21.7, 29.4]\n3\nsomme_carres = 0.0\n4 for idx in range(len(concentrations)):\n5\nsomme_carres += concentrations[idx]**2\n606 ns ± 21.6 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)\nIci, chaque cellule sera exécutée un million de fois sur sept répétitions, soit sept millions de fois au total. Comme\nnous l’avions expliqué dans le chapitre 5 Boucles et comparaisons, itérer une liste sur ses éléments est la méthode la plus\neﬀicace (et la plus élégante)."
  },
  {
    "title": "Lancement d’une commande Unix",
    "content": "Enfin, dans les environnements Linux ou Mac OS X, il est possible de lancer une commande Unix depuis un notebook\nJupyter. Il faut pour cela faire précéder la commande du symbole « ». Par exemple, la commande aﬀiche le contenu\n! ls\ndu répertoire courant :\n1 !ls\njupyter-exemple.ipynb markdown.ipynb test.ipynb\njupyter-logo.png matplotlib.ipynb\nPour aller plus loin\nLe lancement d’une commande Unix depuis un notebook Jupyter (en précédant cette commande de ) est très utile\n!\n4\npour réaliser de grosses analyses de données. Pour vous en rendre compte, explorez ce notebook qui reproduit une analyse\ncomplète de données de séquençage haut débit. Ces résultats ont donné lieu à la publication de l’article scientifique «\n5\nAn open RNA-Seq data analysis pipeline tutorial with an example of reprocessing data from a recent Zika virus study\n» (F1000 Research, 2016).\nConseil\nLes notebooks Jupyter sont particulièrement adaptés à l’analyse de données en combinaison avec les modules mat-\nplotlib et pandas, qui seront abordés dans les prochains chapitres.\n4.\nhttps://github.com/MaayanLab/Zika-RNAseq-Pipeline/blob/master/Zika.ipynb\n5. https://f1000research.com/articles/5-1574/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 191\nChapitre 18. Jupyter et ses notebooks 18.7. Lancement d’une commande Unix\nFigure 18.8 – Notebook avec : (A) une cellule au format Markdown et (B) le rendu après exécution.\n192 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n18.7. Lancement d’une commande Unix Chapitre 18. Jupyter et ses notebooks\nFigure 18.9 – Incorporation d’un graphique dans un notebook Jupyter.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 193"
  },
  {
    "title": "Module Biopython",
    "content": "1\nNous allons aborder dans ce chapitre un module incontournable en bioinformatique. En effet, le module Biopython\npermet de manipuler des données biologiques, comme des séquences (nucléiques et protéiques) ou des structures (fichiers\n2\nPDB), et d’interroger des bases de données comme PubMed. Le tutoriel est particulièrement bien fait, n’hésitez pas à\nle consulter."
  },
  {
    "title": "Installation et convention",
    "content": "Contrairement aux autres modules vus précédemment, Biopython n’est pas fourni avec la distribution Python de base.\n3\nAvec la distribution Miniconda que nous vous conseillons d’utiliser (consultez pour cela la documentation en ligne ),\nvous pouvez rapidement l’installer avec la commande :\n$ conda install -c conda-forge biopython\nDans ce chapitre, nous vous montrerons quelques exemples d’utilisation du module Biopython pour vous convaincre\nde sa pertinence. Ces exemples seront exécutés dans un notebook Jupyter.\n1\nLes cellules de code apparaitront de cette manière\n2 dans un notebook Jupyter, avec des numéros de lignes à gauche.\nLes résultats seront affichés de cette manière,\néventuellement sur plusieurs lignes."
  },
  {
    "title": "Chargement du module",
    "content": "On charge le module Biopython avec la commande :\n1 import Bio\nAttention\nLe nom du module Biopython n’est pas , mais (avec un B majuscule).\nbiopython Bio\n1. http://biopython.org/\n2.\nhttp://biopython.org/DIST/docs/tutorial/Tutorial.html\n3. https://python.sdv.u-paris.fr/livre-dunod\n194\n19.3. Manipulation de séquences Chapitre 19. Module Biopython"
  },
  {
    "title": "Manipulation de séquences",
    "content": "Voici quelques exemples de manipulation de séquences avec Biopython.\n19.3.1 Définition d’une séquence\n1 import Bio\n2\nfrom Bio.Seq import Seq\n3 ADN = Seq(\"ATATCGGCTATAGCATGC\")\n4\nADN\nSeq('ATATCGGCTATAGCATGC')\n•\nLigne 1. Le module Biopython s’appelle .\nBio\n•\nLigne 2. On charge la classe du sous-module .\nSeq Bio.Seq\n•\nLigne 3. La variable est de type , comme aﬀiché dans le résultat.\nADN Seq\n19.3.2 Obtention de la séquence complémentaire et de la séquence complémentaire inverse\n1\nADN.complement()\nSeq('TATAGCCGATATCGTACG')\n1 ADN.reverse_complement()\nSeq('GCATGCTATAGCCGATAT')\n19.3.3 Traduction en séquence protéique\n1\nADN.translate()\nSeq('ISAIAC')\nConseil\nDans l’annexe A Quelques formats de données en biologie, vous trouverez de nombreux exemples d’utilisation de\nBiopython pour manipuler des données aux formats FASTA, GenBank et PDB."
  },
  {
    "title": "Interrogation de la base de données PubMed",
    "content": "Le sous-module Entrez de Biopython permet d’utiliser les ressources du NCBI et notamment d’interroger la base\n4\nde données PubMed . Nous allons par exemple utiliser PubMed pour chercher des articles scientifiques relatifs à la\ntransferrine (transferrin en anglais) :\n1\nfrom Bio import Entrez\n2 Entrez.email = \"votremail@provider.fr\"\n3\nreq_esearch = Entrez.esearch(db=\"pubmed\", term=\"transferrin\")\n4 res_esearch = Entrez.read(req_esearch)\n•\nLigne 1. On charge directement le sous-module Entrez.\n•\nLigne 2. Lors d’une requête sur le site du NCBI, il est important de définir correctement la variable ,\nEntrez.email\nqui sera transmise au NCBI lors de la requête et qui pourra être utilisée pour vous contacter en cas de diﬀiculté\navec le serveur.\n4. https://www.ncbi.nlm.nih.gov/pubmed/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 195\nChapitre 19. Module Biopython 19.4. Interrogation de la base de données PubMed\n•\nLigne 3. On lance la requête ( ) sur le moteur de recherche . La requête est stockée dans la\ntransferrin pubmed\nvariable .\nreq_esearch\n•\nLigne 4. Le résultat est lu et stocké dans la variable .\nres_esearch\nSans être un vrai dictionnaire, la variable en a cependant plusieurs propriétés. Voici ses clés :\nres_esearch\n1 res_esearch.keys()\ndict_keys(['Count', 'RetMax', 'RetStart', 'IdList', 'TranslationSet',\n'TranslationStack', 'QueryTranslation'])\nLa valeur associée à la clé est une liste qui contient les identifiants (PMID) des articles scientifiques associés\nIdList\nà la requête (ici ) :\ntransferrin\n1\nres_esearch[\"IdList\"]\n['30411489', '30409795', '30405884', '30405827', '30402883', '30401570',\n'30399508', '30397276', '30395963', '30394734', '30394728', '30394123',\n'30393423', '30392910', '30392664', '30391706', '30391651', '30391537',\n'30391296', '30390672']\n1\nlen(res_esearch[\"IdList\"])\n20\nCette liste ne contient les identifiants que de 20 publications, alors que, si nous faisons cette même requête directement\nsur le site de PubMed depuis un navigateur web, nous obtenons plus de 45 700 résultats.\nEn réalité, le nombre exact de publications (en janvier 2024) est connu :\n1 res_esearch[\"Count\"]\n'45717'\nPour ne pas saturer les serveurs du NCBI, seulement 20 PMID sont renvoyés par défaut. Mais vous pouvez augmenter\ncette limite en utilisant le paramètre dans la fonction .\nretmax Entrez.esearch()\nNous pouvons maintenant récupérer des informations sur une publication précise en connaissant son PMID, par\n5\nexemple, l’article avec le PMID 22294463 , dont un aperçu est sur la figure 19.1.\nFigure 19.1 – Aperçu de la publication Known and potential roles of transferrin in iron biology depuis le site PubMed.\nNous allons pour cela utiliser la fonction\nEntrez.esummary()\n5. https://www.ncbi.nlm.nih.gov/pubmed/22294463\n196 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n19.4. Interrogation de la base de données PubMed Chapitre 19. Module Biopython\n1\nreq_esummary = Entrez.esummary(db=\"pubmed\", id=\"22294463\")\n2 res_esummary = Entrez.read(req_esummary)\nLa variable n’est pas réellement une liste (son type exacte est ),\nres_esummary Bio.Entrez.Parser.ListElement\nmais elle est indexable (voir chapitre 14 Conteneurs). Cette pseudo-liste n’a qu’un seul élément, qui est lui-même un\ndictionnaire dont voici les clés :\n1 res_esummary[0].keys()\ndict_keys(['Item', 'Id', 'PubDate', 'EPubDate', 'Source', 'AuthorList',\n'LastAuthor', 'Title', 'Volume', 'Issue', 'Pages', 'LangList',\n'NlmUniqueID', 'ISSN', 'ESSN', 'PubTypeList', 'RecordStatus', 'PubStatus',\n'ArticleIds', 'DOI', 'History', 'References', 'HasAbstract', 'PmcRefCount',\n'FullJournalName', 'ELocationID', 'SO'])\nNous pouvons alors facilement obtenir le titre, le DOI et la date de publication ( ) de cet article, ainsi que le\nPubDate\njournal ( ) dans lequel il a été publié :\nSource\n1 res_esummary[0][\"Title\"]\n'Known and potential roles of transferrin in iron biology.'\n1\nres_esummary[0][\"DOI\"]\n'10.1007/s10534-012-9520-3'\n1 res_esummary[0][\"PubDate\"]\n'2012 Aug'\n1\nres_esummary[0][\"Source\"]\n'Biometals'\nEnfin, pour récupérer le résumé de la publication précédente, nous allons utiliser la fonction :\nEntrez.efetch()\n1 req_efetch = Entrez.efetch(\n2\ndb=\"pubmed\", id=\"22294463\",\n3 rettype=\"abstract\", retmode=\"text\")\n4\nreq_efetch.read()\n'1. Biometals. 2012 Aug;25(4):677-86. doi: 10.1007/s10534-012-9520-3.\n\\n\\nKnown and potential roles of transferrin in iron biology.\\n\\nBart\nnikas TB(1).\\n\\nAuthor information:\\n(1)Department of Pathology, Chil’\ndrens Hospital, Enders 1110, 300 Longwood \\nAvenue, Boston, MA 02115\n, USA. mas.Bartnikas@childrens.harvard.edu\\n\\nTransferrin is an abund\nant serum metal-binding protein best known for its role \\nin iron del\n[...]\nLe résultat n’est pas très lisible, car il apparait comme un seul bloc. Le caractère désigne un retour à la ligne.\n\\n\nL’instruction aﬀichera le résultat de manière plus lisible :\nprint()\n1 req_efetch = Entrez.efetch(\n2\ndb=\"pubmed\", id=\"22294463\",\n3 rettype=\"abstract\", retmode=\"text\")\n4\nprint(req_efetch.read())\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 197\nChapitre 19. Module Biopython 19.5. Exercices\n1. Biometals. 2012 Aug;25(4):677-86. doi: 10.1007/s10534-012-9520-3.\nKnown and potential roles of transferrin in iron biology.\nBartnikas TB(1).\nAuthor information:\n(1)Department of Pathology, ’Childrens Hospital, Enders 1110, 300 Longwood\nAvenue, Boston, MA 02115, USA. mas.Bartnikas@childrens.harvard.edu\nTransferrin is an abundant serum metal-binding protein best known for its role\nin iron delivery. The human disease congenital atransferrinemia and animal\nmodels of this disease highlight the essential role of transferrin in\nerythropoiesis and iron metabolism. Patients and mice deficient in transferrin\nexhibit anemia and a paradoxical iron overload attributed to deficiency in\nhepcidin, a peptide hormone synthesized largely by the liver that inhibits\ndietary iron absorption and macrophage iron efflux. Studies of inherited human\ndisease and model organisms indicate that transferrin is an essential regulator\nof hepcidin expression. In this paper, we review current literature on\ntransferrin deficiency and present our recent findings, including potential\noverlaps between transferrin, iron and manganese in the regulation of hepcidin\nexpression.\nDOI: 10.1007/s10534-012-9520-3\nPMCID: PMC3595092\nPMID: 22294463 [Indexed for MEDLINE]\nLe résultat contient bien le résumé de la figure 19.1, mais aussi d’autres informations comme le titre, le DOI, la date\nde publication…"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, utilisez des notebooks Jupyter.\n19.5.1 Pourcentage de GC de gènes de Plasmodium falciparum\nPlasmodium falciparum (P. falciparum) est un des parasites responsables du paludisme chez les êtres humains. Le\n6\nfichier contient 500 gènes du génome de P. falciparum.\np_falciparum_500.fasta\nÉcrivez un code Python qui calcule le pourcentage de GC de chaque gène. Les valeurs seront stockées dans un\ndictionnaire, avec comme clés les identifiants des gènes et comme valeurs le pourcentage de GC.\nOn rappelle que le pourcentage de GC d’une séquence est calculé avec la formule suivante :\nnombre de bases G+nombre de bases C\n×\npourcentage GC = 100\nlongueur de la séquence\nAﬀichez ensuite :\n•\nLe nombre total de gènes.\n•\nL’identifiant de la séquence qui a le pourcentage de GC le plus élevé, avec la valeur du pourcentage aﬀichée avec\ndeux chiffres après la virgule.\n•\nL’identifiant de la séquence qui a le pourcentage de GC le plus faible, avec la valeur du pourcentage aﬀichée avec\ndeux chiffres après la virgule.\nConseil\nPour cet exercice, n’hésitez pas à consulter :\n•\nLe chapitre 14 Conteneurs pour trier un dictionnaire.\n•\nL’annexe A Quelques formats de données en biologie pour lire un fichier FASTA avec Biopython.\n6. https://python.sdv.u-paris.fr/data-files/p_falciparum_500.fasta\n198 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n19.5. Exercices Chapitre 19. Module Biopython\n19.5.2 Années de publication des articles relatifs à la barstar\nL’objectif de cet exercice est d’interroger automatiquement la base de données bibliographique PubMed pour déter-\nminer le nombre d’articles relatifs à la protéine barstar publiés chaque année.\nVous utiliserez le module Biopython et le module matplotlib, qui sera vu un peu plus loin (les principales instructions\nvous seront fournies).\n19.5.2.1 Requête avec un mot-clé\n7\nSur le site de PubMed , cherchez combien d’articles scientifiques sont relatifs à la barstar.\nEffectuez la même chose avec Python et la méthode de Biopython.\nEntrez.esearch()\nChoisissez un des PMID renvoyé et vérifiez dans PubMed que l’article associé est bien à propos de la barstar. Pour\ncela, indiquez le PMID choisi dans la barre de recherche de PubMed et cliquez sur Search. Attention, l’association n’est\npas toujours évidente. Cherchez éventuellement dans le résumé de l’article si besoin.\nEst-ce que le nombre total d’articles trouvés est cohérent avec celui obtenu sur le site de PubMed ?\n19.5.2.2 Récupération des informations d’une publication\n8\nRécupérez les informations de la publication dont le PMID est 29701945 . Vous utiliserez la méthode\nEntrez.\n.\nesummary()\nAﬀichez le titre, le DOI, le nom du journal ( ) et la date de publication ( ) de cet article. Vérifiez que\nSource PubDate\ncela correspond bien à ce que vous avez lu sur PubMed.\n19.5.2.3 Récupération du résumé d’une publication\nRécupérez le résumé de la publication dont le PMID est 29701945. Vous utiliserez la méthode .\nEntrez.efetch()\nAﬀichez ce résumé.\n19.5.2.4 Distribution des années de publication des articles relatifs à la barstar\nEn utilisant la méthode , récupérez tous les PMID relatifs à la barstar. Pour cela, pensez à\nEntrez.esearch()\naugmenter le paramètre . Vos PMID seront stockés dans la liste sous forme de chaînes de caractères.\nretmax pmids\nVérifiez sur PubMed que vous avez récupéré le bon nombre d’articles.\nEn utilisant maintenant la méthode dans une boucle, récupérez la date de publication de\nEntrez.esummary()\nchaque article. Stockez l’année sous forme d’un nombre entier dans la liste . Cette étape peut prendre une dizaine\nyears\nde minutes, soyez patient. Vous pouvez aﬀicher dans votre boucle un message qui indique où vous en êtes dans la\nrécupération des articles.\nVérifiez que votre liste contient bien autant d’éléments que la liste .\nyears pmids\nCalculez maintenant le nombre de publications par année. Vous créerez pour cela un dictionnaire qui aura pour\nfreq\nclé les années (oui, une clé de dictionnaire peut aussi être un entier) et pour valeur le nombre de publications associées\nà une année donnée.\nCréez une liste qui contient les clés du dictionnaire . Ordonnez les valeurs dans avec la méthode .\nx freq x .sort()\nCréez maintenant une seconde liste qui contient, dans l’ordre, le nombre de publications associées à chaque année. Bien\ny\névidemment, les listes et doivent avoir la même taille. Au fait, en quelle année la barstar apparaît pour la première\nx y\nfois dans une publication scientifique ?\nEnsuite, avec le module matplotlib (que nous aborderons prochainement), vous allez pouvoir aﬀicher la distribution\ndes publications en fonction des années :\n7.\nhttps://www.ncbi.nlm.nih.gov/pubmed/\n8. https://www.ncbi.nlm.nih.gov/pubmed/29701945\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 199\nChapitre 19. Module Biopython 19.5. Exercices\n1\nimport matplotlib.pyplot as plt\n2\n3\nfig, ax = plt.subplots()\n4 ax.bar(x, y)\nVous pouvez également ajouter un peu de cosmétique et enregistrer le graphique sur votre disque dur :\n1 import matplotlib.pyplot as plt\n2\n3 fig, ax = plt.subplots()\n4\nax.bar(x, y)\n5\n6 # Étiquetage des axes.\n7\nax.set_xlabel(\"Années\")\n8 ax.set_ylabel(\"Nombre de publications\")\n9\n10\n# Ajout du titre du graphique.\n11 ax.set_title(\"Distribution des publications qui mentionnent la barstar\")\n12\n13 # Enregistrement sur le disque.\n14\nfig.savefig(\"distribution_barstar_annee.png\")\n200 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Module NumPy",
    "content": "1\nLe module NumPy est incontournable en bioinformatique. Il permet d’effectuer des calculs sur des vecteurs ou des\nmatrices, élément par élément, via un nouveau type d’objet appelé array."
  },
  {
    "title": "Installation et convention",
    "content": "Contrairement aux modules vus précédemment, NumPy n’est pas fourni avec la distribution Python de base. Avec la\n2\ndistribution Miniconda que nous vous conseillons d’utiliser (consultez pour cela la documentation en ligne ), vous pouvez\nrapidement l’installer avec la commande :\n$ conda install -c conda-forge numpy\nDans ce chapitre, nous vous montrerons quelques exemples d’utilisation du module NumPy pour vous convaincre de\nsa pertinence. Ces exemples seront exécutés dans un notebook Jupyter.\n1 Les cellules de code apparaitront de cette manière\n2 dans un notebook Jupyter, avec des numéros de lignes à gauche.\nLes résultats seront affichés de cette manière,\néventuellement sur plusieurs lignes."
  },
  {
    "title": "Chargement du module",
    "content": "On charge le module NumPy avec la commande :\n1 import numpy\nPar convention, on utilise comme nom raccourci pour NumPy :\nnp\n1 import numpy as np"
  },
  {
    "title": "Objets de type array",
    "content": "Les objets de type array correspondent à des tableaux à une ou plusieurs dimensions et permettent d’effectuer du\ncalcul vectoriel. La fonction convertit un conteneur (comme une liste ou un tuple) en un objet de type array.\narray()\n1.\nhttp://numpy.scipy.org/\n2. https://python.sdv.u-paris.fr/livre-dunod\n201\nChapitre 20. Module NumPy 20.3. Objets de type array\nVoici un exemple de conversion d’une liste à une dimension en objet array :\n1 import numpy as np\n2\na = [1, 2, 3]\n3 np.array(a)\narray([1, 2, 3])\n1\nb = np.array(a)\n2 b\narray([1, 2, 3])\n1\ntype(b)\nnumpy.ndarray\nNous avons converti la liste en array. La fonction accepte aussi comme argument un tuple,\n[1, 2, 3] np.array()\nou un objet de type range.\nPar ailleurs, lorsqu’on demande à Python d’aﬀicher le contenu d’un objet array, le mot et les symboles et\narray ([\nsont utilisés pour le distinguer d’une liste (délimitée par les caractères et ) ou d’un tuple (délimité par les caractères\n]) [ ]\net ).\n( )\nRemarque\nUn objet array ne contient que des données homogènes, c’est-à-dire d’un type identique. Il est possible de créer un\nobjet array à partir d’une liste contenant des entiers et des chaînes de caractères, mais, dans ce cas, toutes les valeurs\nseront comprises par NumPy comme des chaînes de caractères :\n1 a = np.array([1, 2, \"tigre\"])\n2\na\narray(['1', '2', 'tigre'], dtype='<U21')\nDans cet exemple, toutes les valeurs du array sont entre guillemets, indiquant qu’il s’agit de chaînes de caractères.\nDe même, il est possible de créer un objet array à partir d’une liste constituée d’entiers et de floats, mais toutes les\nvaleurs seront alors comprises par NumPy comme des floats :\n1 b = np.array([1, 2, 3.5])\n2\nb\narray([1. , 2. , 3.5])\nIci, la notation indique qu’il s’agit du float et pas de l’entier .\n1. 1.0000... 1\nSur un modèle similaire à la fonction , la fonction permet de construire un array à une dimension :\nrange() arange()\n1\nnp.arange(10)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nComme avec , on peut spécifier en argument une borne de début, une borne de fin et un pas :\nrange()\n1\nnp.arange(10, 0, -1)\narray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])\n202 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.3. Objets de type array Chapitre 20. Module NumPy\nUn autre avantage de la fonction est qu’elle génère des objets array qui contiennent des entiers ou des\narange()\nfloats (ce qui n’est pas possible avec ) selon l’argument qu’on lui passe. D’abord un entier :\nrange()\n1\nnp.arange(10)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nPuis un float :\n1\nnp.arange(10.0)\narray([ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])\nLa différence fondamentale entre un objet array à une dimension et une liste (ou un tuple) est que celui-ci est\nconsidéré comme un vecteur. Par conséquent, on peut effectuer des opérations vectorielles élément par élément sur\nce type d’objet, ce qui est bien commode lorsqu’on analyse de grandes quantités de données. Regardez ces exemples :\n1\nv = np.arange(4)\n2 v\narray([0, 1, 2, 3])\nOn ajoute à chacun des éléments de l’array :\n1 v\n1 v + 1\narray([1, 2, 3, 4])\nOn multiplie par chacun des éléments de l’array :\n2 v\n1\nv * 2\narray([0, 2, 4, 6])\nAvec les listes, ces opérations n’auraient été possibles qu’en utilisant des boucles. Nous vous encourageons donc à\nutiliser dorénavant les objets array lorsque vous aurez besoin de faire des opérations élément par élément.\nIl est aussi possible de multiplier deux arrays entre eux. Le résultat correspond alors à la multiplication élément par\nélément des deux arrays initiaux :\n1 v * v\narray([0, 1, 4, 9])\n20.3.1 Array et dimensions\nIl est aussi possible de construire des objets arrays à deux dimensions, il suﬀit de passer en argument une liste de\nlistes à la fonction :\narray()\n1\nw = np.array([[1, 2], [3, 4], [5, 6]])\n2 w\narray([[1, 2],\n[3, 4],\n[5, 6]])\nOn peut aussi créer des tableaux à trois dimensions en passant comme argument à la fonction une liste de\narray()\nlistes de listes :\n1 x = np.array([[[1, 2], [2, 3]], [[4, 5], [5, 6]]])\n2\nx\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 203\nChapitre 20. Module NumPy 20.3. Objets de type array\narray([[[1, 2],\n[2, 3]],\n[[4, 5],\n[5, 6]]])\nLa fonction peut créer des tableaux à n’importe quel nombre de dimensions. Toutefois, cela devient vite\narray()\ncompliqué lorsqu’on dépasse trois dimensions. Retenez qu’un objet array à une dimension peut être assimilé à un vecteur,\nun array à deux dimensions à une matrice. On peut généraliser ces objets mathématiques avec un nombre arbitraires de\ndimensions, on parle alors de tenseur, qui sont représentés avec NumPy en array à n dimensions. Nous nous focaliserons\ndans la suite sur des arrays à une dimension (1D) ou deux dimensions (2D).\nAvant de continuer, il est important de définir comment sont organisés ces arrays 2D qui représentent des matrices.\nIl s’agit de tableaux de nombres qui sont organisés en lignes et en colonnes comme le montre la figure 20.1. Les indices\nindiqués dans cette figure seront définis un peu plus loin dans la rubrique Indices.\nFigure 20.1 – Définition des lignes et colonnes dans un array 2D.\nVoici quelques attributs intéressants pour décrire un objet array :\n1 v = np.arange(4)\n2\nv\narray([0, 1, 2, 3])\n1\nw = np.array([[1, 2], [3, 4], [5, 6]])\n2 w\narray([[1, 2],\n[3, 4],\n[5, 6]])\nL’attribut renvoie le nombre de dimensions de l’array. Par exemple, 1 pour un vecteur et 2 pour une matrice :\n.ndim\n1\nv.ndim\n1\n1\nw.ndim\n204 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.3. Objets de type array Chapitre 20. Module NumPy\n2\nL’attribut renvoie les dimensions sous forme d’un tuple. Dans le cas d’une matrice (array à deux dimensions),\n.shape\nla première valeur du tuple correspond au nombre de lignes et la seconde au nombre de colonnes.\n1 v.shape\n(4,)\n1 w.shape\n(3, 2)\nEnfin, l’attribut renvoie le nombre total d’éléments contenus dans l’ :\n.size array\n1\nv.size\n4\n1\nw.size\n6\n20.3.2 Redimensionnement d’array\nLa méthode renvoie un nouvel array avec les dimensions spécifiées en argument :\n.reshape()\n1 a = np.arange(0, 6)\n2\na\narray([0, 1, 2, 3, 4, 5])\n1\na.shape\n(6,)\n1\nb = a.reshape((2, 3))\n2 b\narray([[0, 1, 2],\n[3, 4, 5]])\n1\nb.shape\n(2, 3)\n1\na\narray([0, 1, 2, 3, 4, 5])\nNotez bien que l’array initial n’a pas été modifié et que n’est pas la même chose que\na a.reshape((2, 3))\n:\na.reshape((3, 2))\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 205\nChapitre 20. Module NumPy 20.3. Objets de type array\n1\nc = a.reshape((3, 2))\n2 c\narray([[0, 1],\n[2, 3],\n[4, 5]])\n1 c.shape\n(3, 2)\nLa méthode attend que les nouvelles dimensions soient compatibles avec la dimension initiale de\n.reshape()\nl’objet array, c’est-à-dire que le nombre d’éléments contenus dans les différents arrays soit le même. Dans nos exemples\n× ×\nprécédents, 6 = 2 3 = 3 2.\nSi les nouvelles dimensions ne sont pas compatibles avec les dimensions initiales, la méthode génère une\n.reshape()\nerreur.\n1 a = np.arange(0, 6)\n2\na\narray([0, 1, 2, 3, 4, 5])\n1 a.shape\n(6,)\n1 d = a.reshape((3, 4))\n---------------------------------------------------------------------------\nValueError Traceback (most recent call last)\nCell In[36], line 1\n----> 1 d = a.reshape((3, 4))\nValueError: cannot reshape array of size 6 into shape (3,4)\nLa méthode , par contre, ne déclenche pas d’erreur dans une telle situation et ajoute des 0 jusqu’à ce que\n.resize()\nle nouvel array soit rempli, ou bien coupe la liste initiale :\n1\na = np.arange(0, 6)\n2 a.shape\n(6,)\n1 a.resize((3, 3), refcheck=False)\n2\na.shape\n(3, 3)\n1 a\narray([[0, 1, 2],\n[3, 4, 5],\n[0, 0, 0]])\n206 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.3. Objets de type array Chapitre 20. Module NumPy\n1\nb = np.arange(0, 10)\n2 b.shape\n(10,)\n1\nb.resize((2, 3), refcheck=False)\n2 b.shape\n(2, 3)\n1\nb\narray([[0, 1, 2],\n[3, 4, 5]])\nAttention\n•\nCette modification de la forme de l’array par la méthode est faite « sur place » (in place), c’est-à-dire\n.resize()\nque la méthode ne renvoie rien, mais l’array initial est bel et bien modifié (comme des méthodes sur les listes telles\nque la méthode , voir le chapitre 13 Plus sur les listes).\n.reverse()\n•\nSi l’option n’est pas présente, Python peut parfois renvoyer une erreur s’il existe des références\nrefcheck=False\nvers l’array qu’on souhaite modifier.\nEnfin, il existe la fonction qui, dans le cas d’un nouvel array plus grand que l’array initial, va répéter\nnp.resize()\nl’array initial afin de remplir les cases manquantes :\n1\na = np.arange(0, 6)\n2 a.shape\n(6,)\n1 c = np.resize(a, (3, 5))\n2\nc.shape\n(3, 5)\n1 c\narray([[0, 1, 2, 3, 4],\n[5, 0, 1, 2, 3],\n[4, 5, 0, 1, 2]])\n1\na\narray([0, 1, 2, 3, 4, 5])\nNotez que la fonction renvoie un nouvel array mais ne modifie pas l’array initial, contrairement à la\nnp.resize()\nméthode , décrite ci-dessus.\n.resize()\nRemarque\nDepuis le début de ce chapitre, nous avons toujours montré l’aﬀichage d’un array tel quel dans un notebook Jupyter :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 207\nChapitre 20. Module NumPy 20.3. Objets de type array\n1\na = np.array(range(10))\n2 a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n1\na2 = np.ones((3, 3))\n2 a2\narray([[1., 1., 1.],\n[1., 1., 1.],\n[1., 1., 1.]])\nNous avons déjà indiqué que Python aﬀiche systématiquement le mot array ainsi que les parenthèses, crochets et\nvirgules pour séparer les éléments. Toutefois, si vous utilisez la fonction , l’aﬀichage sera différent. Le mot array,\nprint()\nles parenthèses et les virgules disparaissent :\n1 print(a)\n[0 1 2 3 4 5 6 7 8 9]\n1\nprint(a2)\n[[1. 1. 1.]\n[1. 1. 1.]\n[1. 1. 1.]]\nCeci peut amener des confusions, en particulier entre un array 1D :\n[0 1 2 3 4 5 6 7 8 9]\net une liste contenant les mêmes éléments :\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nDans ce cas, seule la présence ou l’absence de virgules permet de savoir s’il s’agit d’un array ou d’une liste.\n20.3.3 Méthodes de calcul sur les arrays et l’argument\naxis\nChaque array NumPy possède une multitude de méthodes. Nombre d’entre elles permettent de faire des calculs de\nbase comme pour la moyenne, pour la somme, pour l’écart-type, pour extraire le\n.mean() .sum() .std() .max()\n3\nmaximum, pour extraire le minimum, etc. La liste exhaustive est disponible en ligne . Par défaut, chacune de\n.min()\nces méthodes effectuera l’opération sur l’array entier, quelle que soit sa dimensionnalité. Par exemple :\n1\nimport random\n2 ma_liste = list(range(8))\n3\nrandom.shuffle(ma_liste)\n4 ma_liste\n[2, 7, 6, 4, 0, 3, 1, 5]\n1\na = np.resize(ma_liste, (4, 2))\n2 a\n3. https://numpy.org/doc/stable/reference/arrays.ndarray.html#calculation\n208 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.3. Objets de type array Chapitre 20. Module NumPy\narray([[2, 7],\n[6, 4],\n[0, 3],\n[1, 5]])\n1 a.max()\n7\nLa méthode a bien renvoyé la valeur maximale 7. Un argument très utile existant dans toutes ces méthodes\n.max()\nest . Pour un array 2D, signifie qu’on fera l’opération le long de l’axe 0, à savoir les lignes. C’est-à-dire que\naxis axis=0\nl’opération se fait en variant les lignes. On récupère ainsi une valeur par colonne :\n1\na.max(axis=0)\narray([6, 7])\nDans l’array 1D récupéré, le premier élément vaut 6 (maximum de la 1ère colonne) et le second vaut 7 (maximum\nde la seconde colonne).\nAvec , on fait une opération similaire, mais en faisant varier les colonnes. On récupère ainsi une valeur par\naxis=1\nligne :\n1\na.max(axis=1)\narray([7, 6, 3, 5])\nL’array 1D récupéré a quatre éléments correspondant au maximum de chaque ligne.\nOn comprend la puissance de l’argument . À nouveau, il est possible, en une ligne, de faire des calculs qui\naxis\npourraient être fastidieux avec les listes traditionnelles.\n20.3.4 Indices\nPour récupérer un ou plusieurs élément(s) d’un objet array, vous pouvez utiliser les indices, de la même manière\nqu’avec les listes :\n1\na = np.arange(10)\n2 a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n1 a[1]\n1\nL’utilisation des tranches est aussi possible :\n1 a[5:]\narray([5, 6, 7, 8, 9])\nAinsi que les pas :\n1 a[::2]\narray([0, 2, 4, 6, 8])\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 209\nChapitre 20. Module NumPy 20.3. Objets de type array\nDans le cas d’un objet array à deux dimensions, vous pouvez récupérer une ligne complète (d’indice i), une colonne\ncomplète (d’indice j) ou bien un seul élément. La figure 20.1 montre comment sont organisés les indices des lignes et\ndes colonnes :\n1 a = np.array([[1, 2], [3, 4]])\n2\na\narray([[1, 2],\n[3, 4]])\n1 a[:,0]\narray([1, 3])\n1 a[0,:]\narray([1, 2])\nLa syntaxe renvoie la ligne d’indice , et renvoie la colonne d’indice . Les tranches sont aussi\na[i,:] i a[:,j] j\nutilisables sur un array à deux dimensions.\n1 a[1, 1]\n4\nLa syntaxe renvoie l’élément à la ligne d’indice et à la colonne d’indice . Notez que NumPy suit la\na[i, j] i j\n4\nconvention mathématiques des matrices , à savoir, qu’on définit toujours un élément par sa ligne puis par sa\nme me\ncolonne. En mathématiques, l’élément a d’une matrice A se trouve à la i ligne et à la j colonne :\nij\nRemarque\nPour un array 2D, si un seul indice est donné, par exemple , on récupère la ligne d’indice sous forme d’array\na[i] i\n1D :\n1\na = np.array([[1, 2], [3, 4]])\n2 a\narray([[1, 2],\n[3, 4]])\n1 a[0]\narray([1, 2])\n1 a[1]\narray([3, 4])\nPour cette raison, la syntaxe est également valide pour récupérer un élément :\na[i][j]\n1\na[1, 1]\n4\n4. https://fr.wikipedia.org/wiki/Matrice_(math%C3%A9matiques)#D%C3%A9finitions\n210 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.3. Objets de type array Chapitre 20. Module NumPy\n1\na[1][1]\n4\nNous vous recommandons la syntaxe , qui est plus proche de la définition mathématique d’un élément de\na[i, j]\n5\nmatrice .\n20.3.5 Copie d’arrays\nComme pour les listes, nous attirons votre attention sur la copie d’arrays :\n1 a = np.arange(5)\n2\na\narray([0, 1, 2, 3, 4])\n1 b = a\n2\nb[2] = -300\n3 b\narray([ 0, 1, -300, 3, 4])\n1\na\narray([ 0, 1, -300, 3, 4])\nAttention\nPar défaut la copie d’arrays se fait par référence, comme pour tous les conteneurs en Python (listes, tuples, diction-\nnaires, etc.).\nAfin d’éviter le problème, vous pouvez soit utiliser la fonction , qui crée une nouvelle copie distincte de\nnp.array()\nl’array initial, soit la fonction , comme pour les listes (voir chapitre 12 Plus sur les listes) :\ncopy.deepcopy()\n1 a = np.full((2, 2), 0)\n2\na\narray([[0, 0],\n[0, 0]])\n1 b = np.array(a)\n2\nb[1, 1] = -300\n3 import copy\n4\nc = copy.deepcopy(a)\n5 c[1, 1] = -500\n6\na\narray([[0, 0],\n[0, 0]])\n1\nb\n5. https://fr.wikipedia.org/wiki/Matrice_(math%C3%A9matiques)#D%C3%A9finitions\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 211\nChapitre 20. Module NumPy 20.4. Construction automatique de matrices\narray([[ 0, 0],\n[ 0, -300]])\n1\nc\narray([[ 0, 0],\n[ 0, -500]])\nLa fonction est expliquée dans la rubrique suivante.\nnp.full()\nRemarque\nL’instruction réalise bien une copie distincte de l’array , quelle que soit sa dimensionnalité. Ceci\nb = np.array(a) a\nn’était pas le cas avec la fonction pour les copies de listes à partir de la dimension deux (liste de listes) :\nlist()\n1 liste_1 = [[0, 0], [1, 1]]\n2 liste_2 = list(liste_1)\n3 import copy\n4 liste_3 = copy.deepcopy(liste_1)\n5\nliste_1[1][1] = -365\n6 liste_2\n[[0, 0], [1, -365]]\n1 liste_3\n[[0, 0], [1, 1]]"
  },
  {
    "title": "Construction automatique de matrices",
    "content": "Il est parfois pénible de construire une matrice (array à deux dimensions) à l’aide d’une liste de listes. Le module\nNumPy possède quelques fonctions pratiques pour initialiser des matrices. Par exemple, Les fonctions et\nzeros() ones\nconstruisent des objets array contenant des 0 ou des 1. Il suﬀit de leur passer en argument un tuple indiquant les\n()\ndimensions voulues :\n1\nnp.zeros((2, 3))\narray([[0., 0., 0.],\n[0., 0., 0.]])\n1 np.ones((3, 3))\narray([[1., 1., 1.],\n[1., 1., 1.],\n[1., 1., 1.]])\nPar défaut, les fonctions et génèrent des floats, mais vous pouvez demander des entiers en passant\nzeros() ones()\nle type (par exemple , , etc.) en second argument :\nint float\n1\nnp.zeros((2,3), int)\narray([[0, 0, 0],\n[0, 0, 0]])\n212 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.5. Chargement d’un array depuis un fichier Chapitre 20. Module NumPy\nEnfin, si vous voulez construire une matrice avec autre chose que des 0 ou des 1, vous avez à votre disposition la\nfonction :\nfull()\n1\nnp.full((2, 3), 7, int)\narray([[7, 7, 7],\n[7, 7, 7]])\n1\nnp.full((2, 3), 7, float)\narray([[ 7., 7., 7.],\n[ 7., 7., 7.]])\nNous construisons ainsi une matrice constituée de 2 lignes et 3 colonnes. Celle-ci ne contient que le chiffre 7 sous\nformes d’entiers ( ) dans le premier cas et de floats dans le second.\nint"
  },
  {
    "title": "Chargement d’un array depuis un fichier",
    "content": "Le module NumPy contient aussi des fonctions pour lire des données à partir de fichiers et créer des arrays automa-\ntiquement. C’est très pratique, car la plupart du temps les données que l’on analyse proviennent de fichiers. La fonction\nla plus simple à prendre en main est . Celle-ci lit un fichier organisé en lignes et colonnes. Par exemple,\nnp.loadtxt()\nimaginons que nous ayons un fichier contenant :\ndonnees.dat\n1 7 310\n15 -4 35\n78 95 79\nLa fonction prend en argument le nom du fichier et renvoie un array 2D directement :\n1\nnp.loadtxt(\"donnees.dat\")\narray([[ 1., 7., 310.],\n[ 15., -4., 35.],\n[ 78., 95., 79.]])\nPratique, non ? Attention toutefois aux points suivants :\n•\nChaque ligne doit avoir le même nombre de colonnes, la fonction ne gère pas les données manquantes.\n•\nChaque donnée est convertie en float, donc si une chaîne de caractères est rencontrée la fonction renvoie une erreur.\n•\nPar défaut, les données doivent être séparées par n’importe quelle combinaison d’espace(s) et/ou de tabulations.\n6\nNous vous conseillons de consulter la documentation complète de cette fonction. En effet, contient\nnp.loadtxt()\nde nombreux arguments permettant de récupérer telles ou telles lignes ou colonnes, d’ignorer des lignes de commentaire,\nde changer le séparateur par défaut (par exemple la virgule pour les fichiers .csv)… qui peuvent se révéler utiles.\n,\nL’opération inverse qui consiste à sauver un array dans un fichier se fait avec la fonction :\nnp.savetxt()\n1 a = np.reshape(range(1, 10), (3, 3))\n2\na\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\n1 np.savetxt(\"out.dat\", a)\nCeci générera le fichier contenant les lignes suivantes :\nout.dat\n1.000000000000000000e+00 2.000000000000000000e+00 3.000000000000000000e+00\n4.000000000000000000e+00 5.000000000000000000e+00 6.000000000000000000e+00\n7.000000000000000000e+00 8.000000000000000000e+00 9.000000000000000000e+00\n6.\nhttps://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 213\nChapitre 20. Module NumPy 20.6. Concaténation d’arrays\nLa fonction écrit par défaut les données comme des floats en notation scientifique. Il existe de\nnp.savetxt()\n7\nnombreuses options possibles permettant de changer le format, les séparateurs, etc.\nPour aller plus loin\n8\nIl existe d’autres fonctions plus avancées telles que np.genfromttxt() , gérant les données manquantes, ou encore\n9 10\nnp.load() et np.fromfile() , permettant de lire des données au format binaire. De même, il existe des fonctions ou mé-\n11 12\nthodes permettant d’écrire au format binaire : np.save() ou .tofile() . Le format binaire possède en général l’extension\nou lorsque les données sont compressées. L’avantage d’écrire au format binaire est que cela prend moins de\n.npy .npz\nplace pour de gros tableaux de données."
  },
  {
    "title": "Concaténation d’arrays",
    "content": "Il peut être très utile de concaténer un ou plusieurs arrays. Il existe pour cela plusieurs fonctions dans NumPy, nous\ndévelopperons celle qui nous parait la plus intuitive et directe : .\nnp.concatenate()\nPour les arrays 1D, prend en argument un tuple contenant les arrays à concaténer :\nnp.concatenate()\n1\na1 = np.array((0, 1))\n2 a2 = np.array((3, 4))\n3 a1\narray([0, 1])\n1 a2\narray([3, 4])\n1 np.concatenate((a1, a2))\narray([0, 1, 3, 4])\nL’ordre de la concaténation est important :\n1\nnp.concatenate((a2, a1))\narray([3, 4, 0, 1])\n1 np.concatenate((a1, a2, a1, a2))\narray([0, 1, 3, 4, 0, 1, 3, 4])\nPour les arrays 2D, ça se complique un peu, car on peut concaténer des lignes ou des colonnes ! Ainsi,\nnp.\nprend un argument optionnel, à savoir . Comme nous l’avions expliqué plus haut, celui-ci va\nconcatenate() axis\nindiquer à NumPy si on veut concaténer le long de l’axe 0 (les lignes) ou le long de l’axe 1 (les colonnes). Voyons un\nexemple :\n1\na1 = np.reshape(np.array(range(6)), (3, 2))\n2 a2 = a1 * 5\n3\na1\n7.\nhttps://numpy.org/doc/stable/reference/generated/numpy.savetxt.html\n8. https://numpy.org/doc/stable/reference/generated/numpy.genfromtxt.html\n9.\nhttps://numpy.org/doc/stable/reference/generated/numpy.load.html\n10. https://numpy.org/doc/stable/reference/generated/numpy.fromfile.html\n11.\nhttps://numpy.org/doc/stable/reference/generated/numpy.save.html\n12. https://numpy.org/doc/stable/reference/generated/numpy.ndarray.tofile.html#numpy.ndarray.tofile\n214 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.7. Un peu d’algèbre linéaire Chapitre 20. Module NumPy\narray([[0, 1],\n[2, 3],\n[4, 5]])\n1\na2\narray([[ 0, 5],\n[10, 15],\n[20, 25]])\nOn concatène d’abord par ligne ( ), c’est-à-dire qu’on ajoute les lignes du second array à celles de l’array\naxis=0 a2\n:\na1\n1\nnp.concatenate((a1, a2), axis=0)\narray([[ 0, 1],\n[ 2, 3],\n[ 4, 5],\n[ 0, 5],\n[10, 15],\n[20, 25]])\nEnsuite, on concatène par colonne ( ). Attention, il vaut bien veiller à ce que la concaténation soit possible en\naxis=1\nterme de dimensionalité. Par exemple, lors de la concaténation par colonne, il faut que les deux arrays et aient le\na1 a2\nmême nombre de lignes :\n1\nnp.concatenate((a1, a2), axis=1)\narray([[ 0, 1, 0, 5],\n[ 2, 3, 10, 15],\n[ 4, 5, 20, 25]])\nCes opérations de concaténation sont très importantes. On les utilise par exemple si on a des données dans plusieurs\nfichiers différents et qu’on veut les agréger dans un array unique. On verra qu’on peut faire le même genre de chose avec\nles fameux Dataframes du module pandas. Lisez bien également les recommandations dans la dernière rubrique 17.1.10\nQuelques conseils sur quand utiliser la concaténation d’arrays avec NumPy."
  },
  {
    "title": "Un peu d’algèbre linéaire",
    "content": "Après avoir manipulé les objets array comme des vecteurs et des matrices, voici quelques fonctions pour faire de\nl’algèbre linéaire.\n13\nLa fonction renvoie la transposée d’un array. Par exemple, pour une matrice :\ntranspose()\n1 a = np.resize(np.arange(1, 10), (3, 3))\n2\na\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\n1\nnp.transpose(a)\narray([[1, 4, 7],\n[2, 5, 8],\n[3, 6, 9]])\n13. https://fr.wikipedia.org/wiki/Matrice_transpos%C3%A9e\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 215\nChapitre 20. Module NumPy 20.7. Un peu d’algèbre linéaire\nTout objet array possède un attribut qui contient la transposée, il est ainsi possible d’utiliser cette notation objet\n.T\nplus compacte :\n1 a.T\narray([[1, 4, 7],\n[2, 5, 8],\n[3, 6, 9]])\n14\nLa fonction permet de multiplier deux matrices :\ndot()\n1 a = np.resize(np.arange(4), (2, 2))\n2\na\narray([[0, 1],\n[2, 3]])\n1\nnp.dot(a, a)\narray([[ 2, 3],\n[ 6, 11]])\n1 a * a\narray([[0, 1],\n[4, 9]])\nNotez bien que renvoie le produit matriciel entre deux matrices, alors que l’opération renvoie le\ndot(a, a) a * a\nproduit élément par élément.\nRemarque\nDans le module NumPy, il existe également des objets de type matrix pour lesquels les multiplications de matrices\nsont différents, mais nous ne les aborderons pas ici.\nPour toutes les opérations suivantes, nous utiliserons des fonctions du sous-module linalg de NumPy.\nLa fonction permet de générer une matrice diagonale :\ndiag()\n1 a = np.diag((1, 2, 3))\n2\na\narray([[1, 0, 0],\n[0, 2, 0],\n[0, 0, 3]])\n15\nLa fonction renvoie l’inverse d’une matrice carrée :\ninv()\n1 np.linalg.inv(a)\narray([[1. , 0. , 0. ],\n[0. , 0.5 , 0. ],\n[0. , 0. , 0.33333333]])\n16\nLa fonction renvoie le déterminant d’une matrice carrée :\ndet()\n14. https://fr.wikipedia.org/wiki/Produit_matriciel#Produit_matriciel_ordinaire\n15.\nhttps://fr.wikipedia.org/wiki/Matrice_inversible\n16. https://fr.wikipedia.org/wiki/Calcul_du_d%C3%A9terminant_d%27une_matrice\n216 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.8. Parcours de matrice et affectation de lignes et colonnes Chapitre 20. Module NumPy\n1\nnp.linalg.det(a)\n6.0\nEnfin, la fonction renvoie les vecteurs et valeurs propres :\neig()\n1\nnp.linalg.eig(a)\nEigResult(eigenvalues=array([1., 2., 3.]), eigenvectors=array([[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]]))\nLa fonction renvoie un objet , qui contient les valeurs propres ( ) et les vecteurs\neig() EigResult eigenvalues\npropres ( ), qu’on peut ensuite récupérer par affectation multiple :\neigenvectors\n1\neigvals, eigvecs = np.linalg.eig(a)\n2 eigvals\narray([1., 2., 3.])\nest un array 1D contenant les trois valeurs propres.\neigvals\n1 eigvecs\narray([[1., 0., 0.],\n[0., 1., 0.],\n[0., 0., 1.]])\nest un array 2D contenant les trois vecteurs propres (un par ligne).\neigvecs"
  },
  {
    "title": "Parcours de matrice et affectation de lignes et colonnes",
    "content": "Lorsqu’on a une matrice, on est souvent amené à la parcourir par ligne ou par colonne. NumPy permet d’itérer\ndirectement sur les lignes d’une array :\n1 a = np.reshape(np.arange(1, 10), (3, 3))\n2\na\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\n1\nfor row in a:\n2 print(row, type(row))\n[1 2 3] <class 'numpy.ndarray'>\n[4 5 6] <class 'numpy.ndarray'>\n[7 8 9] <class 'numpy.ndarray'>\nÀ chaque itération, la variable est un array 1D correspondant à chaque ligne de la matrice . Cela est du au fait\nrow a\nque l’utilisation d’un indiçage unique pour un array 2D correspond à sa ligne d’indice (voir la rubrique Indices\na[i] i\nci-dessus).\nPour itérer sur les colonnes, on peut utiliser l’astuce d’itérer sur la transposée de l’array , c’est-à-dire :\na a.T\n1 for col in a.T:\n2\nprint(col, type(col))\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 217\nChapitre 20. Module NumPy 20.9. Masques booléens\n[1 4 7] <class 'numpy.ndarray'>\n[2 5 8] <class 'numpy.ndarray'>\n[3 6 9] <class 'numpy.ndarray'>\nÀ chaque itération, la variable est un array 1D correspondant à chaque colonne de .\ncol a\nOn se souvient de l’affectation multiple qui permettait d’affecter des valeurs à plusieurs variables à la\nx, y = 1, 2\nfois. Il est possible d’utiliser cette fonctionnalité aussi avec les arrays NumPy :\n1 a\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\n1 a1, a2, a3 = a\n2\na1\narray([1, 2, 3])\n1\na2\narray([4, 5, 6])\n1 a3\narray([7, 8, 9])\nPar défaut, l’affectation multiple se fait sur les lignes de l’array 2D. Cette fonctionnalité s’explique à nouveau par le\nfait que pour NumPy, correspond à la ligne d’indice d’un array 2D.\na[i] i\nPour utiliser l’affectation multiple sur les colonnes, il suﬀit d’utiliser la transposée :\na.T\n1\nc1, c2, c3 = a.T\n2 c1\narray([1, 4, 7])\n1 c2\narray([2, 5, 8])\n1\nc3\narray([3, 6, 9])"
  },
  {
    "title": "Masques booléens",
    "content": "Une fonctionnalité puissante des arrays NumPy est l’utilisation des masques booléens. Avant de les définir, il est\nimportant d’introduire le concept d’arrays de booléens. Jusqu’à maintenant nous avions définis uniquement des arrays\navec des types numériques int ou float. Il est tout à fait possible de définir des arrays de booléens. La fonction\nnp.full()\nvue précédemment nous permet d’en construire facilement :\n1\nnp.full((2, 2), True)\n218 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.9. Masques booléens Chapitre 20. Module NumPy\narray([[ True, True],\n[ True, True]])\n1 np.full((2, 2), False)\narray([[False, False],\n[False, False]])\nAu premier abord, nous n’en voyons pas forcément l’utilité… Mais qu’en est-il lorsqu’on utilise les opérateurs de\ncomparaison avec un array ? Et bien cela renvoie un array de booléens !\n1\na = np.reshape(np.arange(1, 10), (3, 3))\n2 a\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\n1 a > 5\narray([[False, False, False],\n[False, False, True],\n[ True, True, True]])\n1 a == 2\narray([[False, True, False],\n[False, False, False],\n[False, False, False]])\nTous les éléments de l’array satisfaisant la condition seront à , les autres à . Il est même possible de\nTrue False\ncombiner plusieurs conditions avec les opérateurs logiques et (respectivement ET et OU) :\n& |\n1\na = np.reshape(np.arange(1, 10), (3, 3))\n2 a\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\n1\n(a > 3) & (a % 2 == 0)\narray([[False, False, False],\n[ True, False, True],\n[False, True, False]])\n1\n(a > 3) | (a % 2 == 0)\narray([[False, True, False],\n[ True, True, True],\n[ True, True, True]])\n•\nLes opérateurs logiques et s’appliquent sur les arrays et sont différents des opérateurs logiques et , qui\n& | and or\neux s’appliquent sur les booléens ( ou ).\nTrue False\n•\nIl est conseillé de mettre entre parenthèses chaque condition afin d’éviter les ambiguïtés.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 219\nChapitre 20. Module NumPy 20.9. Masques booléens\nMaintenant que les arrays de booléens ont été introduits, nous pouvons définir les masques booléens :\nDéfinition\nLes masques booléens sont des arrays de booléens qui sont utilisés en tant qu’« indice » d’un array initial. Cela permet\nde récupérer ou de modifier une partie de l’array initial.\nConcrètement, il suﬀira d’utiliser un array et un opérateur de comparaison entre les crochets qui étaient dédiés à\nl’indiçage :\n1 a = np.reshape(np.arange(1, 10), (3, 3))\n2\na\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\nPour isoler tous les éléments de l’array qui sont supérieurs à 5 :\na\n1\na[a > 5]\narray([6, 7, 8, 9])\nPour isoler tous les éléments de l’array qui sont égaux à 2 :\na\n1 a[a == 2]\narray([2])\nPour isoler tous les éléments de l’array qui sont non nuls :\na\n1\na[a != 0]\narray([1, 2, 3, 4, 5, 6, 7, 8, 9])\nÀ chaque fois, on ne récupère que les éléments de l’array qui satisfont la sélection. Toutefois, il est important de\na\nremarquer que l’array renvoyé perd la dimensionnalité de l’array initial, il s’agit systématiquement d’un array 1D.\na\nLa grande puissance de ce mécanisme est que l’on peut utiliser les masques booléens pour modifier les éléments que\nl’on sélectionne :\n1\na = np.reshape(np.arange(1, 10), (3, 3))\n2 a\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\nOn sélectionne les éléments de l’array supérieurs à 5 :\na\n1\na[a > 5]\narray([6, 7, 8, 9])\nOn affecte la valeur aux éléments de l’array supérieurs à 5 :\n-1 a\n1 a[a > 5] = -1\n2\na\n220 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.10. Quelques conseils Chapitre 20. Module NumPy\narray([[ 1, 2, 3],\n[ 4, 5, -1],\n[-1, -1, -1]])\nOn peut bien sûr combiner plusieurs conditions avec les opérateurs logiques :\n1\na = np.reshape(np.arange(1, 10), (3, 3))\n2 a\narray([[1, 2, 3],\n[4, 5, 6],\n[7, 8, 9]])\n1\na[(a > 3) | (a % 2 == 0)] = 0\n2 a\narray([[1, 0, 3],\n[0, 0, 0],\n[0, 0, 0]])\nCe mécanisme de sélection avec des masques booléens se révèle très puissant pour manipuler de grandes quantités\nde données. On verra qu’il peut être également utilisé avec les Dataframes du module pandas.\nRemarque\n17\nLes masques booléens ne doivent pas être confondus avec les masked arrays , qui sont des arrays dans lesquels on\npeut trouver des valeurs manquantes ou invalides.\nEnfin, une application possible des masques est de « binariser » une matrice de nombre :\n1 import random\n2\nimport numpy as np\n3 a = np.resize([random.random() for i in range(16)], (4, 4))\n4\na\narray([[0.58704728, 0.50212977, 0.70652863, 0.24158108],\n[0.93102132, 0.41864373, 0.45807961, 0.98288744],\n[0.48198211, 0.16877376, 0.14431518, 0.74784176],\n[0.92913469, 0.08383269, 0.10670144, 0.14554345]])\n1 seuil = 0.3\n2\na[a < seuil] = 0\n3 a[a > seuil] = 1\n4\na\narray([[1., 1., 1., 0.],\n[1., 1., 1., 1.],\n[1., 0., 0., 1.],\n[1., 0., 0., 0.]])\nOn obtient ce résultat avec deux lignes de code en utilisant des arrays, alors qu’il aurait fallu faire des boucles avec\ndes listes classiques."
  },
  {
    "title": "Quelques conseils",
    "content": "Nous vous avons présenté une petite partie du module NumPy, mais vous avez pu en constater son extraordinaire\npuissance. On pourrait au premier abord être tenté d’abandonner les listes, toutefois elles gardent toute leur importance.\n17. https://numpy.org/doc/1.18/reference/maskedarray.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 221\nChapitre 20. Module NumPy 20.11. Exercices\nAlors, quand utiliser les listes ou quand utiliser les arrays NumPy ? Voici une liste non exhaustive d’éléments qui peuvent\nguider votre choix :\nUtilisez NumPy pour :\n•\nles opérations vectorielles (éléments par éléments) ;\n•\nlorsque vous souhaitez manipuler des objets mathématiques (vecteurs, matrices, etc.) et les outils associés (algèbre\nlinéaire) ;\n•\ntout ce qui est numérique de manière générale.\nUtilisez les listes :\n•\nLorsque vous avez besoin d’un conteneur pour accumuler des valeurs (fussent-elles des sous-listes), surtout lors-\nqu’elles ne sont pas homogènes (c’est-à-dire du même type).\n•\nLorsque vous souhaitez accumuler des valeurs au fur et à mesure des itérations d’une boucle. Pour cela, la méthode\ndes listes est bien plus eﬀicace que de faire grandir un array ligne par ligne (c’est-à-dire en ajoutant\n.append()\nune ligne avec à chaque itération).\nnp.concatenate()\n•\nLorsqu’on ne peut pas utiliser les fonctions de lecture de fichier de NumPy pour quelque raison que ce soit, il est\ntout à fait classique de faire grandir une liste au fur et à mesure de la lecture du fichier puis de la convertir à la fin\nen array. De manière générale, utilisez seulement pour concaténer des gros arrays, pas pour\nnp.concatenate()\najouter une seule ligne.\nEnfin, comme nous vous le conseillons depuis le début, soignez votre documentation (docstrings) et vos commentaires\nlorsque vous utilisez des arrays. NumPy permet de réaliser des opérations vectorielles de manière très compacte. Il est\ndonc essentiel de se mettre à la place du lecteur de votre script (y compris vous dans quelques semaines ou mois) et de\ndocumenter ce que contient chaque array ainsi que sa dimensionnalité (1D, 2D, etc.).\n18\nLe module NumPy est la brique de base du calcul numérique en Python. Associé aux modules SciPy et matplotlib,\nainsi qu’aux notebooks Jupyter (voir le chapitre précédent), il permet de faire du calcul scientifique de manière très\neﬀicace. On verra dans le chapitre 22 Module Pandas que la puissance de NumPy est également utilisée par le module\npandas pour faire de l’analyse de données.\nPour aller plus loin\n• 19\nLe livre de Nicolas Rougier From Python to Numpy est une excellente ressource pour explorer plus en détails les\npossibilités de NumPy.\n• 20\nLes tutoriels proposés par les développeurs de NumPy sont également un bon moyen de poursuivre votre explo-\nration de cette bibliothèque incontournable en sciences."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, utilisez des notebooks Jupyter.\n20.11.1 Nombres pairs et impairs\nSoit un array NumPy qui contient les nombres :\nimpairs\n1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21\nEn une seule instruction, construisez l’array dans lequel tous les éléments de sont incrémentés de 1.\npairs impairs\nComparez ce que vous venez de faire avec l’exercice « Nombres pairs et impairs » du chapitre 5 Boucles et comparaisons.\n18. https://scipy.org/\n19.\nhttps://www.labri.fr/perso/nrougier/from-python-to-numpy/\n20. https://numpy.org/numpy-tutorials/index.html\n222 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.11. Exercices Chapitre 20. Module NumPy\n20.11.2 Distance entre deux atomes carbones alpha consécutifs de la barstar\nLa barstar est un inhibiteur de ribonucléase. C’est une protéine relativement simple qui contient 89 acides aminés. Sa\nstructure tridimensionnelle, obtenue par résonance magnétique nucléaire (RMN), se trouve dans la Protein Data Bank\n(PDB) sous le code 1BTA.\nL’objectif de cet exercice est de calculer la distance entre carbones alpha consécutifs le long de la chaîne peptidique\navec module NumPy et de découvrir une anomalie.\nLe morceau de code suivant vous sera utile pour extraire les coordonnées atomiques des carbones alpha de la barstar\ndepuis un fichier PDB :\n1 with open(\"1bta.pdb\", \"r\") as f_pdb, open(\"1bta_CA.txt\", \"w\") as f_CA:\n2\nfor ligne in f_pdb:\n3 if ligne.startswith(\"ATOM\") and ligne[12:16].strip() == \"CA\":\n4\nx = ligne[30:38]\n5 y = ligne[38:46]\n6\nz = ligne[46:54]\n7 f_CA.write(f\"{x} {y} {z} \")\n•\nLigne 1. On ouvre deux fichiers simultanément. Ici, le fichier est ouvert en lecture ( ) et le fichier\n1bta.pdb r\nest ouvert en écriture ( ).\n1bta_CA.txt w\n•\nPour chaque ligne du fichier PDB (ligne 2), si la ligne débute par et le nom de l’atome est (ligne 3),\nATOM CA\nalors on extrait les coordonnées atomiques (lignes 4 à 6) et on les écrit dans le fichier (ligne 7).\n1bta_CA.txt\nLes coordonnées sont toutes enregistrées sur une seule ligne, les unes après les autres.\nVoici les étapes à suivre :\n1. Extraction des coordonnées atomiques\n• 21\nTéléchargez le fichier qui correspond à la structure de la barstar sur le site de la PDB (lien direct\n1bta.pdb\n22\nvers le fichier ).\n•\nUtilisez le code précédent pour extraire les coordonnées atomiques des carbones alpha de la barstar.\n2. Lecture des coordonnées\n•\nOuvrez le fichier avec Python et créez une liste contenant toutes les coordonnées sous forme\n1bta_CA.txt\nde floats avec les fonctions et .\nsplit() float()\n•\nAﬀichez à l’écran le nombre total de coordonnées.\n3. Construction de la matrice de coordonnées\n•\nEn ouvrant dans un éditeur de texte le fichier , trouvez le nombre d’acides aminés qui constituent\n1bta.pdb\nla barstar.\n•\nAvec la fonction du module NumPy, convertissez la liste de coordonnées en . Avec la fonction\narray() array\nde NumPy, construisez ensuite une matrice à deux dimensions contenant les coordonnées des\nreshape()\ncarbones alpha de la barstar. Aﬀichez les dimensions de cette matrice.\n4. Calcul de la distance\n• −\nCréez maintenant une matrice qui contient les coordonnées des n premiers carbones alpha et une autre\n1\n−\nqui contient les coordonnées des n 1 derniers carbones alpha. Aﬀichez les dimensions des matrices pour\nvérification.\n•\nEn utilisant les opérateurs mathématiques habituels ( , , ) et les fonctions et du module\n- + **2 sqrt() sum()\nNumPy, calculez la distance entre les atomes n et n+1.\n•\nPour chaque atome, aﬀichez le numéro de l’atome et la distance entre carbones alpha consécutifs avec un\nchiffre après la virgule. Repérez la valeur surprenante.\n20.11.3 Jour le plus chaud\n23\nLe fichier contient un relevé de quatre températures pour chaque jour de la semaine :\ntemperature.dat\nLun 12 11 14 12\nMar 12 10 14 11\nMer 11 11 14 13\n[...]\n21. http://www.rcsb.org/pdb/explore.do?structureId=1BTA\n22.\nhttps://files.rcsb.org/download/1BTA.pdb\n23. https://python.sdv.u-paris.fr/data-files/temperatures.dat\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 223\nChapitre 20. Module NumPy 20.11. Exercices\nÀ l’aide du module NumPy, on souhaite déterminer quel est le jour de la semaine le plus chaud. Pour cela nous vous\nproposons les étapes suivantes :\n1. Récupérez le nom des jours de la semaine depuis le fichier et stockez-les dans une liste .\ndays\n2. Récupérez les valeurs de températures depuis le fichier et stockez-les dans un array 2D. La fonction\nnp.loadtxt\n24\net son argument vous seront utiles.\n() usecols\n3. Parcourez chaque ligne de la matrice, calculez la température moyenne de chaque jour puis stockez-la dans une\nliste .\nmean_temps\n4. À l’aide des deux listes et , déterminez et aﬀichez le jour le plus chaud.\ndays mean_temps\n20.11.4 Calcul du centre de masse d’une membrane\nL’image de gauche de la figure 20.2 montre le cliché d’une membrane de POPC (cyan) entourée d’eau (bleu)\n25\n(coordonnées trouvées ici ). Les atomes de phosphore des groupes phosphates sont représentés en boule de van der\nWaals brune. Dans cet exercice, on cherche à calculer le centre de masse de la membrane, ainsi que le centre de masse\n(COM) de chaque monocouche de phosphores. Ces COM sont représentés sous forme de croix dans le graphique de droite\nde la figure 20.2.\nFigure 20.2 – Cliché d’une membrane de POPC.\n26\nLes coordonnées cartésiennes (x,y,z) de chaque atome de phosphore (en Å) sont stockées dans le fichier coors_P.dat ,\nà raison d’un atome par ligne.\nNous vous proposons les étapes suivantes pour résoudre cet exercice à l’aide du module NumPy :\n1. Récupérez les coordonnées des atomes de phosphore depuis le fichier et stockez-les dans un array\ncoors_P.dat\n×\n2D (matrice) . La dimensionnalité de cette matrice est n 3, avec n le nombre de phosphores.\ncoors_P\n2. Calculez le moyen de tous les phosphores (nombre réel) et stockez-le dans la variable . La méthode\nz\nmean_z\nvous sera utile.\n.mean()\n3. Avec des masques de booléens, récupérez les coordonnées des phosphores de la monocouche du haut dans un array\n2D . Faites de même avec la monocouche du bas dans un array 2D .\nupper lower\n4. Calculez le centre de masse de la membrane, ainsi que de la monocouche du haut et du bas\nCOM COM_upper\n. Pensez aux méthodes de calcul sur les arrays et l’argument .\nCOM_lower axis\n5. Une fois tout cela effectué, créez un graphique 3D pour représenter les différents centres de masse. Utilisez la\n27\nfonction du module matplotlib pour l’aﬀichage en 3D . Voici un squelette de programme pour vous\nscatter()\n24.\nhttps://numpy.org/doc/stable/reference/generated/numpy.loadtxt.html\n25. https://zenodo.org/record/153944\n26.\nhttps://python.sdv.u-paris.fr/data-files/coors_P.dat\n27. https://matplotlib.org/3.2.1/gallery/mplot3d/scatter3d.html\n224 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n20.11. Exercices Chapitre 20. Module NumPy\naider :\n1\n# Initialisation du graphique.\n2 from mpl_toolkits.mplot3d import Axes3D\n3\nimport matplotlib.pyplot as plt\n4 fig = plt.figure()\n5\nax = fig.add_subplot(111, projection=\"3d\")\n6 [...]\n7\n# X, Y et Z sont des arrays 1D de n éléments.\n8 # Par exemple X représente tous les x des P de la monocouche upper.\n9 [...]\n10\n# Affichage de la couche upper.\n11 ax.scatter(X, Y, Z, c=\"salmon\", marker=\"o\")\n12\n# Affichage du COM de la couche upper.\n13 ax.scatter(x, y, z, c=\"red\", marker=\"x\")\n14\n[...]\n15 # Affichage des étiquettes des axes et du titre.\n16 ax.set_xlabel(\"x (Å)\")\n17\nax.set_ylabel(\"y (Å)\")\n18\nax.set_zlabel(\"z (Å)\")\n19 ax.set_title(\"Graphe 3D des phosphores\")\n20\nplt.show()\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 225"
  },
  {
    "title": "Module Matplotlib",
    "content": "1\nLe module matplotlib permet de générer des graphiques depuis Python. Il est l’outil complémentaire des modules\nNumPy, scipy ou pandas (que l’on verra juste après) lorsqu’on veut faire de l’analyse de données."
  },
  {
    "title": "Installation et convention",
    "content": "Le module matplotlib n’est pas fourni avec la distribution Python de base. Avec la distribution Miniconda que nous\n2\nvous conseillons d’utiliser (consultez pour cela la documentation en ligne ), vous pouvez l’installer avec la commande :\n$ conda install -c conda-forge matplotlib\nDans ce chapitre, nous vous montrerons quelques exemples d’utilisation du module matplotlib pour vous convaincre\nde sa pertinence. Ces exemples seront exécutés dans un notebook Jupyter.\n1 Les cellules de code apparaitront de cette manière\n2\ndans un notebook Jupyter, avec des numéros de lignes à gauche."
  },
  {
    "title": "Chargement du module",
    "content": "On importe le module matplotlib avec la commande :\n1 import matplotlib.pyplot as plt\nRemarque\nOn n’importe pas le module matplotlib directement, mais plutôt son sous-module . Par convention, et pour\npyplot\nl’utiliser plus rapidement, ce sous-module prendre l’alias .\nplt"
  },
  {
    "title": "Représentation en nuage de points",
    "content": "Dans cet exemple, nous considérons l’évolution de la concentration d’un produit dans le sang (exprimé en mg/L) en\nfonction du temps (exprimé en heures). Cet exemple est purement fictif.\n1.\nhttps://matplotlib.org/\n2. https://python.sdv.u-paris.fr/livre-dunod\n226\n21.3. Représentation en nuage de points Chapitre 21. Module Matplotlib\nVoici les valeurs mesurées :\nTemps (h) Concentration (mg/L)\n1 3.5\n2 5.8\n3 9.1\n4 11.8\n6 17.5\n7 21.3\n9 26.8\nNous allons maintenant représenter l’évolution de la concentration en fonction du temps :\n1\nimport matplotlib.pyplot as plt\n2\n3\ntemps = [1, 2, 3, 4, 6, 7, 9]\n4 concentration = [5.5, 7.2, 11.8, 13.6, 19.1, 21.7, 29.4]\n5\n6 fig, ax = plt.subplots()\n7 ax.scatter(temps, concentration, marker=\"o\", color=\"blue\")\n8\nax.set_xlabel(\"Temps (h)\")\n9 ax.set_ylabel(\"Concentration (mg/L)\")\n10\nax.set_title(\"Concentration de produit en fonction du temps\")\n11 plt.show()\nDans un notebook Jupyter, vous devriez obtenir un graphique ressemblant à celui de la figure 21.1.\nFigure 21.1 – Graphique produit par matplotlib.\nRevenons maintenant sur le code :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 227\nChapitre 21. Module Matplotlib 21.4. Représentation sous forme de courbe\n•\nLigne 1. Tout d’abord, on importe le sous-module du module matplotlib et on lui donne l’alias pour\npyplot plt\nl’utiliser plus rapidement ensuite. Cet alias est standard, utilisez-le systématiquement.\n•\nLignes 3 et 4. On définit les variables et comme des listes. Les deux listes doivent avoir\ntemps concentration\nla même longueur (sept éléments dans le cas présent).\n•\nLigne 6. On crée une figure avec la fonction qui renvoie deux objets : une figure ( ) et un axe\nsubplots() fig\n( ). L’axe est l’objet qui contient le graphique à proprement dit. On peut avoir plusieurs axes dans une même\nax\nfigure.\n•\nLigne 7. La méthode permet de représenter des points sous forme de nuage de points. Les deux\n.scatter()\npremiers arguments correspondent aux valeurs en abscisse et en ordonnée des points, fournis sous forme de listes.\nDes arguments facultatifs sont ensuite précisés comme le symbole ( ) et la couleur ( ).\nmarker color\n•\nLignes 8 et 9. Les méthodes et donnent une légende aux axes des abscisses et\n.set_xlabel() .set_ylabel()\ndes ordonnées.\n•\nLigne 10. La méthode définit le titre du graphique.\n.set_title()\n•\nLigne 11. L’instruction aﬀiche le graphique. Elle n’est pas nécessaire dans un notebook Jupyter, car\nplt.show()\nle graphique est aﬀiché automatiquement, mais elle est indispensable dans un script Python."
  },
  {
    "title": "Représentation sous forme de courbe",
    "content": "On sait par ailleurs que l’évolution de la concentration du produit en fonction du temps peut-être modélisée par la\n×\nfonction f(x) = 2+3 x.\nRemarque\nLe modèle présenté ici est purement fictif. Vous découvrirez dans le chapitre 22 Module Pandas comment réaliser une\nrégression linéaire pour modéliser des données expérimentales.\nReprésentons ce modèle avec les points expérimentaux et sauvegardons le graphique obtenu sous forme d’une image :\n1 import numpy as np\n2\nimport matplotlib.pyplot as plt\n3\n4\ntemps = [1, 2, 3, 4, 6, 7, 9]\n5 concentration = [5.5, 7.2, 11.8, 13.6, 19.1, 21.7, 29.4]\n6\n7 fig, ax = plt.subplots()\n8 ax.scatter(temps, concentration, marker=\"o\", color = \"blue\")\n9\nax.set_xlabel(\"Temps (h)\")\n10 ax.set_ylabel(\"Concentration (mg/L)\")\n11\nax.set_title(\"Concentration de produit en fonction du temps\")\n12\n13\nx = np.linspace(min(temps), max(temps), 50)\n14 y = 2 + 3 * x\n15\n16 ax.plot(x, y, color=\"green\", ls=\"--\")\n17\nax.grid()\n18 fig.savefig(\"concentration_vs_temps_1.png\", bbox_inches=\"tight\", dpi=200)\nLe résultat est représenté sur la figure 21.2.\nLes étapes supplémentaires par rapport au graphique précédent (figure 21.1) sont :\n•\nLigne 1. On charge le module numpy sous le nom .\nnp\n•\nLigne 13. On crée la variable avec la fonction du module NumPy, qui renvoie une liste de valeurs\nx linspace()\nrégulièrement espacées entre deux bornes, ici entre le minimum ( ) et le maximum ( ) de\nmin(temps) max(temps)\nla variable . Dans notre exemple, nous générons une liste de 50 valeurs. La variable ainsi créée est du type\ntemps x\narray.\n•\nLigne 14. On construit ensuite la variable à partir de la formule modélisant l’évolution de la concentration\ny\ndu produit en fonction du temps. Cette manipulation n’est possible que parce que est du type array. Cela ne\nx\nfonctionnerait pas avec une liste classique.\n•\nLigne 16. La méthode construit une courbe à partir des coordonnées en abscisse et en ordonnées des\n.plot()\n228 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n21.4. Représentation sous forme de courbe Chapitre 21. Module Matplotlib\nFigure 21.2 – Concentration du produit en fonction du temps.\npoints à représenter. On indique ensuite des arguments facultatifs comme le style de la ligne ( pour line style)\nls\net sa couleur ( ).\ncolor\n•\nLigne 17. La méthode aﬀiche une grille.\n.grid()\n•\nLigne 18. Enfin, l’instruction enregistre le graphique produit sous la forme d’une image au format\nfig.savefig()\npng. Des arguments par mot-clé définissent la manière de générer les marges autour du graphique ( )\nbbox_inches\net la résolution de l’image ( ).\ndpi\nPour terminer, on peut améliorer un peu plus le graphique en ajoutant une légende et en modifiant l’étendue des axes\ndes abscisses et des ordonnées :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 229\nChapitre 21. Module Matplotlib 21.4. Représentation sous forme de courbe\n1\nimport numpy as np\n2 import matplotlib.pyplot as plt\n3\n4 temps = [1, 2, 3, 4, 6, 7, 9]\n5\nconcentration = [5.5, 7.2, 11.8, 13.6, 19.1, 21.7, 29.4]\n6\n7 fig, ax = plt.subplots()\n8\nax.scatter(temps, concentration, marker=\"o\", color=\"blue\", label=\"mesures\")\n9 ax.set_xlabel(\"Temps (h)\")\n10\nax.set_ylabel(\"Concentration (mg/L)\")\n11 ax.set_title(\"Concentration de produit en fonction du temps\")\n12\n13 x = np.linspace(min(temps), max(temps), 50)\n14\ny = 2 + 3 * x\n15\n16\nax.plot(x, y, color=\"green\", ls=\"--\", label=\"modèle\")\n17\n18\nax.grid()\n19 ax.set_xlim(0, 10)\n20 ax.set_ylim(0, 35)\n21\n22 ax.legend(loc=\"upper left\")\n23\nfig.savefig(\"concentration_vs_temps_2.png\", bbox_inches=\"tight\", dpi=200)\nOn obtient alors le graphique représenté dans la figure 21.3.\nFigure 21.3 – Concentration du produit en fonction du temps, version améliorée.\nLes différences notables par rapport au code précédent sont :\n•\nLignes 8 et 16. On ajoute le paramètre pour donner un nom au nuage de points ( ) ou à la\nlabel .scatter()\ncourbe ( ).\n.plot()\n•\nLignes 19 et 20. On définit l’étendue de l’axe des abscisses avec la méthode et de l’axe des\n.set_xlim()\n230 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n21.5. Représentation en diagramme en bâtons Chapitre 21. Module Matplotlib\nordonnées avec la méthode .\n.set_ylim()\n•\nLignes 22. On aﬀiche la légende avec la méthode . L’argument permet de préciser la position de\n.legend() loc\nla légende dans le graphique. Dans notre exemple, la légende est placée en haut à gauche ( ).\n\"upper left\""
  },
  {
    "title": "Représentation en diagramme en bâtons",
    "content": "On souhaite maintenant représenter graphiquement la distribution des différentes bases dans une séquence d’ADN.\n1\nimport numpy as np\n2 import matplotlib.pyplot as plt\n3\n4 sequence = \"ACGATCATAGCGAGCTACGTAGAA\"\n5\nbases = [\"A\", \"C\", \"G\", \"T\"]\n6 distribution = []\n7\nfor base in bases:\n8 distribution.append(sequence.count(base))\n9\n10 x = np.arange(len(bases))\n11\n12 fig, ax = plt.subplots()\n13 ax.bar(x, distribution)\n14\nax.set_xticks(x, bases)\n15 ax.set_xlabel(\"Bases\")\n16\nax.set_ylabel(\"Nombre\")\n17 ax.set_title(f\"Distribution des bases\\n dans la séquence {sequence}\")\n18\nfig.savefig(\"distribution_bases.png\", bbox_inches=\"tight\", dpi=200)\nOn obtient alors le graphique de la figure 21.4.\nFigure 21.4 – Distribution des bases.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 231\nChapitre 21. Module Matplotlib 21.5. Représentation en diagramme en bâtons\nPrenons le temps d’examiner les différentes étapes du script précédent :\n•\nLignes 4 à 6. On définit les variables , et .\nsequence bases distribution\n•\nLignes 7 et 8. On calcule la distribution des différentes bases dans la séquence. On utilise pour cela la méthode\n, qui renvoie le nombre de fois qu’une chaîne de caractères (les différentes bases) se trouve dans une autre\ncount()\n(la séquence).\n•\nLigne 10. On définit la position en abscisse des barres. Dans cet exemple, la variable vaut\nx array([0, 1, 2,\n.\n3])\n•\nLigne 12. On crée le graphique.\n•\nLigne 13. La méthode construit le diagramme en bâtons. Elle prend en argument la position des barres\n.bar()\n( ) et leurs hauteurs ( ).\nx distribution\n•\nLigne 14. La méthode redéfinit les étiquettes (c’est-à-dire le nom des bases) sur l’axe des abscisses.\n.set_xtics()\n•\nLignes 15 à 17. On définit les légendes des axes et le titre du graphique. On insère un retour à la ligne dans\n\\n\nle titre pour qu’il soit réparti sur deux lignes.\n•\nLigne 18. Enfin, on enregistre le graphique généré au format png.\nOn espère que ces courts exemples vous auront convaincu de l’utilité du module matplotlib. Sachez qu’il peut faire\nbien plus, par exemple générer des histogrammes ou toutes sortes de graphiques utiles en analyse de données. Il est existe\n3 4 5\npar ailleurs d’autres bibliothèques pour produire des graphiques avec Python, comme Seaborn , Bokeh ou Plotly . Ces\ndeux dernières permettent de générer des graphiques interactifs, c’est-à-dire des graphiques dans lesquels on peut zoomer,\nse déplacer, etc. Nous vous invitons à les découvrir par vous-même.\nPour aller plus loin\n• 6\nLe site de matplotlib fournit de nombreux exemples détaillés , n’hésitez pas à le consulter.\n•\n7\nLe site Python Graph Gallery propose aussi des exemples de code pour différents types de graphiques, réalisés\navec matplotlib ou d’autres bibliothèques.\n• 8\nEnfin, des cheat sheets de matplotlib sont extrêmement utiles et très bien faites.\n3.\nhttps://seaborn.pydata.org/\n4. http://bokeh.org/\n5.\nhttps://plotly.com/\n6. https://matplotlib.org/gallery/index.html\n7.\nhttps://www.python-graph-gallery.com/matplotlib/\n8. https://matplotlib.org/cheatsheets/\n232 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Module Pandas",
    "content": "1\nLe module pandas a été conçu pour l’analyse de données. Il est particulièrement puissant pour manipuler des données\nstructurées sous forme de tableau."
  },
  {
    "title": "Installation et convention",
    "content": "Le module pandas n’est pas fourni avec la distribution Python de base. Avec la distribution Miniconda que nous\n2\nvous conseillons d’utiliser (consultez pour cela la documentation en ligne ), vous pouvez rapidement l’installer avec la\ncommande :\n$ conda install -c conda-forge pandas\nVous aurez également besoin des modules matplotlib pour créer des graphiques et scipy pour réaliser une régression\nlinaire, que vous pouvez installer ainsi :\n$ conda install -c conda-forge matplotlib scipy\nDans ce chapitre, nous vous montrerons quelques exemples d’utilisation du module pandas pour vous convaincre de\nsa pertinence. Ces exemples seront exécutés dans un notebook Jupyter.\n1 Les cellules de code apparaitront de cette manière\n2\ndans un notebook Jupyter, avec des numéros de lignes à gauche.\nLes résultats seront affichés de cette manière,\néventuellement sur plusieurs lignes."
  },
  {
    "title": "Chargement du module",
    "content": "Pour charger pandas dans la mémoire de Python, on utilise la commande habituelle :\nimport\n1 import pandas\nPar convention, on utilise comme nom raccourci pour pandas :\npd\n1\nimport pandas as pd\n1.\nhttps://pandas.pydata.org/\n2. https://python.sdv.u-paris.fr/livre-dunod\n233\nChapitre 22. Module Pandas 22.3. Series"
  },
  {
    "title": "Series",
    "content": "Le premier type de données apporté par pandas est la Series, qui correspond à un vecteur à une dimension.\n1 s = pd.Series([10, 20, 30, 40], index = ['a', 'b', 'c', 'd'])\n2 s\na 10\nb 20\nc 30\nd 40\ndtype: int64\n22.3.1 Sélections par étiquette ou indice\nAvec pandas, chaque élément de la série de données possède une étiquette qui permet d’appeler les éléments qui la\ncomposent. Ainsi, pour appeler le premier élément de la série, on peut utiliser son étiquette (ici, ) :\n\"a\"\n1 s[\"a\"]\n10\nPour accéder au premier élément par son indice (ici 0), comme on le ferait avec une liste, on utilise la méthode\n:\n.iloc\n1 s.iloc[0]\n10\nBien sûr, on peut extraire plusieurs éléments, par leurs indices ou leurs étiquettes :\n1\ns[[\"b\", \"d\"]]\nb 20\nd 40\ndtype: int64\net\n1 s.iloc[[1, 3]]\nb 20\nd 40\ndtype: int64\n22.3.2 Modifications de Series\nLes étiquettes permettent de modifier et d’ajouter des éléments :\n1 s[\"c\"] = 300\n2\ns[\"z\"] = 50\n3 s\na 10\nb 20\nc 300\nd 40\nz 50\ndtype: int64\n234 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.4. Dataframes Chapitre 22. Module Pandas\n22.3.3 Filtres\nEnfin, on peut filtrer une partie de la Series :\n1\ns[s>30]\nc 300\nd 40\nz 50\ndtype: int64\nRemarque\nCette écriture rappelle celle des masques booléens dans le chapitre 20 Module NumPy.\nEnfin, on peut aussi combiner plusieurs critères de sélection avec les opérateurs logiques (pour ET) et (pour\n& |\nOU) :\n1\ns[(s>20) & (s<100)]\nd 40\nz 50\ndtype: int64\n1 s[(s<15) | (s>150)]\na 10\nc 300\ndtype: int64"
  },
  {
    "title": "Dataframes",
    "content": "Un autre type d’objet particulièrement intéressant introduit par pandas sont les Dataframes. Ceux-ci correspondent\nà des tableaux à deux dimensions avec des étiquettes pour nommer les lignes et les colonnes.\nRemarque\nSi vous êtes familier avec le langage de programmation et d’analyse statistique R, les Dataframes de pandas se\nrapprochent de ceux trouvés dans R.\n22.4.1 Création\nVoici comment créer un Dataframe avec pandas à partir de données fournies comme liste de lignes :\n1\nimport numpy as np\n2 df = pd.DataFrame(columns=[\"a\", \"b\", \"c\", \"d\"],\n3\nindex=[\"chat\", \"singe\", \"souris\"],\n4 data=[np.arange(10, 14),\n5\nnp.arange(20, 24),\n6 np.arange(30, 34)])\n7\ndf\na b c d\nchat 10 11 12 13\nsinge 20 21 22 23\nsouris 30 31 32 33\nVoici quelques commentaires sur le code précédent :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 235\nChapitre 22. Module Pandas 22.4. Dataframes\n•\nLigne 1. On charge le module NumPy utilisé ensuite.\n•\nLigne 2. Le Dataframe est créé avec la fonction à laquelle on fournit plusieurs arguments. L’argument\nDataFrame()\nindique le nom des colonnes, sous forme d’une liste.\ncolumns\n•\nLigne 3. L’argument définit le nom des lignes, sous forme de liste également.\nindex\n•\nLignes 4 à 6. L’argument fournit le contenu du Dataframe, sous la forme d’une liste de valeurs correspon-\ndata\ndantes à des lignes. Ainsi, qui est équivalent à correspond à la première\nnp.arange(10, 14) [10, 11, 12, 13]\nligne du Dataframe.\nLe même Dataframe peut aussi être créé à partir des valeurs fournies en colonnes sous la forme d’un dictionnaire :\n1 data = {\"a\": np.arange(10, 40, 10),\n2\n\"b\": np.arange(11, 40, 10),\n3 \"c\": np.arange(12, 40, 10),\n4\n\"d\": np.arange(13, 40, 10)}\n5 df = pd.DataFrame(data)\n6\ndf.index = [\"chat\", \"singe\", \"souris\"]\n7 df\na b c d\nchat 10 11 12 13\nsinge 20 21 22 23\nsouris 30 31 32 33\n•\nLignes 1 à 4. Le dictionnaire contient les données en colonnes. La clé associée à chaque colonne est le nom\ndata\nde la colonne.\n•\nLigne 5. Le dataframe est créé avec la fonction à laquelle on passe en argument.\npd.DataFrame() data\n•\nLigne 6. On peut définir les étiquettes des lignes de n’importe quel dataframe avec l’attribut .\ndf.index\n22.4.2 Quelques propriétés\nLes dimensions d’un dataframe sont données par l’attribut :\n.shape\n1 df.shape\n(3, 4)\nIci, le dataframe possède trois lignes et quatre colonnes.\ndf\nL’attribut renvoie le nom des colonnes et permet aussi de renommer les colonnes d’un dataframe :\n.columns\n1 df.columns\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n1\ndf.columns = [\"Paris\", \"Lyon\", \"Nantes\", \"Pau\"]\n2 df\nParis Lyon Nantes Pau\nchat 10 11 12 13\nsinge 20 21 22 23\nsouris 30 31 32 33\nLa méthode renvoie les n premières lignes du Dataframe (par défaut, n vaut 5) :\n.head(n)\n1\ndf.head(2)\nParis Lyon Nantes Pau\nchat 10 11 12 13\nsinge 20 21 22 23\n236 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.4. Dataframes Chapitre 22. Module Pandas\nRemarque\nLes Dataframes utilisés ici comme exemples sont volontairement petits. Si vous êtes confrontés à des Dataframes\nde grande taille, ceux-ci seront aﬀichés partiellement dans un notebook Jupyter. Des ascenseurs en bas et à droite du\nDataframe permettront de naviguer dans les données.\n22.4.3 Sélections\nLes mécanismes de sélection fournis avec pandas sont très puissants. En voici un rapide aperçu :\n22.4.3.1 Sélection de colonnes\nOn peut sélectionner une colonne par son étiquette :\n1\ndf[\"Lyon\"]\nchat 11\nsinge 21\nsouris 31\nLa notation sélectionne une colonne et renvoie un objet Series :\ndf[\"Lyon\"]\n1 type(df[\"Lyon\"])\npandas.core.series.Series\nAttention\nOn trouve parfois l’écriture pour sélectionner une colonne. C’est une très mauvaise pratique, car cette\ndf.Lyon\nécriture peut être confondue avec un attribut de l’objet (par exemple ). Par ailleurs, elle ne fonctionne pas\ndf .shape\npour des noms de colonnes qui contiennent des espaces ou des caractères spéciaux (ce qui n’est pas non plus une bonne\npratique).\nNous vous conseillons de toujours utiliser la notation .\ndf[\"nom_de_colonne\"]\nPour sélectionner plusieurs colonnes, il faut fournir une liste de noms de colonnes :\n1 df[[\"Lyon\", \"Pau\"]]\nLyon Pau\nchat 11 13\nsinge 21 23\nsouris 31 33\nOn obtient cette fois un Dataframe avec les colonnes sélectionnées :\n1\ntype(df[[\"Lyon\", \"Pau\"]])\npandas.core.frame.DataFrame\nRemarque\nLa sélection de plusieurs colonnes nécessite une liste entre les crochets, par exemple . Si on\ndf[[\"Lyon\", \"Pau\"]]\nutilise un tuple du type , Python renvoie une erreur .\ndf[(\"Lyon\", \"Pau\")] KeyError: ('Lyon', 'Pau')\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 237\nChapitre 22. Module Pandas 22.4. Dataframes\n22.4.3.2 Sélection de lignes\nPour sélectionner une ligne, il faut utiliser l’instruction et l’étiquette de la ligne :\n.loc\n1 df.loc[\"singe\"]\nParis 20\nLyon 21\nNantes 22\nPau 23\nName: singe, dtype: int64\nIci aussi, on peut sélectionner plusieurs lignes :\n1\ndf.loc[[\"singe\", \"chat\"]]\nParis Lyon Nantes Pau\nsinge 20 21 22 23\nchat 10 11 12 13\nEnfin, on peut aussi sélectionner des lignes avec l’instruction et l’indice de la ligne (la première ligne ayant\n.iloc\nl’indice 0) :\n1 df.iloc[1]\nParis 20\nLyon 21\nNantes 22\nPau 23\nName: singe, dtype: int64\n1 df.iloc[[1, 0]]\nParis Lyon Nantes Pau\nsinge 20 21 22 23\nchat 10 11 12 13\nOn peut également utiliser les tranches (comme pour les listes) :\n1\ndf.iloc[0:2]\nParis Lyon Nantes Pau\nchat 10 11 12 13\nsinge 20 21 22 23\n22.4.3.3 Sélection sur les lignes et les colonnes\nOn peut bien sûr combiner les deux types de sélection (en ligne et en colonne) :\n1 df.loc[\"souris\", \"Pau\"]\n33\n1\ndf.loc[[\"singe\", \"souris\"], [\"Nantes\", \"Lyon\"]]\nNantes Lyon\nsinge 22 21\nsouris 32 31\n238 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.4. Dataframes Chapitre 22. Module Pandas\nNotez qu’à partir du moment où on souhaite effectuer une sélection sur des lignes, il faut utiliser (ou si\n.loc .iloc\non utilise les indices).\n22.4.3.4 Sélection par condition\nRemémorons-nous d’abord le contenu du dataframe :\ndf\n1\ndf\nParis Lyon Nantes Pau\nchat 10 11 12 13\nsinge 20 21 22 23\nsouris 30 31 32 33\nSélectionnons maintenant toutes les lignes pour lesquelles les effectifs à Pau sont supérieurs à 15 :\n1\ndf[ df[\"Pau\"]>15 ]\nParis Lyon Nantes Pau\nsinge 20 21 22 23\nsouris 30 31 32 33\nDe cette sélection, on ne souhaite garder que les valeurs pour Lyon :\n1 df[ df[\"Pau\"]>15 ][\"Lyon\"]\nsinge 21\nsouris 31\nName: Lyon, dtype: int64\nOn peut aussi combiner plusieurs conditions avec pour l’opérateur et :\n&\n1 df[ (df[\"Pau\"]>15) & (df[\"Lyon\"]>25) ]\nParis Lyon Nantes Pau\nsouris 30 31 32 33\net pour l’opérateur ou :\n|\n1\ndf[ (df[\"Pau\"]>15) | (df[\"Lyon\"]>25) ]\nParis Lyon Nantes Pau\nsinge 20 21 22 23\nsouris 30 31 32 33\n22.4.4 Combinaison de dataframes\nEn biologie, on a souvent besoin de combiner deux tableaux à partir d’une colonne commune. Par exemple, si on\nconsidère les deux dataframes suivants :\n1\ndata1 = {\"Lyon\": [10, 23, 17], \"Paris\": [3, 15, 20]}\n2 df1 = pd.DataFrame.from_dict(data1)\n3\ndf1.index = [\"chat\", \"singe\", \"souris\"]\n4 df1\nLyon Paris\nchat 10 3\nsinge 23 15\nsouris 17 20\net\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 239\nChapitre 22. Module Pandas 22.4. Dataframes\n1\ndata2 = {\"Nantes\": [3, 9, 14], \"Strasbourg\": [5, 10, 8]}\n2 df2 = pd.DataFrame.from_dict(data2)\n3\ndf2.index = [\"chat\", \"souris\", \"lapin\"]\n4 df2\nNantes Strasbourg\nchat 3 5\nsouris 9 10\nlapin 14 8\nOn souhaite combiner ces deux dataframes, c’est-à-dire connaître pour les quatre villes (Lyon, Paris, Nantes et\nStrasbourg) le nombre d’animaux. On remarque d’ores et déjà qu’il y a des singes à Lyon et Paris, mais pas de lapin et\nqu’il y a des lapins à Nantes et Strasbourg, mais pas de singe. Nous allons voir comment gérer cette situation.\n3\nPandas propose pour cela la fonction , qui prend comme argument une liste de dataframes :\nconcat()\n1\npd.concat([df1, df2])\nLyon Nantes Paris Strasbourg\nchat 10.0 NaN 3.0 NaN\nsinge 23.0 NaN 15.0 NaN\nsouris 17.0 NaN 20.0 NaN\nchat NaN 3.0 NaN 5.0\nsouris NaN 9.0 NaN 10.0\nlapin NaN 14.0 NaN 8.0\nIci, indique des valeurs manquantes, cela signifie littéralement Not a Number. Mais le résultat obtenu n’est pas\nNaN\ncelui que nous attendions, puisque les lignes de deux dataframes ont été recopiées.\nL’argument supplémentaire produit le résultat attendu :\naxis=1\n1 pd.concat([df1, df2], axis=1)\nLyon Paris Nantes Strasbourg\nchat 10.0 3.0 3.0 5.0\nlapin NaN NaN 14.0 8.0\nsinge 23.0 15.0 NaN NaN\nsouris 17.0 20.0 9.0 10.0\nPar défaut, pandas va conserver le plus de lignes possible. Si on ne souhaite conserver que les lignes communes aux\ndeux dataframes, il faut ajouter l’argument :\njoin=\"inner\"\n1 pd.concat([df1, df2], axis=1, join=\"inner\")\nLyon Paris Nantes Strasbourg\nchat 10 3 3 5\nsouris 17 20 9 10\nUn autre comportement par défaut de est que cette fonction va combiner les dataframes en se basant sur\nconcat()\nleurs index. Il est néanmoins possible de préciser, pour chaque dataframe, le nom de la colonne qui sera utilisée comme\nréférence avec l’argument .\njoin_axes\n22.4.5 Opérations vectorielles\nPour cette rubrique, créons un Dataframe composé de nombres aléatoires compris entre 100 et 200, répartis en trois\ncolonnes ( , et ) et 1 000 lignes :\na b c\n3. https://pandas.pydata.org/pandas-docs/stable/merging.html\n240 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.4. Dataframes Chapitre 22. Module Pandas\n1\nimport numpy as np\n2 import pandas as pd\n3\n4 nb_rows = 1000\n5\ndf = pd.DataFrame(\n6 {\n7 \"a\": np.random.randint(100, 200, nb_rows),\n8\n\"b\": np.random.randint(100, 200, nb_rows),\n9 \"c\": np.random.randint(100, 200, nb_rows),\n10\n}\n11 )\nVérifions que ce Dataframe a bien les propriétés attendues :\n1\ndf.shape\n(1000, 3)\n1 df.head()\na b c\n0 105 156 122\n1 116 135 138\n2 125 190 113\n3 196 175 179\n4 129 184 153\nOn souhaite maintenant créer une nouvelle colonne ( ) qui sera le résultat de la multiplication des colonnes et ,\nd a b\nà laquelle on ajoute ensuite la colonne .\nc\nUne première manière de faire est de procéder ligne par ligne. La méthode permet de parcourir les\n.iterrows()\nlignes d’un Dataframe et renvoie un tuple contenant l’indice de la ligne (sous la forme d’un entier) et la ligne elle-même\n(sous la forme d’une Series) :\n1 for idx, row in df.iterrows():\n2\ndf.at[idx, \"d\"] = (row[\"a\"] * row[\"b\"]) + row[\"c\"]\nIci, l’instruction ajoute une cellule à la ligne d’indice et de colonne . Cette instruction est plus eﬀicace que\n.at idx d\npour ajouter une cellule à un Dataframe.\n.loc\nL’approche précédente produit le résultat attendu, mais elle n’est pas optimale, car très lente. Pour évaluer le temps\nmoyen pour réaliser ces opérations, on utilise la commande magique abordée dans le chapitre 18 Jupyter et\n%%timeit\nses notebooks :\n1 %%timeit\n2\nfor idx, row in df.iterrows():\n3 df.at[idx, \"d\"] = (row[\"a\"] * row[\"b\"]) + row[\"c\"]\nqui renvoie :\n52.4 ms ± 3.6 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\nCette cellule de code s’exécute en moyenne en 52,4 ms.\nUne autre approche, plus eﬀicace, consiste à réaliser les opérations directement sur les colonnes (et non plus ligne\npar ligne) :\n1 %%timeit\n2\ndf[\"d\"] = (df[\"a\"] * df[\"b\"]) + df[\"c\"]\nqui renvoie :\n250 µs ± 36.1 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\nIci, la cellule de code s’exécute en moyenne en 250 µs, soit environ 200 fois (52400/250) plus rapidement qu’avec\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 241\nChapitre 22. Module Pandas 22.5. Un exemple plus concret avec les kinases\n. Tout comme avec les arrays du chapitre 20 Numpy, les opérations vectorielles avec les Dataframes sont\n.iterrows()\nrapides et eﬀicaces. Privilégiez toujours ce type d’approche avec les arrays de NumPy ou les Series et Dataframes de\npandas.\nRemarque\nDans l’exemple précédent, l’utilisation de la commande magique calcule le temps d’exécution moyen d’une\n%%timeit\ncellule. Python détermine automatiquement le nombre d’itérations à réaliser pour que le calcul se fasse dans un temps\nraisonnable. Ainsi, pour la méthode , le calcul est réalisé 10 fois sur sept répétitions alors que pour les\n.iterrows()\nopérations vectorielles, le calcul est effectué 1000 fois sur sept répétitions."
  },
  {
    "title": "Un exemple plus concret avec les kinases",
    "content": "4\nPour illustrer les possibilités de pandas, voici un exemple plus concret sur un jeu de données de kinases . Les kinases\nsont des protéines responsables de la phosphorylation d’autres protéines.\n5\nLe fichier que vous pouvez télécharger en ligne contient des informations tirées de la base de données\nkinases.csv\nde séquences UniProt pour quelques kinases.\nSi vous n’êtes pas familier avec le format de fichier , nous vous conseillons de consulter l’annexe A Quelques\n.csv\nformats de données en biologie.\nRemarque\nAvant de nous lancer dans l’analyse de ce fichier, nous vous proposons cette petite devinette :\nQu’est-ce qu’une protéine dans une piscine ?\nLa réponse sera donnée à la fin de ce chapitre.\n22.5.1 Prise de contact avec le jeu de données\nUne fonctionnalité très intéressante de pandas est d’ouvrir très facilement un fichier au format :\n.csv\n1 df = pd.read_csv(\"kinases.csv\")\nLe contenu est chargé sous la forme d’un Dataframe dans la variable .\ndf\nLe fichier contient 1 442 lignes de données plus une ligne d’en-tête. Cette dernière est automatiquement utilisée par\npandas pour nommer les différentes colonnes. Voici un aperçu des premières lignes :\n1\ndf.head()\nEntry Organism Length Creation date Mass PDB\n0 A0A0B4J2F2 Human 783 2018-06-20 84930 NaN\n1 A4L9P5 Rat 1211 2007-07-24 130801 NaN\n2 A0A1D6E0S8 Maize 856 2023-05-03 93153 NaN\n3 A0A8I5ZNK2 Rat 528 2023-09-13 58360 NaN\n4 A1Z7T0 Fruit fly 1190 2012-01-25 131791 NaN\nNous avons six colonnes de données :\n•\nl’identifiant de la protéine ( ) ;\nEntry\n•\nl’organisme d’où provient cette protéine ( ) ;\nOrganism\n•\nle nombre d’acides aminés qui constituent la protéine ( ) ;\nLength\n•\nla date à laquelle cette protéine a été déréférencée dans UniProt ( ) ;\nCreation date\n•\nla masse de la protéine ( ), exprimée en Dalton ;\nMass\n•\nles éventuelles structures 3D de la protéine ( ).\nPDB\n4.\nhttps://fr.wikipedia.org/wiki/Kinase\n5. https://python.sdv.u-paris.fr/data-files/kinases.csv\n242 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.5. Un exemple plus concret avec les kinases Chapitre 22. Module Pandas\nLa colonne d’entiers tout à gauche est un index automatiquement créé par pandas.\nNous pouvons demander à pandas d’utiliser une colonne particulière comme index. On utilise pour cela le paramètre\nde la fonction . Ici, la colonne s’y prête très bien, car cette colonne ne contient que des\nindex_col read_csv() Entry\nidentifiants uniques :\n1 df = pd.read_csv(\"kinases.csv\", index_col=\"Entry\")\n2\ndf.head()\nOrganism Length Creation date Mass PDB\nEntry\nA0A0B4J2F2 Human 783 2018-06-20 84930 NaN\nA4L9P5 Rat 1211 2007-07-24 130801 NaN\nA0A1D6E0S8 Maize 856 2023-05-03 93153 NaN\nA0A8I5ZNK2 Rat 528 2023-09-13 58360 NaN\nA1Z7T0 Fruit fly 1190 2012-01-25 131791 NaN\nRemarque\nLa fonction permet également d’ouvrir un fichier au format TSV (voir l’annexe A Quelques formats de\n.read_csv()\ndonnées en biologie). Il faut pour cela préciser que le séparateur des colonnes de données est une tabulation ( ), avec\n\\t\nl’argument .\nsep=\"\\t\"\nAvant d’analyser un jeu de données, il est intéressant de l’explorer un peu. Par exemple, connaître ses dimensions :\n1\ndf.shape\n(1442, 5)\nNotre jeu de données contient donc 1 442 lignes et 5 colonnes. En effet, la colonne est maintenant utilisée\nEntry\ncomme index et n’est donc plus prise en compte.\nIl est aussi intéressant de savoir de quel type de données est constituée chaque colonne :\n1\ndf.dtypes\nOrganism object\nLength int64\nCreation date object\nMass int64\nPDB object\ndtype: object\nLes colonnes et contiennent des valeurs numériques, en l’occurrence des entiers ( ). Le type\nLength Mass int64\nest un type par défaut.\nobject\nLa méthode permet d’aller un peu plus loin dans l’exploration du jeu de données en combinant les informa-\n.info()\ntions produites par les propriétés et :\n.shape .dtypes\n1 df.info()\n<class 'pandas.core.frame.DataFrame'>\nIndex: 1442 entries, A0A0B4J2F2 to Q5F361\nData columns (total 5 columns):\n# Column Non-Null Count Dtype\n--- ------ -------------- -----\n0 Organism 1442 non-null object\n1 Length 1442 non-null int64\n2 Creation date 1442 non-null object\n3 Mass 1442 non-null int64\n4 PDB 488 non-null object\ndtypes: int64(2), object(3)\nmemory usage: 67.6+ KB\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 243\nChapitre 22. Module Pandas 22.5. Un exemple plus concret avec les kinases\nAvec l’argument , la méthode permet de connaitre avec précision la quantité de\nmemory_usage=\"deep\" .info()\nmémoire vive occupée par le Dataframe :\n1 df.info(memory_usage=\"deep\")\n<class 'pandas.core.frame.DataFrame'>\nIndex: 1442 entries, A0A0B4J2F2 to Q5F361\nData columns (total 5 columns):\n# Column Non-Null Count Dtype\n--- ------ -------------- -----\n0 Organism 1442 non-null object\n1 Length 1442 non-null int64\n2 Creation date 1442 non-null object\n3 Mass 1442 non-null int64\n4 PDB 488 non-null object\ndtypes: int64(2), object(3)\nmemory usage: 351.0 KB\nIci, le Dataframe occupe 351 kilo-octets (ko) en mémoire.\n22.5.2 Recherche de valeurs manquantes\nIl est aussi utile de savoir si des valeurs manquantes sont présentes dans le jeu de données. Ces valeurs manquantes\ncorrespondent à des champs pour lesquels aucune valeur n’ont été fournies. Elles sont souvent représentées par (pour\nNaN\nNot a Number).\nLa méthode renvoie un Dataframe de la même dimension que le Dataframe initial, mais avec des valeurs\n.isna()\nbooléennes ( si la valeur est manquante ( ) ou sinon). En le combinant avec la méthode , on peut\nTrue NaN False .sum()\ncompter le nombre de valeurs manquantes pour chaque colonne :\n1 df.isna().sum()\nOrganism 0\nLength 0\nCreation date 0\nMass 0\nPDB 954\ndtype: int64\nIci, la seule colonne qui contient des valeurs manquantes est la colonne , qui contient 954 valeurs manquantes.\nPDB\nCela signifie que pour 954 protéines, aucune structure 3D n’est disponible. Nous reviendrons plus tard sur cette colonne\n.\nPDB\n22.5.3 Conversion en date\nLe type correspond la plupart du temps à des chaînes de caractères. C’est tout à fait légitime pour la colonne\nobject\n. Mais on sait par contre que la colonne est une date sous la forme année-mois-jour.\nOrganism Creation date\nSi le format de date utilisé est homogène sur tout le jeu de données et non ambigu, on peut demander à pandas\nde considérer la colonne comme une date. pandas détectera alors automatiquement le format de date\nCreation Date\nutilisé :\n1 df[\"Creation date\"] = pd.to_datetime(df[\"Creation date\"])\nL’aﬀichage des données n’est pas modifié :\n1\ndf.head()\nOrganism Length Creation date Mass PDB\nEntry\nA0A0B4J2F2 Human 783 2018-06-20 84930 NaN\nA4L9P5 Rat 1211 2007-07-24 130801 NaN\nA0A1D6E0S8 Maize 856 2023-05-03 93153 NaN\nA0A8I5ZNK2 Rat 528 2023-09-13 58360 NaN\nA1Z7T0 Fruit fly 1190 2012-01-25 131791 NaN\n244 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.5. Un exemple plus concret avec les kinases Chapitre 22. Module Pandas\nMais le type de données de la colonne est maintenant une date ( ) :\nCreation date datetime64[ns]\n1 df.dtypes\nOrganism object\nLength int64\nCreation date datetime64[ns]\nMass int64\nPDB object\ndtype: object\n22.5.4 Statistiques descriptives et table de comptage\nPour les colonnes qui contiennent des données numériques, on peut obtenir rapidement quelques statistiques descrip-\ntives avec la méthode :\n.describe()\n1 df.describe()\nLength Creation date Mass\ncount 1442.000000 1442 1442.000000\nmean 756.139390 2001-01-25 16:10:39.112344064 84710.753814\nmin 81.000000 1986-07-21 00:00:00 9405.000000\n25% 476.250000 1996-10-01 00:00:00 54059.000000\n50% 632.000000 2002-03-10 00:00:00 71613.000000\n75% 949.250000 2005-11-22 00:00:00 105485.250000\nmax 2986.000000 2023-09-13 00:00:00 340261.000000\nstd 404.195273 NaN 44764.273097\nOn apprend ainsi que la taille de la protéine (colonne ) a une valeur moyenne de 756,14 acides aminés et que\nLength\nla plus petite protéine est composée de 81 acides aminés et la plus grande de 2 986. Pratique !\nDes statistiques sont également proposées pour la colonne . La protéine la plus récente a ainsi été\nCreation date\nréférencée le 13 septembre 2023.\nLa colonne contient des chaînes de caractères, on peut rapidement déterminer le nombre de protéines pour\nOrganism\nchaque organisme :\n1 df[\"Organism\"].value_counts()\nOrganism\nHuman 489\nMouse 489\nRat 253\nFruit fly 103\nChicken 75\nRabbit 25\nMaize 8\nName: count, dtype: int64\nOn apprend ainsi que 489 protéines sont d’origine humaine ( ) et 8 proviennent du maïs ( ).\nHuman Maize\n22.5.5 Statistiques par groupe\nOn peut aussi déterminer, pour chaque organisme, la taille et la masse moyenne des kinases :\n1\ndf.groupby([\"Organism\"])[[\"Length\", \"Mass\"]].mean()\nLength Mass\nOrganism\nChicken 720.160000 81120.880000\nFruit fly 784.844660 88154.669903\nHuman 771.004090 86281.190184\nMaize 666.875000 73635.000000\nMouse 768.092025 85942.274029\nRabbit 591.480000 66754.200000\nRat 722.379447 81081.822134\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 245\nChapitre 22. Module Pandas 22.5. Un exemple plus concret avec les kinases\nLa méthode rassemble d’abord les données suivant la colonne . Puis on sélectionne les colonnes\n.groupby() Organism\net . Enfin, la méthode calcule la moyenne pour chaque groupe.\nLength Mass .mean()\nSi on souhaite obtenir deux statistiques (par exemple les valeurs minimale et maximale) en une seule fois, il convient\nalors d’utiliser la méthode , méthode plus complexe, mais aussi beaucoup plus puissante :\n.pivot_table()\n1\ndf.pivot_table(\n2 index=\"Organism\",\n3\nvalues=[\"Length\", \"Mass\"],\n4 aggfunc=[\"min\", \"max\"]\n5\n)\nmin max\nLength Mass Length Mass\nOrganism\nChicken 303 34688 2311 260961\nFruit fly 294 33180 2554 287025\nHuman 253 28160 2986 340261\nMaize 294 33834 996 105988\nMouse 244 27394 2964 337000\nRabbit 81 9405 1382 158347\nRat 274 31162 2959 336587\n•\nL’argument précise la colonne dont on veut agréger les données.\nindex\n•\nL’argument indique sur quelles colonnes les statistiques sont calculées.\nvalues\n•\nEnfin, liste les statistiques calculées, ici les valeurs minimale et maximale.\naggfunc\nNotez que les valeurs renvoyées sont d’abord les valeurs minimales pour et puis les valeurs maximales\nLength Mass\npour et .\nLength Mass\n22.5.6 Analyse de données numériques\nOn peut, sans trop de risque, émettre l’hypothèse que plus il y a d’acides aminés dans la protéine, plus sa masse va\nêtre élevée.\nPour vérifier cela graphiquement, on représente la masse de la protéine en fonction de sa taille (c’est-à-dire du nombre\nd’acides aminés) :\n1\nimport matplotlib.pyplot as plt\n2\n3\nfig, ax = plt.subplots()\n4 ax.scatter(df[\"Length\"], df[\"Mass\"])\n5\nax.set_xlabel(\"Taille (nombre d'acides aminés)\")\n6 ax.set_ylabel(\"Masse (Dalton)\")\n7\nfig.savefig(\"kinases1.png\")\nOn obtient un graphique similaire à celui de la figure 22.1.\nAvec pandas, on peut aussi appeler une méthode sur un Dataframe pour obtenir une représentation graphique\n.plot()\nidentique à la figure 22.1 :\n1 import matplotlib.pyplot as plt\n2\n3 df.plot(\n4\nkind=\"scatter\",\n5 x=\"Length\",\n6\ny=\"Mass\",\n7 xlabel=\"Taille (nombre d'acides aminés)\",\n8 ylabel=\"Masse (Dalton)\"\n9 )\n10 plt.savefig(\"kinases1.png\")\n•\nLigne 4. On spécifie le type de graphique. Ici, un nuage de points.\n•\nLignes 5 et 6. On précise les colonnes à utiliser pour les abscisses et les ordonnées.\nLe graphique de la figure 22.1 met en évidence une relation linéaire entre le nombre de résidus d’une protéine et sa\nmasse.\n246 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.5. Un exemple plus concret avec les kinases Chapitre 22. Module Pandas\nFigure 22.1 – Masse en fonction de la taille.\nEn réalisant une régression linéaire, on peut déterminer les paramètres de la droite qui passent le plus proche possible\n6\ndes points du graphique. On utilise pour cela la fonction du module :\nlinregress() scipy.stats\n1 from scipy.stats import linregress\n2\nmodel = linregress(df[\"Length\"], df[\"Mass\"])\n3 model\nLinregressResult(slope=110.63478918698122, intercept=1055.431834679228,\nrvalue=0.9989676084416755, pvalue=0.0, stderr=0.13258187632073232,\nintercept_stderr=113.66584551734655)\nCe modèle linéaire nous indique qu’un résidu a une masse d’environ 111 Dalton, ce qui est cohérent. On peut également\ncomparer ce modèle aux différentes protéines :\n1\nfig, ax = plt.subplots()\n2 ax.scatter(df[\"Length\"], df[\"Mass\"], label=\"données\")\n3\nax.plot(\n4 df[\"Length\"],\n5\ndf[\"Length\"]*model.slope + model.intercept,\n6 ls=\":\",\n7 label=\"modèle\"\n8\n)\n9 ax.set_xlabel(\"Taille (nombre d'acides aminés)\")\n10\nax.set_ylabel(\"Masse (Dalton)\")\n11 ax.legend()\n12\nfig.savefig(\"kinases2.png\")\nOn obtient ainsi le graphique de la figure 22.2.\n22.5.7 Analyse de données temporelles\nIl peut être intéressant de savoir, pour chaque organisme, quand les premières et les dernières séquences de kinases\nont été référencées dans UniProt.\n6. https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 247\nChapitre 22. Module Pandas 22.5. Un exemple plus concret avec les kinases\nFigure 22.2 – Masse en fonction de la taille des protéines.\nLa méthode apporte des éléments de réponse :\n.pivot_table()\n1 df.pivot_table(\n2\nindex=\"Organism\",\n3 values=[\"Creation date\"],\n4\naggfunc=[\"min\", \"max\"]\n5 )\nmin max\nCreation date Creation date\nOrganism\nChicken 1986-07-21 2021-02-10\nFruit fly 1986-07-21 2023-09-13\nHuman 1986-07-21 2018-06-20\nMaize 1990-08-01 2023-05-03\nMouse 1986-07-21 2017-03-15\nRabbit 1986-07-21 2010-03-02\nRat 1986-07-21 2023-09-13\nChez le poulet (Chicken), la première séquence a été référencée le 21 juillet 1986 et la dernière le 10 février 2021.\nUne autre question est de savoir combien de kinases ont été référencées en fonction du temps.\nLa méthode peut être utilisée, mais elle ne renvoie que le nombre de protéines référencées dans\n.value_counts()\nUniProt pour un jour donné. Par exemple, 40 structures ont été référencées le 28 novembre 2006 :\n1 df[\"Creation date\"].value_counts().head()\nCreation date\n1997-11-01 72\n1996-10-01 58\n2000-12-01 43\n2000-05-30 41\n2006-11-28 40\nName: count, dtype: int64\n248 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.5. Un exemple plus concret avec les kinases Chapitre 22. Module Pandas\nSi on souhaite une réponse plus globale, par exemple à l’échelle de l’année, la méthode calcule le\n.resample()\nnombre de protéines référencées par an (en fournissant l’argument ). En utilisant le method chaining présenté dans le\nYE\nchapitre 11 Plus sur les chaînes de caractères, nous pouvons écrire toutes ces transformations en une seule instruction,\nrépartie sur plusieurs lignes pour plus de lisibilité (en utilisant des parenthèses) :\n1 (df[\"Creation date\"]\n2\n.value_counts()\n3 .resample(\"YE\")\n4\n.sum()\n5 .head()\n6\n)\nCreation date\n1986-12-31 11\n1987-12-31 12\n1988-12-31 32\n1989-12-31 29\n1990-12-31 40\nFreq: YE-DEC, Name: count, dtype: int64\nLes dates apparaissent maintenant comme le dernier jour de l’année (31 décembre), mais désignent bien l’année\ncomplète. Dans cet exemple, 11 kinases ont été référencées dans UniProt entre le 1er janvier et le 31 décembre 1986.\nPour connaître en quelle année le plus de kinases ont été référencées dans UniProt, il faut trier les valeurs obtenues\ndu plus grand au plus petit avec la méthode . Comme on ne veut connaître que les premières dates\n.sort_values()\n(celles où il y a eu le plus de protéines référencées), on utilisera également la méthode :\n.head()\n1 (df[\"Creation date\"]\n2\n.value_counts()\n3 .resample(\"YE\")\n4\n.sum()\n5 .sort_values(ascending=False)\n6\n.head()\n7 )\nCreation date\n2006-12-31 167\n2005-12-31 136\n2004-12-31 118\n2003-12-31 104\n2007-12-31 88\nName: count, dtype: int64\nEn 2006, 167 kinases ont été référencées dans UniProt. La deuxième « meilleure » année est 2005 avec 136 protéines.\nToutes ces méthodes, enchaînées les unes à la suite des autres, peuvent vous sembler complexes, mais chacune d’elles\ncorrespond à une étape du traitement des données. Bien sûr, on aurait pu créer des variables intermédiaires pour chaque\nétape, mais cela aurait été plus lourd :\n1 date1 = df[\"Creation date\"].value_counts()\n2\ndate2 = date1.resample(\"YE\")\n3 date3 = date2.sum()\n4\ndate4 = date3.sort_values(ascending=False)\n5 date4.head()\nOn aurait obtenu exactement le même résultat.\nRemarque\n7\nLe method chaining est une manière eﬀicace et élégante de traiter des données avec pandas.\nEnfin, pour obtenir un graphique de l’évolution du nombre de kinases référencées dans UniProt en fonction du temps,\n7. https://www.youtube.com/watch?v=39MEeDLxGGg\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 249\nChapitre 22. Module Pandas 22.5. Un exemple plus concret avec les kinases\non peut encore utiliser le method chaining :\n1 import matplotlib.pyplot as plt\n2\n(df[\"Creation date\"]\n3 .value_counts()\n4\n.resample(\"YE\")\n5 .sum()\n6 .plot()\n7 )\n8 plt.savefig(\"kinases3.png\")\nOn obtient ainsi le graphique de la figure 22.3.\nFigure 22.3 – Évolution temporelle du nombre de kinases référencées dans UniProt.\nOn observe un pic du nombre de kinases référencées dans UniProt sur la période 2003-2007.\n22.5.8 Transformation d’une colonne\nNous avons vu précédemment que la colonne contenait de nombreuses valeurs manquantes ( ). Toutefois, il\nPDB NaN\nest intéressant de savoir ce que peut contenir cette colonne quand elle n’est pas vide :\n1\n(df\n2 .loc[ ~ df[\"PDB\"].isna() ]\n3 .head(3)\n4\n)\nOrganism Length Creation date Mass PDB\nEntry\nA2CG49 Mouse 2964 2007-10-23 337000 1WFW;7UR2;\nD3ZMK9 Rat 1368 2018-07-18 147716 6EWX;\nO00141 Human 431 1998-12-15 48942 2R5T;3HDM;3HDN;7PUE;\n•\nLigne 2. La méthode sélectionne les lignes qui contiennent des valeurs manquantes dans la colonne ,\nisna() PDB\npuis l’opérateur inverse cette sélection.\n~\n•\nLigne 3. On limite l’aﬀichage aux trois premières lignes.\n250 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.5. Un exemple plus concret avec les kinases Chapitre 22. Module Pandas\nOn découvre que la colonne contient des identifiants de structures 3D de protéines. Ces identifiants sont séparés\nPDB\npar des points-virgules, y compris pour la dernière valeur.\nNous souhaitons compter le nombre de structures 3D pour chaque protéine. Pour cela, nous allons d’abord créer une\nfonction qui compte le nombre de points-virgules dans une chaîne de caractères :\n1 def count_structures(row):\n2\nif pd.isna(row[\"PDB\"]):\n3 return 0\n4\nelse:\n5 return row[\"PDB\"].count(\";\")\nDans la ligne 2, la méthode teste si la valeur est manquante et si ce n’est pas le cas, la fonction renvoie le\n.isna()\nnombre de points-virgules dans la chaîne de caractères de la colonne (ligne 5).\nPDB\nOn applique ensuite la fonction au Dataframe avec la méthode . On crée la nouvelle\ncount_structures() .apply()\ncolonne en même temps :\nnb_structures\n1 df[\"nb_structures\"] = df.apply(count_structures, axis=1)\n2\ndf.head()\nOrganism Length Creation date Mass PDB nb_structures\nEntry\nA0A0B4J2F2 Human 783 2018-06-20 84930 NaN 0\nA4L9P5 Rat 1211 2007-07-24 130801 NaN 0\nA0A1D6E0S8 Maize 856 2023-05-03 93153 NaN 0\nA0A8I5ZNK2 Rat 528 2023-09-13 58360 NaN 0\nA1Z7T0 Fruit fly 1190 2012-01-25 131791 NaN 0\nLes premières lignes ne sont pas très intéressantes, car elles ne contiennent pas de structures 3D. Mais on peut\nchercher les kinases qui ont le plus de structures 3D :\n1 (df\n2\n.sort_values(by=\"nb_structures\", ascending=False)\n3 .filter([\"Organism\", \"nb_structures\"])\n4\n.head()\n5 )\n•\nLigne 2. On trie les données par ordre décroissant de la colonne .\nnb_structures\n•\nLigne 3. On ne conserve que les colonnes et à aﬀicher.\nOrganism nb_structures\n•\nLigne 4. On limite l’aﬀichage aux cinq premières lignes.\nOrganism nb_structures\nEntry\nP24941 Human 453\nP00533 Human 284\nQ16539 Human 245\nP68400 Human 238\nP11309 Human 176\nLa kinase possède 453 structures 3D référencées dans UniProt. Les cinq kinases qui ont le plus de structures\nP24941\n3D sont toutes d’origine humaine.\nPour aller plus loin\nLes ouvrages Python for Data Analysis (2022) de Wes McKinney et Effective Pandas (2021) de Matt Harrison sont\nd’excellentes références pour pandas.\nRemarque\nLa réponse à la devinette précédente est :\nUne protéine kinase\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 251\nChapitre 22. Module Pandas 22.6. Exercices\n(Une protéine qui nage… dans une piscine… Vous l’avez ?)"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, utilisez des notebooks Jupyter.\n22.6.1 Analyse d’un jeu de données\nLe jeu de données contient les caractéristiques de quelques individus : prénom, sexe, taille (en cm) et\npeople.tsv\nâge (en années). Par exemple :\nname sex size age\nsimon male 175 33\nclara female 167 45\nserge male 181 44\nclaire female 174 31\n… … … …\nL’objectif de cet exercice est de manipuler ce jeu de données avec pandas, de sélectionner des données et d’en calculer\nquelques statistiques.\nConseil\nSi vous n’êtes pas familier avec le format de fichier , nous vous conseillons de consulter l’annexe A Quelques\n.tsv\nformats de données en biologie.\n1. Chargement du jeu de données\n•\n8\nTéléchargez le fichier people.tsv .\n•\nOuvrez ce fichier avec pandas et la fonction . N’oubliez pas de préciser le séparateur par défaut\n.read_csv()\navec l’argument . Utilisez également l’argument pour utiliser la colonne comme\nsep=\"\\t\" index_col name\nindex.\n•\nAﬀichez les six premières lignes du jeu de données.\n•\nCombien de lignes contient le jeu de données ?\n2. Sélections\n•\nDéterminez la taille de Claire.\n•\nDéterminez l’âge de Baptiste.\n•\nAﬀichez, en une seule commande, l’âge de Paul et Bob.\n3. Statistiques descriptives et table de comptage\n•\nDéterminez la moyenne et la valeur minimale de la taille et l’âge des individus.\n•\nComptez ensuite le nombre de personnes de chaque sexe.\n4. Statistiques par groupe\n•\nDéterminez la taille et l’âge moyen chez les hommes et les femmes. Utilisez pour cela la méthode .\n.groupby()\n5. Sélections par filtre\n•\nDéterminez combien de d’individus mesurent plus de 1,80 m.\n•\nQuelle femme a moins de 35 ans ?\n6. Sélections et statistiques\n•\nDéterminez l’âge moyen des individus qui mesurent plus de 1,80 m.\n8. https://python.sdv.u-paris.fr/data-files/people.tsv\n252 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n22.6. Exercices Chapitre 22. Module Pandas\n•\nDéterminez la taille maximale des femmes qui ont plus de 35 ans.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 253"
  },
  {
    "title": "Avoir la classe avec les objets",
    "content": "La programmation orientée objet (POO) est un concept de programmation très puissant qui permet de structurer ses\nprogrammes d’une manière nouvelle. En POO, on définit un « objet » qui peut contenir des « attributs » ainsi que des «\nméthodes » qui agissent sur lui-même. Par exemple, on définit un objet « citron » qui contient les attributs « saveur » et\n« couleur », ainsi qu’une méthode « presser » permettant d’en extraire le jus. En Python, on utilise une « classe » pour\nconstruire un objet. Dans notre exemple, la classe correspondrait au « moule » utilisé pour construire autant d’objets\ncitrons que nécessaire.\nDéfinition\nUne classe définit des objets, qui sont des instances (des représentants) de cette classe. Dans ce chapitre, on utilisera\nles mots objet ou instance pour désigner la même chose. Les objets peuvent posséder des attributs (variables associées\naux objets) et des méthodes (qui sont des fonctions associées aux objets et qui peuvent agir sur ces derniers, ou encore\nles utiliser).\nDans les chapitres précédents, nous avons déjà mentionné qu’en Python tout est objet. Une variable de type int est\nen fait un objet de type int, donc construit à partir de la classe int. Même chose pour les float et string, mais aussi pour\nles list, tuple, dict, etc. Voilà pourquoi nous avons rencontré de nombreuses notations et mots de vocabulaire associés à\nla POO depuis le début de ce cours.\nLa POO permet de produire du code plus compact et plus facilement réutilisable. L’utilisation de classes évite\nl’utilisation de variables globales en créant ce qu’on appelle un espace de noms, propre à chaque objet et permettant\nd’y encapsuler des attributs et des méthodes. De plus, la POO amène de nouveaux concepts tels que le polymorphisme\n(capacité à redéfinir le comportement des opérateurs), ou bien encore l’héritage (capacité à définir une classe à partir\nd’une classe pré-existante et d’y ajouter de nouvelles fonctionnalités). Tous ces concepts seront définis dans ce chapitre.\nMalgré tous ces avantages, la POO peut paraître diﬀicile à aborder pour le débutant, spécialement dans la conception\ndes programmes. Elle nécessite donc la lecture de nombreux exemples, mais surtout beaucoup de pratique. Bien structurer\nses programmes en POO est un véritable art. Il existe même des langages qui formalisent la construction de programmes\n1\norientés objets, par exemple le langage UML .\nDans ce chapitre, nous vous donnerons tous les éléments pour démarrer la construction de vos premières classes.\nLe chapitre 24 Avoir plus la classe avec les objets (en ligne) abordera des aspects plus poussés de la POO, comme le\npolymorphisme, la composition, l’héritage, certains pièges à éviter, ainsi que des bonnes pratiques.\n1. https://fr.wikipedia.org/wiki/UML_(informatique)\n254\n23.1. Construction d’une classe Chapitre 23. Avoir la classe avec les objets\nAprès la lecture de ces deux chapitres sur la POO avec Python, vous verrez d’un autre œil de nombreux exemples\névoqués dans les chapitres précédents, et vous comprendrez sans doute de nombreuses subtilités qui avaient pu vous\nparaître absconses.\nEnfin, il est vivement recommandé de lire ces deux chapitres sur la POO avant d’aborder le chapitre 25 Fenêtres\ngraphiques et Tkinter (en ligne)."
  },
  {
    "title": "Construction d’une classe",
    "content": "Nous allons voir dans cette rubrique comment définir une classe en reprenant notre exemple sur le citron, que nous\nallons faire évoluer et complexifier. Attention, certains exemples sont destinés à vous montrer comment les classes\nfonctionnent, mais leur utilisation n’aurait pas de sens dans un vrai programme. Ainsi, nous vous donnerons plus loin\ndans ce chapitre les pratiques recommandées.\n23.1.1 La classe minimale\nEn Python, le mot-clé permet de créer sa propre classe, suivi du nom de cette classe. On se souvient, un\nclass\nnom de classe commence toujours par une majuscule (voir le chapitre 16 Bonnes pratiques en programmation Python).\nComme d’habitude, cette ligne attend un bloc d’instructions indenté définissant le corps de la classe. Voyons un exemple\nsimple dans l’interpréteur :\n1 >>> class Citron:\n2 ... pass\n3\n...\n4 >>> Citron\n5\n<class '__main__.Citron'>\n6 >>> type(Citron)\n7\n<class 'type'>\n8 >>> citron1 = Citron()\n9\n>>> citron1\n10 <__main__.Citron object at 0x7ff2193a20f0>\n11\n>>>\nLigne 1. La classe est définie. Pas besoin de parenthèses comme avec les fonctions dans un cas simple comme\nCitron\ncelui-là (nous verrons d’autres exemples plus loin où elles seront nécessaires).\nLigne 2. La classe ne contient rien, mais il faut mettre au moins une ligne, on met donc ici le mot-clé Python\npass\nqui ne fait rien (comme dans une fonction qui ne fait rien).\nLignes 4 et 5. Quand on tape le nom de notre classe , Python nous indique que cette classe est connue.\nCitron\nLignes 6 et 7. Lorsqu’on regarde le type de notre classe , Python nous indique qu’il s’agit d’un type au même\nCitron\ntitre que . Nous avons donc créé un nouveau type !\ntype(int)\nLigne 8. On crée une instance de la classe , c’est-à-dire qu’on fabrique un représentant ou objet de la classe\nCitron\n, que nous nommons .\nCitron citron1\nLignes 9 et 10. Lorsqu’on tape le nom de l’instance , l’interpréteur nous rappelle qu’il s’agit d’un objet de\ncitron1\ntype , ainsi que son adresse en mémoire.\nCitron\nIl est également possible de vérifier qu’une instance est bien issue d’une classe donnée avec la fonction :\nisinstance()\n1\n>>> isinstance(citron1, Citron)\n2 True\n23.1.2 Ajout d’un attribut d’instance\nReprenons notre classe et l’instance créée précédemment. Regardons les attributs et méthodes que\nCitron citron1\ncet objet possède, puis tentons de lui ajouter un attribut :\n1\n>>> dir(citron1)\n2 ['__class__', '__delattr__', '__dict__', [...], '__weakref__']\n3\n>>> citron1.couleur = \"jaune\"\n4 >>> dir(citron1)\n5\n['__class__', '__delattr__', '__dict__', [...], '__weakref__', 'couleur']\n6 >>> citron1.couleur\n7\n'jaune'\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 255\nChapitre 23. Avoir la classe avec les objets 23.1. Construction d’une classe\nLignes 1 et 2. L’objet possède de nombreuses méthodes ou attributs, qui commencent et qui se terminent par deux\ncaractères underscores. On se souvient que les underscores indiquent qu’il s’agit de méthodes ou attributs destinés au\nfonctionnement interne de l’objet. Nous reviendrons sur certains d’entre-eux dans la suite.\nLigne 3. Ici on ajoute un attribut à l’instance . Notez bien la syntaxe et\n.couleur citron1 instance.attribut\nle point qui lie les deux.\nLignes 4 à 5. La fonction nous montre que l’attribut a bien été ajouté à l’objet.\ndir() .couleur\nLignes 6. La notation donne accès à l’attribut de l’objet.\ninstance.attribut\nL’attribut nommé est particulièrement intéressant. Il s’agit d’un dictionnaire qui listera les attributs créés\n.__dict__\ndynamiquement dans l’instance en cours :\n1 >>> citron1 = Citron()\n2\n>>> citron1.__dict__\n3 {}\n4\n>>> citron1.couleur = \"jaune\"\n5 >>> citron1.__dict__\n6\n{'couleur': 'jaune'}\nL’ajout d’un attribut depuis l’extérieur de la classe (on parle aussi du côté « client ») avec une syntaxe\ninstance.\n, créera ce nouvel attribut uniquement pour cette instance :\nnouvel_attribut = valeur\n1 citron1 = Citron()\n2\ncitron1.couleur = \"jaune\"\n3 >>> citron1.__dict__\n4\n{'couleur': 'jaune'}\n5 >>> citron2 = Citron()\n6\n>>> citron2.__dict__\n7 {}\nSi on crée une nouvelle instance de , ici , elle n’aura pas l’attribut\nCitron citron2\nà sa création.\ncouleur\nDéfinition\nUne variable ou attribut d’instance est une variable accrochée à une instance et qui lui est spécifique. Cet attribut\nn’existe donc pas forcément pour toutes les instances d’une classe donnée et, d’une instance à l’autre, il ne prendra\npas forcément la même valeur. On peut retrouver tous les attributs d’instance d’une instance donnée avec une syntaxe\n.\ninstance.__dict__\nL’instruction fonctionne bien sûr pour détruire un objet (par exemple : ), mais permet également\ndel del citron1\nde détruire un attribut d’instance. Si on reprend notre exemple ci-dessus :\ncitron1\n1\n>>> citron1.__dict__\n2 {'couleur': 'jaune'}\n3\n>>> del citron1.couleur\n4 >>> citron1.__dict__\n5\n{}\nDans la suite, on montrera du code à tester dans un script : n’hésitez pas, comme d’habitude, à le tester par\nvous-même.\n23.1.3 Les attributs de classe\nSi on ajoute une variable dans une classe comme on créait une variable locale dans une fonction, on crée ce qu’on\nappelle un attribut de classe :\n1\nclass Citron:\n2 couleur = \"jaune\"\nDéfinition\n256 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n23.1. Construction d’une classe Chapitre 23. Avoir la classe avec les objets\nUne variable de classe ou attribut de classe est un attribut qui sera identique pour chaque instance. On verra plus\nbas que de tels attributs suivent des règles différentes par rapport aux attributs d’instance.\nÀ l’extérieur ou à l’intérieur d’une classe, un attribut de classe peut se retrouver avec une syntaxe\nNomClasse.\n:\nattribut\n1\nprint(Citron.couleur)\nCe code aﬀiche . L’attribut de classe est aussi visible depuis n’importe quelle instance :\njaune\n1\nclass Citron:\n2 couleur = \"jaune\"\n3\n4\n5 if __name__ == \"__main__\":\n6\ncitron1 = Citron()\n7 print(citron1.couleur)\n8\ncitron2 = Citron()\n9 print(citron2.couleur)\nL’exécution de ce code aﬀichera :\njaune\njaune\nAttention\nMême si on peut retrouver un attribut de classe avec la syntaxe , un tel attribut ne peut pas\ninstance.attribut\nêtre modifié avec une instruction de cette forme :\n1\ninstance.attribut = nouvelle_valeur\n(voir la rubrique Différence entre les attributs de classe et d’instance).\n23.1.4 Les méthodes\nDans notre classe, on pourra aussi ajouter des fonctions.\nDéfinition\nUne fonction définie au sein d’une classe est appelée méthode. Pour exécuter une méthode à l’extérieur de la classe,\nla syntaxe générale est . En général, on distingue attributs et méthodes (comme nous le ferons\ninstance.méthode()\nsystématiquement dans ce chapitre). Toutefois, il faut garder à l’esprit qu’une méthode est finalement un objet de type\nfonction. Ainsi, elle peut être vue comme un attribut également, concept que vous croiserez peut-être en consultant de\nla documentation externe.\nVoici un exemple d’ajout d’une fonction, ou plus exactement d’une méthode, au sein d’une classe (attention à\nl’indentation !) :\n1 class Citron:\n2\ndef coucou(self):\n3 print(\"Coucou, je suis la mth .coucou() dans la classe Citron !\")\n4\n5\n6\nif __name__ == \"__main__\":\n7 citron1 = Citron()\n8\ncitron1.coucou()\nLignes 2 et 3. On définit une méthode nommée , qui va aﬀicher un petit message. Attention, cette\n.coucou()\nméthode prend obligatoirement un argument que nous avons nommé ici . Nous verrons dans les deux prochaines\nself\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 257\nChapitre 23. Avoir la classe avec les objets 23.1. Construction d’une classe\nrubriques la signification de ce . Si on a plusieurs méthodes dans une classe, on saute toujours une ligne entre elles\nself\nafin de faciliter la lecture (comme pour les fonctions).\nLigne 7 et 8. On crée l’instance de la classe , puis on exécute la méthode avec une\ncitron1 Citron .coucou()\nsyntaxe .\ninstance.méthode()\nUne méthode étant une fonction, elle peut bien sûr retourner une valeur :\n1\nclass Citron:\n2 def recup_saveur(self):\n3\nreturn \"acide\"\n4\n5\n6 if __name__ == \"__main__\":\n7\ncitron1 = Citron()\n8 saveur_citron1 = citron1.recup_saveur()\n9\nprint(saveur_citron1)\nVous l’aurez deviné, ce code aﬀichera à l’écran. Comme pour les fonctions, une valeur retournée par une\nacide\nméthode est récupérable dans une variable, ici .\nsaveur_citron1\n23.1.5 Le constructeur\nLors de l’instanciation d’un objet à partir d’une classe, il peut être intéressant de lancer des instructions, comme,\nd’initialiser certaines variables. Pour cela, on ajoute une méthode spéciale nommée : cette méthode s’appelle\n.__init__()\nle « constructeur » de la classe. Il s’agit d’une méthode spéciale dont le nom est entouré de doubles underscores : en\neffet, elle sert au fonctionnement interne de notre classe et, sauf cas extrêmement rare, elle n’est pas supposée être lancée\ncomme une fonction classique par l’utilisateur de la classe. Ce constructeur est exécuté à chaque instanciation de notre\nclasse, et ne renvoie pas de valeur, il ne possède donc pas de .\nreturn\nRemarque\nPour les débutants, vous pouvez sauter cette remarque. Certains auteurs préfèrent nommer « instantia-\n.__init__()\nteur » ou « initialisateur », pour signifier qu’il existe une autre méthode appelée , qui participe à la création\n.__new__()\nd’une instance. Vous n’avez bien sûr pas à retenir ces détails pour continuer la lecture de ce chapitre, retenez simplement\nque nous avons décidé de nommer la méthode « constructeur » dans cet ouvrage.\n.__init__()\n2\nPour bien comprendre comment cela fonctionne, nous allons suivre un exemple simple avec le site Python Tutor\n(déjà utilisé dans les chapitres 10 et 13 sur les fonctions). N’hésitez pas à copier/coller ce code dans Python Tutor pour\nle tester vous-même :\n1 class Citron:\n2 def __init__(self):\n3\nself.couleur = \"jaune\"\n4\n5\n6 if __name__ == \"__main__\":\n7\ncitron1 = Citron()\n8 print(citron1.couleur)\nÉtape 1\nFigure 23.1. Au départ, Python Tutor nous montre que la classe a été mise en mémoire, elle contient pour\nCitron\nl’instant la méthode .\n.__init__()\nÉtape 2\nFigure 23.2. Nous créons ensuite l’instance à partir de la classe . Notre classe contenant\ncitron1 Citron Citron\nune méthode (le constructeur), celle-ci est immédiatement exécutée au moment de l’instanciation. Cette\n.__init__()\nméthode prend un argument nommé : cet argument est obligatoire. Il s’agit en fait d’une référence vers l’instance\nself\n2. http://www.pythontutor.com\n258 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n23.1. Construction d’une classe Chapitre 23. Avoir la classe avec les objets\nFigure 23.1 – Fonctionnement d’un constructeur (étape 1).\nen cours (instance que nous appellerons dans le programme principal, mais cela serait vrai pour n’importe quel\ncitron1\nautre nom d’instance). Python Tutor nous indique cela par une flèche pointant vers un espace nommé .\nCitron instance\nLa signification du est expliquée en détail dans la rubrique suivante.\nself\nFigure 23.2 – Fonctionnement d’un constructeur (étape 2).\nÉtape 3\nFigure 23.3. Un nouvel attribut est créé s’appelant . La chaîne de caractères est ainsi «\nself.couleur couleur\naccrochée » (grâce au caractère point) à l’instance en cours référencée par le . Python Tutor nous montre cela par\nself\nune flèche qui pointe depuis le vers la variable (qui se trouve elle-même dans l’espace nommé\nself couleur Citron\n). Si d’autres attributs étaient créés, ils seraient tous répertoriés dans cet espace . Vous\ninstance Citron instance\nl’aurez compris, l’attribut est donc une variable d’instance (voir rubrique Ajout d’un attribut d’instance ci-\ncouleur\ndessus). La méthode étant intrinsèquement une fonction, Python Tutor nous rappelle qu’elle ne renvoie\n.__init__()\nrien (d’où le dans la case Return value), une fois son exécution terminée. Et comme avec les fonctions classiques,\nNone\nl’espace mémoire contenant les variables locales à cette méthode va être détruit une fois son exécution terminée.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 259\nChapitre 23. Avoir la classe avec les objets 23.1. Construction d’une classe\nFigure 23.3 – Fonctionnement d’un constructeur (étape 3).\nÉtape 4\nFigure 23.4. De retour dans le programme principal, Python Tutor nous indique que est une instance de\ncitron1\nla classe par une flèche pointant vers l’espace . Cette instance contient un attribut nommé\nCitron Citron instance\nauquel on accéde avec la syntaxe dans le . Notez que si l’instance s’était appelée\ncouleur citron1.couleur print()\n, on aurait utilisé pour accéder à l’attribut .\nenorme_citron enorme_citron.couleur couleur\nFigure 23.4 – Fonctionnement d’un constructeur (étape 4).\nConseil\nDans la mesure du possible, nous vous conseillons de créer tous les attributs d’instance dont vous aurez besoin dans\nle constructeur plutôt que dans toute autre méthode. Ainsi, ils seront visibles dans toute la classe dès\n.__init__()\nl’instanciation.\n23.1.6 Passage d’argument(s) à l’instanciation\nLors de l’instanciation, il est possible de passer des arguments au constructeur. Comme pour les fonctions, on peut\npasser des arguments positionnels ou par mot-clé, et en créer autant que l’on veut (voir chapitre 10 Fonctions). Voici un\nexemple :\n260 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n23.1. Construction d’une classe Chapitre 23. Avoir la classe avec les objets\n1\nclass Citron:\n2 def __init__(self, masse, couleur=\"jaune\"):\n3\nself.masse = masse\n4 self.couleur = couleur\n5\n6\n7 if __name__ == \"__main__\":\n8\ncitron1 = Citron(100)\n9 print(\"citron1:\", citron1.__dict__)\n10\ncitron2 = Citron(150, couleur=\"blanc\")\n11 print(\"citron2:\", citron2.__dict__)\nOn a ici un argument positionnel ( ) et un autre par mot-clé ( ). Le code donnera la sortie suivante :\nmasse couleur\n1\ncitron1: {'masse': 100, 'couleur': 'jaune'}\n2 citron2: {'masse': 150, 'couleur': 'blanc'}\n23.1.7 Mieux comprendre le rôle du self\nCette rubrique va nous aider à mieux comprendre le rôle du à travers quelques exemples simples. Regardons le\nself\ncode suivant dans lequel nous créons une nouvelle méthode :\n.affiche_attributs()\n1\nclass Citron:\n2 def __init__(self, couleur=\"jaune\"):\n3\nself.couleur = couleur\n4 var = 2\n5\n6 def affiche_attributs(self):\n7\nprint(self)\n8 print(self.couleur)\n9\nprint(var)\n10\n11\n12\nif __name__ == \"__main__\":\n13 citron1 = Citron()\n14\ncitron1.affiche_attributs()\nLigne 3. On crée l’attribut que l’on accroche à l’instance avec .\ncouleur self\nLigne 4. Nous créons cette fois-ci une variable sans l’accrocher à .\nvar self\nLigne 6. Nous créons une nouvelle méthode dans la classe qui se nomme\nCitron\n. Comme pour le constructeur, cette méthode prend comme premier argument une variable\n.affiche_attributs()\nobligatoire, que nous avons à nouveau nommée . Il s’agit encore une fois d’une référence vers l’objet ou instance\nself\ncréé(e).\nAttention\nOn peut appeler cette référence comme on veut, toutefois nous vous conseillons vivement de l’appeler , car c’est\nself\nune convention en Python. Ainsi, quelqu’un qui lira votre code comprendra immédiatement de quoi il s’agit.\nLigne 7. Cette ligne va aﬀicher le contenu de la variable .\nself\nLignes 8 et 9. On souhaite que notre méthode aﬀiche ensuite l’attribut de classe\n.affiche_attributs() .couleur\nainsi que la variable créée dans le constructeur .\nvar .__init__()\nL’exécution de ce code donnera :\n$ python classe_exemple1.py\n<__main__.Citron object at 0x7f4e5fb71438>\njaune\nTraceback (most recent call last):\nFile \"classe_exemple1.py\", line 14, in <module>\ncitron1.affiche_attributs()\nFile \"classe_exemple1.py\", line 9, in affiche_attributs\nprint(var)\n^^^\nNameError: name 'var' is not defined. Did you mean: 'vars'?\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 261\nChapitre 23. Avoir la classe avec les objets 23.1. Construction d’une classe\nLigne 2. La méthode montre que le est bien une référence vers l’instance (ou objet)\n.affiche_attributs() self\n(ou vers n’importe quelle autre instance : par exemple, si on crée , le sera une\ncitron1 citron2 = Citron() self\nréférence vers ).\ncitron2\nLigne 3. La méthode aﬀiche l’attribut , qui avait été créé précédemment dans\n.affiche_attributs() .couleur\nle constructeur. Vous voyez ici l’intérêt principal de l’argument passé en premier à chaque méthode d’une classe :\nself\nil « accroche » n’importe quel attribut qui sera visible partout dans la classe, y compris dans une méthode où il n’a pas\nété défini.\nLignes 4 à 9. La création de la variable dans la méthode sans l’accrocher à l’objet fait\nvar .__init__() self\nqu’elle n’est plus accessible en dehors de . C’est exactement comme pour les fonctions classiques,\n.__init__() var\nest finalement une variable locale au sein de la méthode et n’est plus visible lorsque l’exécution de cette\n.__init__()\ndernière est terminée (voir les chapitres 10 et 13 sur les fonctions). Ainsi, Python renvoie une erreur, car n’existe\nvar\npas lorsque est en exécution.\n.affiche_attributs()\nEn résumé, le est nécessaire lorsqu’on a besoin d’accéder à différents attributs dans les différentes méthodes\nself\nd’une classe. Le est également nécessaire pour appeler une méthode de la classe depuis une autre méthode :\nself\n1\nclass Citron:\n2 def __init__(self, couleur=\"jaune\"):\n3\nself.couleur = couleur\n4 self.affiche_message()\n5\n6 def affiche_message(self):\n7\nprint(\"Le citron c'est trop bon !\")\n8\n9\n10 if __name__ == \"__main__\":\n11\ncitron1 = Citron(\"jaune pâle\")\nLigne 4. Nous appelons ici la méthode depuis le constructeur. Pour appeler cette méthode\n.affiche_message()\ninterne à la classe , on doit utiliser une syntaxe . Le sert donc pour accéder aux attributs,\nCitron self.méthode() self\nmais aussi aux méthodes, ou plus généralement à tout ce qui est accroché à la classe.\nLignes 6 et 7. La méthode est exécutée. On peut se poser la question « Pourquoi passer\n.affiche_message()\nl’argument self à cette méthode alors qu’on ne s’en sert pas dans celle-ci ? »\nAttention\nMême si on ne se sert d’aucun attribut dans une méthode, l’argument (ou quel que soit son nom) est stricte-\nself\nment obligatoire. En fait, la notation est équivalente à\ncitron1.affiche_message() Citron.affiche_message\n. Testez les deux pour voir ! Dans cette dernière instruction, on appelle la méthode accrochée à la classe\n(citron1)\net on lui passe explicitement l’instance en tant qu’argument. La notation\nCitron citron1 citron1.affiche_message\ncontient donc en filigrane un argument, à savoir la référence vers l’instance que l’on appelle au sein\n() citron1 self\nde la méthode.\nConseil\nC’est la première notation (ou plus généralement ), plus\ncitron1.affiche_attributs() instance.méthode()\ncompacte, qui sera toujours utilisée.\nLigne 11. On crée l’instance en lui passant l’argument . La variable d’instance\ncitron1 \"jaune pâle\" couleur\nprendra ainsi cette valeur au lieu de celle par défaut ( ). À noter, l’instanciation aﬀichera le message\n\"jaune\" Le citron\npuisque la méthode est appelée dans le constructeur .\nc'est trop bon ! .affiche_attributs() .__init__()\nAfin de bien comprendre les différentes étapes des codes de cette rubrique, nous vous conseillons de les retester de\nvotre côté dans Python Tutor.\n262 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n23.2. Exercices Chapitre 23. Avoir la classe avec les objets\n23.1.8 Remarque finale\nDans ce chapitre, nous avons vu les bases pour construire une classe. Toutefois, nous avons encore de nombreuses\nnotions à vous montrer afin de pouvoir utiliser la POO à plein régime. Dans le chapitre 24 Avoir plus la classe avec les\nobjets (en ligne), nous verrons les concepts de polymorphisme, composition et héritage qui donnent toute la puissance\nà la POO. D’autres notions comme les décorateurs seront abordées permettant le contrôle des attributs par\nproperty\nun utilisateur de la classe. Nous donnerons également des conseils généraux quand vous utilisez la POO. Le chapitre 25\nFenêtres graphiques et Tkinter (en ligne) illustrera l’utilisation de la POO pour concevoir des fenêtres graphiques avec\nle module Tkinter."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n23.2.1 Classe\nRectangle\n3\nTéléchargez le script qui implémente la classe .\nrectangle.py Rectangle\nComplétez le programme principal pour que le script :\n•\ncrée une instance de la classe ;\nrectangle Rectangle\n•\naﬀiche les attributs d’instance , et ;\nlargeur longueur couleur\n•\ncalcule et aﬀiche la surface de ;\nrectangle\n•\naﬀiche une ligne vide ;\n•\nchange le rectangle en carré de 30 m de côté ;\n•\ncalcule et aﬀiche la surface de ce carré ;\n•\ncrée une autre instance , aux dimensions et à la couleur que vous souhaitez (soyez créatif !) et qui\nrectangle2\naﬀiche les attributs et la surface de ce nouveau rectangle.\n23.2.2 Classe améliorée\nRectangle\nEntraînez-vous avec la classe . Créez la méthode qui calcule le périmètre d’un\nRectangle calcule_perimetre()\nobjet rectangle. Testez sur un exemple simple (largeur = 10 m, longueur = 20 m).\n23.2.3 Classe Atome\nCréez une nouvelle classe avec les attributs , , , qui contiennent les coordonnées atomiques, et la méthode\nAtome x y z\n, qui calcule la distance entre deux atomes. Testez cette classe sur plusieurs exemples.\ncalcul_distance()\n23.2.4 Classe Atome améliorée\nAméliorez la classe en lui ajoutant un nouvel attribut , qui correspond à la masse atomique, ainsi qu’une\nAtome masse\nnouvelle méthode . Que se passe-t-il quand vous utilisez l’instruction avec une\n.calcule_centre_masse() print()\ninstance d’un objet ? Dans votre classe, ajoutez la méthode suivante :\nAtome\n1 def __str__(self):\n2\n\"\"\"Redéfinition du comportement avec print().\"\"\"\n3 return f\"coords({self.x}, {self.y}, {self.z}) ; mass = {self.masse}\"\nUtilisez à nouveau l’instruction avec un objet de la classe . Que constatez-vous par rapport au\nprint() Atome\nprécédent ?\nprint()\n3. https://python.sdv.u-paris.fr/data-files/rectangle.py\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 263"
  },
  {
    "title": "Avoir plus la classe avec les objets",
    "content": "Dans le chapitre précédent, nous avons vu les bases sur comment créer une classe, les notions d’attributs d’instance\net de classe, le fonctionnent d’un constructeur et comment passer des arguments lors de l’instanciation. Nous avons vu\nqu’une classe pouvait être vue comme un constructeur de conteneur (chaque conteneur construit est une instance), qu’on\npouvait y mettre tout un tas de variables ou objets (les attributs d’instance), mais également nous pouvions définir des\nméthodes réalisant des actions pour modifier ce que contient l’objet.\nDans le présent chapitre, nous abordons de nouvelles notions qui augmentent la puissance des classes, à savoir le\npolymorphisme, l’héritage et la composition. Nous verrons également les décorateurs property permettant le contrôle de\nl’accès aux attributs. À la fin du chapitre, nous vous donnerons des bonnes pratiques pour construire vos classes. Mais\navant d’aborder ces sujets, nous revenons sur un concept important en Python, à savoir les espaces de noms."
  },
  {
    "title": "Espace de noms",
    "content": "La notion d’espace de noms est importante lorsqu’on étudie les classes. Nous avons déjà croisé ce concept à plusieurs\nreprises. D’abord dans le chapitre 13 Plus sur les fonctions, puis dans le chapitre 15 Création de modules, et maintenant\ndans ce chapitre. De quoi s’agit-il ?\nDéfinition\n1\nDans la documentation oﬀicielle , un espace de noms est défini comme suit : « a namespace is a mapping from\nnames to objects ». Un espace de noms, c’est finalement une correspondance entre des noms et des objets. Un espace\nde noms peut être vu aussi comme une capsule dans laquelle on trouve des noms d’objets. Par exemple, le programme\nprincipal ou une fonction représentent chacun un espace de noms, un module aussi, et bien sûr une classe ou l’instance\nd’une classe également.\nDifférents espaces de noms peuvent contenir des objets de même nom sans que cela ne pose de problème. Parce qu’ils\nsont chacun dans un espace différent, ils peuvent cohabiter sans risque d’écrasement de l’un par l’autre. Par exemple, à\nchaque fois que l’on appelle une fonction, un espace de noms est créé pour cette fonction. Python Tutor nous montre\ncet espace sous la forme d’une zone dédiée (voir les chapitres 10 et 13 sur les fonctions). Si cette fonction appelle une\nautre fonction, un nouvel espace est créé, bien distinct de la fonction appelante (ce nouvel espace peut donc contenir\n1. https://docs.python.org/fr/3/tutorial/classes.html#python-scopes-and-namespaces\n264\n24.1. Espace de noms Chapitre 24. Avoir plus la classe avec les objets\nun objet de même nom). En définitive, ce qui va compter, c’est de savoir quelles règles Python va utiliser pour chercher\ndans les différents espaces de noms pour finalement accéder à un objet.\nNous allons dans cette rubrique refaire le point sur ce que l’on a appris dans cet ouvrage sur les espaces de noms en\nPython, puis se pencher sur les spécificités de ce concept dans les classes.\n24.1.1 Rappel sur la règle LGI\nComme vu dans le chapitre 10 Fonctions, la règle LGI peut être résumée ainsi : Local > Global > Interne. Lorsque\nPython rencontre un objet, il utilise cette règle de priorité pour accéder à la valeur de celui-ci. Si on est dans une fonction\n(ou une méthode), Python va d’abord chercher l’espace de noms local à cette fonction. S’il ne trouve pas de nom il va\nensuite chercher l’espace de noms du programme principal (ou celui du module), donc des variables globales s’y trouvant.\n2\nS’il ne trouve pas de nom, il va chercher dans les commandes internes à Python (on parle des Built-in Functions et des\n3\nBuilt-in Constants ). Si aucun objet n’est trouvé, Python renvoie une erreur.\n24.1.2 Gestion des noms dans les modules\nLes modules représentent aussi un espace de noms en soi. Afin d’illustrer cela, jetons un coup d’œil à ce programme\n:\ntest_var_module.py\n1 import mod\n2\n3 i = 1000000\n4 j = 2\n5\n6 print(\"Dans prog principal i:\", i)\n7\nprint(\"Dans prog principal j:\", j)\n8\n9\nmod.fct()\n10 mod.fct2()\n11\n12 print(\"Dans prog principal i:\", i)\n13\nprint(\"Dans prog principal j:\", j)\nLe module contient les instructions suivantes :\nmod.py\n1\ndef fct():\n2 i = -27478524\n3\nprint(\"Dans module, i local:\", i)\n4\n5\n6 def fct2():\n7 print(\"Dans module, j global:\", j)\n8\n9\n10\ni = 3.14\n11 j = -76\nL’exécution de donnera :\ntest_var_module.py\n$ python ./test_var_module.py\nDans prog principal i: 1000000\nDans prog principal j: 2\nDans module, i local: -27478524\nDans module, j global: -76\nDans prog principal i: 1000000\nDans prog principal j: 2\nLignes 3 et 4. On a bien les valeurs de et définies dans le programme principal de .\ni j test.py\nLignes 9 et 10. Lorsqu’on exécute , la valeur de sera celle définie localement dans cette fonction.\nmod.fct() i\nLorsqu’on exécute , la valeur de sera celle définie de manière globale dans le module.\nmod.fct2() j\nLignes 12 et 13. De retour dans notre programme principal, les variables et existent toujours et n’ont pas été\ni j\nmodifiées par l’exécution de fonctions du module .\nmod.py\n2.\nhttps://docs.python.org/fr/3/library/functions.html%20comme%20par%20exemple%20%60print()%60\n3. https://docs.python.org/fr/3/library/constants.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 265\nChapitre 24. Avoir plus la classe avec les objets 24.1. Espace de noms\nEn résumé, lorsqu’on lance une méthode d’un module, c’est l’espace de noms de celui-ci qui est utilisé. Bien sûr,\ntoutes les variables du programme principal / fonction / méthode appelant ce module sont conservées telles quelles, et\non les retrouve intactes lorsque l’exécution de la fonction du module est terminée. Un module a donc son propre espace\nde noms qui est bien distinct de tout programme principal / fonction / méthode appelant un composant de ce module.\nEnfin, les variables globales créées dans notre programme principal ne sont pas accessibles dans le module lorsque celui-ci\nest en exécution.\n24.1.3 Gestion des noms avec les classes\nOn vient de voir qu’un module avait son propre espace de noms, mais qu’en est-il des classes ? En utilisant les exemples\nvus depuis le début de ce chapitre, vous avez certainement la réponse. Une classe possède par définition son propre espace\nde noms qui ne peut être en aucun cas confondu avec celui d’une fonction ou d’un programme principal. Reprenons un\nexemple simple :\n1 class Citron:\n2 def __init__(self, saveur=\"acide\", couleur=\"jaune\"):\n3\nself.saveur = saveur\n4 self.couleur = couleur\n5\nprint(\"Dans __init__(), vous venez de créer un citron:\",\n6 self.affiche_attributs())\n7\n8 def affiche_attributs(self):\n9\nreturn f\"{self.saveur}, {self.couleur}\"\n10\n11\n12 if __name__ == \"__main__\":\n13\nsaveur = \"sucrée\"\n14 couleur = \"orange\"\n15 print(f\"Dans le programme principal: {saveur}, {couleur}\")\n16\ncitron1 = Citron(\"très acide\", \"jaune foncé\")\n17 print(\"Dans citron1.affiche_attributs():\", citron1.affiche_attributs())\n18\nprint(f\"Dans le programme principal: {saveur}, {couleur}\")\nLorsqu’on exécutera ce code, on obtiendra :\nDans le programme principal: sucrée, orange\nDans __init__(), vous venez de créer un citron: très acide, jaune foncé\nDans citron1.affiche_attributs(): très acide, jaune foncé\nDans le programme principal: sucrée, orange\nLes deux variables globales et du programme principal ne peuvent pas être confondues avec les\nsaveur couleur\nvariables d’instance portant le même nom. Au sein de la classe, on utilisera pour récupérer ces dernières\nself.saveur\net . À l’extérieur, on utilisera et . Il n’y a donc aucun risque de\nself.couleur instance.saveur instance.couleur\nconfusion possible avec les variables globales et , on accède à chaque variable de la classe avec un nom\nsaveur couleur\ndistinct (qu’on soit à l’intérieur ou à l’extérieur de la classe).\nCeci est également vrai pour les méthodes. Si par exemple, on a une méthode avec un certain nom, et une fonction\ndu module principal avec le même nom, regardons ce qui se passe :\n266 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.1. Espace de noms Chapitre 24. Avoir plus la classe avec les objets\n1\nclass Citron:\n2 def __init__(self):\n3\nself.couleur = \"jaune\"\n4 self.affiche_coucou()\n5\naffiche_coucou()\n6\n7 def affiche_coucou(self):\n8\nprint(\"Coucou interne !\")\n9\n10\n11 def affiche_coucou():\n12\nprint(\"Coucou externe\")\n13\n14\n15 if __name__ == \"__main__\":\n16\ncitron1 = Citron()\n17 citron1.affiche_coucou()\n18\naffiche_coucou()\nLorsqu’on va exécuter le code, on obtiendra :\nCoucou interne !\nCoucou externe\nCoucou interne !\nCoucou externe\nÀ nouveau, il n’y a pas de conflit possible pour l’utilisation d’une méthode ou d’une fonction avec le même nom. À\nl’intérieur de la classe on utilise pour la méthode et pour la fonction.\nself.affiche_coucou() affiche_coucou()\nÀ l’extérieur de la classe, on utilise pour la méthode et pour la\ninstance.affiche_coucou() affiche_coucou()\nfonction.\nDans cette rubrique, nous venons de voir une propriété des classes extrêmement puissante : une classe crée au-\ntomatiquement son propre espace de noms. Cela permet d’encapsuler à l’intérieur tous les attributs et méthodes\ndont on a besoin, sans avoir aucun risque de conflit de nom avec l’extérieur (variables locales, globales ou provenant de\nmodules). L’utilisation de classes évitera ainsi l’utilisation de variables globales qui, on l’a vu aux chapitres 10 et 13 sur\nles fonctions, sont à proscrire absolument. Tout cela concourt à rendre le code plus lisible.\nDans le chapitre 25 Fenêtres graphiques et Tkinter (en ligne), vous verrez une démonstration de l’utilité de tout\nencapsuler dans une classe afin d’éviter les variables globales.\n24.1.4 Gestion des noms entre les attributs de classe et d’instance\nSi vous lisez cette rubrique sur l’espace de noms sans avoir lu ce chapitre depuis le début, nous vous conseillons\nvivement de lire attentivement la rubrique Différence entre les attributs de classe et d’instance. La chose importante\nà retenir sur cette question est la suivante : si un attribut de classe et un attribut d’instance ont le même nom, c’est\nl’attribut d’instance qui est prioritaire.\nPour aller plus loin\nIl existe d’autres règles concernant les espace de noms. L’une d’elle, que vous pourriez rencontrer, concerne la gestion\ndes noms avec des fonctions imbriquées. Et oui, Python autorise cela ! Par exemple :\n1\ndef fonction1():\n2 [...]\n3\n4 def fct_dans_fonction1():\n5 [...]\nLà encore, il existe certaines règles de priorités d’accès aux objets spécifiques à ce genre de cas, avec l’apparition d’un\nnouveau mot-clé nommé . Toutefois ces aspects vont au-delà du présent ouvrage. Pour plus d’informations sur\nnonlocal\n4\nles fonctions imbriquées et la directive , vous pouvez consulter la documentation oﬀicielle .\nnonlocal\nD’autres subtilités concerneront la gestion des noms en cas de définition d’une nouvelle classe héritant d’une classe\n4. https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 267\nChapitre 24. Avoir plus la classe avec les objets 24.2. Polymorphisme\nmère. Ces aspects sont présentés dans la rubrique Héritage de ce chapitre."
  },
  {
    "title": "Polymorphisme",
    "content": "Nous allons voir maintenant des propriétés très importantes des classes en Python, le polymorphisme dans cette\nrubrique et l’héritage dans la suivante. Ces deux concepts donnent un surplus de puissance à la POO par rapport à la\nprogrammation classique.\n24.2.1 Principe\nCommençons par le polymorphisme. Dans la vie, celui-ci évoque la capacité à prendre plusieurs apparences, qu’en\nest-il en programmation ?\nDéfinition\nEn programmation, le polymorphisme est la capacité d’une fonction (ou méthode) à se comporter différemment en\nfonction de l’objet qui lui est passé. Une fonction donnée peut donc avoir plusieurs définitions.\nPrenons un exemple concret de polymorphisme : la fonction Python va trier par ordre ASCII si l’argument\nsorted()\nest une chaîne de caractères, et elle va trier par ordre croissant lorsque l’argument est une liste d’entiers :\n1\n>>> sorted(\"citron\")\n2 ['c', 'i', 'n', 'o', 'r', 't']\n3 >>> sorted([1, -67, 42, 0, 81])\n4 [-67, 0, 1, 42, 81]\nLe polymorphisme est intimement lié au concept de redéfinition des opérateurs que nous avons déjà croisé à plusieurs\nreprises dans ce livre.\nDéfinition\nLa redéfinition des opérateurs est la capacité à redéfinir le comportement d’un opérateur en fonction des opérandes\nutilisées (on rappelle dans l’expression , est l’opérateur d’addition et les deux sont les opérandes).\n1 + 1 + 1\nUn exemple classique de redéfinition des opérateurs concerne l’opérateur . Si les opérandes sont de type numérique,\n+\nil fait une addition, si elles sont des chaînes de caractère il fait une concaténation :\n1\n>>> 2 + 2\n2 4\n3\n>>> \"ti\" + \"ti\"\n4 'titi'\nNous verrons dans la rubrique suivante sur l’héritage qu’il est également possible de redéfinir des méthodes d’une\nclasse, c’est-à-dire leur donner une nouvelle définition.\n24.2.2 Méthodes dunder ou magiques\nComment Python permet-il ces prouesses que sont le polymorphisme et la redéfinition des opérateurs ? Et bien, il\nutilise des méthodes dites dunder ou magiques.\nDéfinition\nUne méthode dunder (dunder method) est une méthode spéciale dont le nom est entouré de double underscores.\nPar exemple, la méthode est une méthode dunder. Ces méthodes sont, la plupart du temps, destinées\n.__init__()\nau fonctionnement interne de la classe. Nombre d’entre elles sont destinées à changer le comportement de fonctions ou\nopérateurs internes à Python avec les instances d’une classe que l’on a créée. Le mot dunder signifie littéralement double\nunderscore. On parle aussi parfois de méthodes magiques.\n268 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.2. Polymorphisme Chapitre 24. Avoir plus la classe avec les objets\nNous allons prendre un exemple concret. Imaginons que suite à la création d’une classe, nous souhaitions que Python\naﬀiche un message personnalisé lors de l’utilisation de la fonction avec une instance de cette classe. La méthode\nprint()\ndunder qui permettra cela est nommée : elle redéfinit le comportement d’une instance avec la fonction\n.__str__()\n.\nprint()\n1\nclass CitronBasique:\n2 def __init__(self, couleur=\"jaune\", taille=\"standard\"):\n3 self.couleur = \"jaune\"\n4\nself.taille = \"standard\"\n5\n6\n7 class CitronCool:\n8\ndef __init__(self, couleur=\"jaune\", taille=\"standard\"):\n9 self.couleur = couleur\n10\nself.taille = taille\n11\n12\ndef __str__(self):\n13 return (f\"Votre citron est de couleur {self.couleur} \"\n14\nf\"et de taille {self.taille}\")\n15\n16\n17 if __name__ == \"__main__\":\n18 citron1 = CitronBasique()\n19\nprint(citron1)\n20 citron2 = CitronCool(\"jaune foncée\", \"minuscule\")\n21\nprint(citron2)\nLignes 1 à 4. Création d’une classe dans laquelle il n’y a qu’un constructeur.\nCitronBasique\nLignes 7 à 14. Création d’une classe où nous avons ajouté la nouvelle méthode . Cette\nCitronCool .__str__()\ndernière renvoie une chaîne de caractères contenant la description de l’instance.\nLignes 18 à 21. On crée une instance de chaque classe, et on utilise la fonction pour voir leur contenu.\nprint()\nL’exécution de ce code aﬀichera la sortie suivante :\n1\n<__main__.CitronBasique object at 0x7ffe23e717b8>\n2 Votre citron est de couleur jaune foncée et de taille minuscule 8-)\nL’utilisation de la fonction sur l’instance construite à partir de la classe aﬀiche\nprint() citron1 CitronBasique\nle message abscons que nous avons déjà croisé. Par contre, pour l’instance de la classe , le texte\ncitron2 CitronCool\ncorrespond à celui retourné par la méthode dunder . Nous avons donc redéfini comment la fonction\n.__str__() print()\nse comportait avec une instance de la classe . Notez que donnerait le même message que\nCitronCool str(citron2)\n.\nprint(citron2)\nCe mécanisme pourra être reproduit avec de très nombreux opérateurs et fonctions de bases de Python. En effet, il\nexiste une multitude de méthodes dunder, en voici quelques unes :\n•\n: redéfinit le message obtenu lorsqu’on tape le nom de l’instance dans l’interpréteur ;\n.__repr__()\n•\n: redéfinit le comportement de l’opérateur ;\n.__add__() +\n•\n: redéfinit le comportement de l’opérateur ;\n.__mul__() *\n•\n: redéfinit le comportement de la fonction .\n.__del__() del\nSi on conçoit une classe produisant des objets séquentiels (comme des listes ou des tuples), il existe des méthodes\ndunder telles que :\n•\n: redéfinit le comportement de la fonction ;\n.__len__() len()\n•\n: redéfinit le comportement pour récupérer un élément ;\n.__getitem__()\n•\n: redéfinit le comportement avec les tranches.\n.__getslice__()\nCertaines méthodes dunder font des choses assez impressionnantes. Par exemple, la méthode crée des\n.__call__()\ninstances que l’on peut appeler comme des fonctions ! Dans cet exemple, nous allons vous montrer que l’on peut ainsi\ncréer un moyen inattendu pour mettre à jour des attributs d’instance :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 269\nChapitre 24. Avoir plus la classe avec les objets 24.3. Héritage\n1\nclass Citronnier:\n2 def __init__(self, nb_citrons, age):\n3\nself.nb_citrons, self.age = nb_citrons, age\n4\n5\ndef __call__(self, nb_citrons, age):\n6 self.nb_citrons, self.age = nb_citrons, age\n7\n8\ndef __str__(self):\n9 return (f\"Ce citronnier a {self.age} ans \"\n10\nf\"et {self.nb_citrons} citrons\")\n11\n12\n13 if __name__ == \"__main__\":\n14\ncitronnier1 = Citronnier(10, 3)\n15 print(citronnier1)\n16\ncitronnier1(30, 4)\n17 print(citronnier1)\nÀ la ligne 16, on utilise une notation , ce qui va automatiquement appeler la méthode dunder\ninstance(arg1, arg2)\nqui mettra à jour les deux attributs d’instance et (lignes 5 et 6). Ce code aﬀichera la\n.__call__() nbcitrons age\nsortie suivante :\nCe citronnier a 3 ans et 10 citrons\nCe citronnier a 4 ans et 30 citrons\nPour aller plus loin\n•\nNous vous avons montré l’idée qu’il y avait derrière le polymorphisme, et avec cela vous avez assez pour vous jeter à\nl’eau et commencer à construire vos propres classes. L’apprentissage de toutes les méthodes dunder va bien sûr au-\n5\ndelà du présent ouvrage. Toutefois, si vous souhaitez aller plus loin, nous vous conseillons la page de Trey Hunner\nqui est particulièrement complète et très bien faite. Une autre page qui a un peu vieilli mais reste intéressante\n6\nest celle de Rafe Kettler . Enfin, nous développons les méthodes dunder et dans la\n.__iter__() .__next__()\nrubrique sur les itérateurs du chapitre 26 Remarques complémentaires."
  },
  {
    "title": "Héritage",
    "content": "24.3.1 Prise en main\nL’héritage peut évoquer la capacité qu’ont nos parents à nous transmettre certains traits physiques ou de caractère\n(ne dit-on pas, j’ai hérité ceci ou cela de ma mère ou de mon père ?). Qu’en est-il en programmation ?\nDéfinition\nEn programmation, l’héritage est la capacité d’une classe d’hériter des propriétés d’une classe pré-existante. On parle\nde classe mère et de classe fille. En Python, l’héritage peut être multiple lorsqu’une classe fille hérite de plusieurs classes\nmères.\nEn Python, lorsque l’on veut créer une classe héritant d’une autre classe, on ajoutera après le nom de la classe fille\nle nom de la ou des classe(s) mère(s) entre parenthèses :\n5.\nhttps://www.pythonmorsels.com/every-dunder-method/\n6. https://rszalski.github.io/magicmethods\n270 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.3. Héritage Chapitre 24. Avoir plus la classe avec les objets\n1\nclass Mere1:\n2 # contenu de la classe mère 1\n3\n4\n5\nclass Mere2:\n6 # contenu de la classe mère 2\n7\n8\n9 class Fille1(Mere1):\n10\n# contenu de la classe fille 1\n11\n12\n13 class Fille2(Mere1, Mere2):\n14\n# contenu de la classe fille 2\nDans cet exemple, la classe hérite de la classe et la classe hérite des deux classes et\nFille1 Mere1 Fille2 Mere1\n. Dans le cas de la classe , on parle d’héritage multiple. Voyons maintenant un exemple concret :\nMere2 Fille2\n1 class Mere:\n2\ndef bonjour(self):\n3 return \"Vous avez le bonjour de la classe mère !\"\n4\n5\n6\nclass Fille(Mere):\n7 def salut(self):\n8\nreturn \"Un salut de la classe fille !\"\n9\n10\n11 if __name__ == \"__main__\":\n12\nfille = Fille()\n13 print(fille.salut())\n14 print(fille.bonjour())\nLignes 1 à 3. On définit une classe avec une méthode .\nMere .bonjour()\nLignes 6 à 8. On définit une classe qui hérite de la classe . Cette classe fille contient une nouvelle méthode\nFille Mere\n.\n.salut()\nLignes 12 à 14. Après instanciation de la classe , on utilise la méthode , puis la méthode\nFille .salut() .bonjour()\nhéritée de la classe mère.\nCe code aﬀiche la sortie suivante :\nUn salut de la classe fille !\nVous avez le bonjour de la classe mère !\nNous commençons à entrevoir la puissance de l’héritage. Si on possède une classe avec de nombreuses méthodes et\nque l’on souhaite en ajouter de nouvelles, il suﬀit de créer une classe fille héritant d’une classe mère.\nEn revenant à notre exemple, une instance de la classe sera automatiquement une instance de la classe .\nFille Mere\nRegardons dans l’interpréteur :\n1\n>>> fille = Fille()\n2 >>> isinstance(fille, Fille)\n3\nTrue\n4 >>> isinstance(fille, Mere)\n5\nTrue\nSi une méthode de la classe fille possède le même nom que celle de la classe mère, c’est la première qui prend la\npriorité. Dans ce cas, on dit que la méthode est redéfinie (en anglais on parle de method overriding), tout comme on\nparlait de redéfinition des opérateurs un peu plus haut. C’est le même mécanisme, car la redéfinition des opérateurs\nrevient finalement à redéfinir une méthode dunder (comme par exemple la méthode pour l’opérateur ).\n.__add__() +\nVoyons un exemple :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 271\nChapitre 24. Avoir plus la classe avec les objets 24.3. Héritage\n1\nclass Mere:\n2 def bonjour(self):\n3\nreturn \"Vous avez le bonjour de la classe mère !\"\n4\n5\n6 class Fille2(Mere):\n7 def bonjour(self):\n8\nreturn \"Vous avez le bonjour de la classe fille !\"\n9\n10\n11 if __name__ == \"__main__\":\n12\nfille = Fille2()\n13 print(fille.bonjour())\nCe code va aﬀicher . La méthode de la classe fille\nVous avez le bonjour de la classe fille ! .bonjour()\na donc pris la priorité sur celle de la classe mère. Ce comportement provient de la gestion des espaces de noms par\nPython, il est traité en détail dans la rubrique suivante.\nRemarque\nÀ ce point, nous pouvons faire une note de sémantique importante. Python utilise le mécanisme de redéfinition de\nméthode (method overriding), c’est-à-dire qu’on redéfinit une méthode héritée d’une classe mère. Il ne faut pas confondre\ncela avec la surcharge de fonction (function overloading) qui désigne le fait d’avoir plusieurs définitions d’une fonction\nselon le nombres d’arguments et/ou leur type (la surcharge n’est pas supportée par Python contrairement à d’autres\nlangages orientés objet).\n24.3.2 Ordre de résolution des noms\nVous l’avez compris, il y aura un ordre pour la résolution des noms d’attributs ou de méthodes en fonction du ou\ndes héritage(s) de notre classe (à nouveau, cela provient de la manière dont Python gère les espaces de noms). Prenons\nl’exemple d’une classe déclarée comme suit . Si on invoque un attribut ou une méthode\nclass Fille(Mere1, Mere2):\nsur une instance de cette classe, Python cherchera d’abord dans la classe . S’il ne trouve pas, il cherchera ensuite\nFille\ndans la première classe mère ( dans notre exemple). S’il ne trouve pas, il cherchera dans les ancêtres de cette\nMere1\npremière mère (si elle en a), et ce en remontant la filiation (d’abord la grand-mère, puis l’arrière grand-mère, etc). S’il n’a\ntoujours pas trouvé, il cherchera dans la deuxième classe mère ( dans notre exemple) puis dans tous ses ancêtres.\nMere2\nEt ainsi de suite, s’il y a plus de deux classes mères. Bien sûr, si aucun attribut ou méthode n’est trouvé, Python renverra\nune erreur.\nIl est en général possible d’avoir des informations sur l’ordre de résolution des méthodes d’une classe en évoquant la\ncommande sur celle-ci ou une de ses instances. Par exemple, nous verrons dans le chapitre suivant le module\nhelp()\nTkinter, imaginons que nous créions une instance de la classe principale du module Tkinter nommée :\nTk\n1 >>> import tkinter as tk\n2 >>> racine = tk.Tk()\nEn invoquant la commande , l’interpréteur nous montre :\nhelp(racine)\n1\nHelp on class Tk in module tkinter:\n2\n3\nclass Tk(Misc, Wm)\n4 | Toplevel widget of Tk which represents mostly the main window\n5\n| of an application. It has an associated Tcl interpreter.\n6 |\n7\n| Method resolution order:\n8 | Tk\n9\n| Misc\n10 | Wm\n11 | builtins.object\n12\n[...]\nOn voit tout de suite que la classe hérite de deux autres classes et . Ensuite, le help indique l’ordre de\nTk Misc Wm\nrésolution des méthodes : d’abord la classe elle-même, ensuite ses deux mères puis , et enfin une dernière\nTk Misc Wm\n272 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.3. Héritage Chapitre 24. Avoir plus la classe avec les objets\nclasse nommée dont nous allons voir la signification maintenant.\nbuiltins.object\nRemarque\nEn Python, il existe une classe interne nommée qui est en quelque sorte la classe ancêtre de tous les objets.\nobject\nToutes les classes héritent de .\nobject\nPour vous en convaincre, nous pouvons recréer une classe vide :\n1 >>> class Citron:\n2 ... pass\nPuis ensuite regarder l’aide sur l’une de ses instances :\n1 Help on class Citron in module __main__:\n2\n3 class Citron(builtins.object)\n4\n| Data descriptors defined here:\n5 |\n6\n| __dict__\n7 | dictionary for instance variables (if defined)\n8\n[...]\nL’aide nous montre que a hérité de bien que nous ne l’ayons pas déclaré explicitement.\nCitron builtins.object\nCela se fait donc de manière implicite.\nRemarque\nLe module builtins possède toutes les fonctions internes à Python. Il est donc pratique pour avoir une liste de toutes ces\nfonctions internes en un coup d’œil. Regardons cela avec les deux instructions puis :\nimport builtins dir(builtins)\n1\n>>> import builtins\n2 >>> dir(builtins)\n3\n['ArithmeticError', 'AssertionError', 'AttributeError', [...]\n4 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', [...]\n5\n'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', [...]\n6 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']\nAu début, on y trouve les exceptions commençant par une lettre majuscule (voir le chapitre 26 Remarques complé-\nmentaires (en ligne) pour la définition d’une exception), puis les fonctions Python de base tout en minuscule. On retrouve\npar exemple ou , mais il y a aussi . Toutefois ces fonctions étant chargées de base dans l’interpréteur,\nlist str object\nl’importation de n’est pas obligatoire : par exemple revient au même que , ou\nbuiltins list builtins.list object\nrevient au même que .\nbuiltins.object\nEn résumé, la syntaxe sera équivalente à\nclass Citron:\nclass Citron(builtins.object):\nou à .\nclass Citron(object):\nAinsi, même si on crée une classe vide (contenant seulement une commande ), elle possède déjà tout\nCitron pass\nune panoplie de méthodes héritées de la classe . Regardez l’exemple suivant :\nobject\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 273\nChapitre 24. Avoir plus la classe avec les objets 24.3. Héritage\n1\n>>> class Citron:\n2 ... pass\n3\n...\n4 >>> c = Citron()\n5\n>>> dir(c)\n6 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__',\n7 '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__',\n8\n'__init__', '__le__', '__lt__', '__module__', '__ne__', '__new__',\n9 '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n10\n'__str__', '__subclasshook__', '__weakref__']\n11 >>> o = object()\n12\n>>> dir(o)\n13 ['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__',\n14\n'__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__',\n15 '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__',\n16\n'__setattr__', '__sizeof__', '__str__', '__subclasshook__']\nLa quasi-totalité des attributs / méthodes de base de la classe sont donc hérités de la classe object. Par\nCitron\nexemple, lorsqu’on instancie un objet Citron , Python utilisera la méthode héritée de la\nc = Citron() .__init__()\nclasse object (puisque nous ne l’avons pas définie dans la classe ).\nCitron\n24.3.3 Un exemple concret d’héritage\nNous allons maintenant prendre un exemple un peu plus conséquent pour illustrer la puissance de l’héritage en\nprogrammation. D’abord quelques mots à propos de la conception. Imaginons que nous souhaitions créer plusieurs classes\ncorrespondant à nos fruits favoris, par exemple le citron (comme par hasard !), l’orange, le kaki, etc. Chaque fruit a ses\npropres particularités, mais il y a aussi de nombreux points communs. Nous pourrions donc concevoir une classe\nFruit\npermettant, par exemple, d’instancier un fruit et ajouter des méthodes d’aﬀichage commune à n’importe quel fruit, et\najouter (ou toute autre méthode) pouvant être utilisée pour n’importe quel fruit. Nous pourrions alors créer des classes\ncomme , , etc., héritant de la classe et ainsi nous économiser des lignes de code identiques à\nCitron Orange Fruit\najouter pour chaque fruit. Regardons l’exemple suivant que nous avons garni de pour bien comprendre ce qui\nprint()\nse passe :\n274 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.3. Héritage Chapitre 24. Avoir plus la classe avec les objets\n1\nclass Fruit:\n2 def __init__(self, taille=None, masse=None, saveur=None, forme=None):\n3\nprint(\"(2) Je suis dans le constructeur de la classe Fruit\")\n4 self.taille = taille\n5\nself.masse = masse\n6 self.saveur = saveur\n7 self.forme = forme\n8\nprint(\"Je viens de créer self.taille, self.masse, self.saveur \"\n9 \"et self.forme\")\n10\n11 def affiche_conseil(self, type_fruit, conseil):\n12\nprint(\"(2) Je suis dans la méthode .affiche_conseil() de la \"\n13 \"classe Fruit\\n\")\n14\nreturn (f\"Instance {type_fruit}\\n\"\n15 f\"taille: {self.taille}, masse: {self.masse}\\n\"\n16\nf\"saveur: {self.saveur}, forme: {self.forme}\\n\"\n17 f\"conseil: {conseil}\\n\")\n18\n19\n20 class Citron(Fruit):\n21 def __init__(self, taille=None, masse=None, saveur=None, forme=None):\n22 print(\"(1) Je rentre dans le constructeur de Citron, et je vais \"\n23\n\"appeler\\n\"\n24 \"le constructeur de la classe mère Fruit !\")\n25\nFruit.__init__(self, taille, masse, saveur, forme)\n26 print(\"(3) J'ai fini dans le constructeur de Citron, \"\n27\n\"les attributs sont :\\n\"\n28 f\"self.taille: {self.taille}, self.masse: {self.masse}\\n\"\n29\nf\"self.saveur: {self.saveur}, self.forme: {self.forme}\\n\")\n30\n31\ndef __str__(self):\n32 print(\"(1) Je rentre dans la méthode .__str__() de la classe \"\n33\n\"Citron\")\n34 print(\"Je vais lancer la méthode .affiche_conseil() héritée \"\n35 \"de la classe Fruit\")\n36\nreturn self.affiche_conseil(\"Citron\", \"Bon en tarte :-p !\")\n37\n38\n39 if __name__ == \"__main__\":\n40\n# On crée un citron.\n41 citron1 = Citron(taille=\"petite\", saveur=\"acide\",\n42\nforme=\"ellipsoïde\", masse=50)\n43 print(citron1)\nLignes 1 à 9. On crée la classe avec son constructeur qui initialisera tous les attributs d’instance décrivant le\nFruit\nfruit.\nLignes 11 à 17. Création d’une méthode qui retourne une chaîne contenant le type de fruit,\n.affiche_conseil()\nles attributs d’instance du fruit, et un conseil de consommation.\nLignes 20 à 29. Création de la classe qui hérite de la classe . Le constructeur de prend les\nCitron Fruit Citron\nmêmes arguments que ceux du constructeur de . La ligne 24 est une étape importante que nous n’avons encore\nFruit\njamais vue : l’instruction est un appel au constructeur de la classe mère (cf. explications plus bas).\nFruit.__init__()\nNotez bien que le premier argument passé au constructeur de la classe mère sera systématiquement l’instance en cours\n. Le en lignes 26-29 illustre qu’après l’appel du constructeur de la classe mère tous les attributs d’instance\nself print()\n( , , etc.) ont bel et bien été créés.\nself.taille self.poids\nLignes 31 à 36. On définit la méthode qui va modifier le comportement de notre classe avec .\n.__str__() print()\nCelle-ci fait également appel à une méthode hértitée de la classe mère nommée . Comme on a l’a\n.affiche_conseil()\nhéritée, elle est directement accessible avec un (et de l’extérieur ce serait ).\nself.méthode() instance.méthode()\nLignes 39 à 43. Dans le programme principal, on instancie un objet , puis on utilise sur l’instance.\nCitron print()\nL’exécution de ce code aﬀichera la sortie suivante :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 275\nChapitre 24. Avoir plus la classe avec les objets 24.3. Héritage\n(1) Je rentre dans le constructeur de Citron, et je vais appeler\nle constructeur de la classe mère Fruit !\n(2) Je suis dans le constructeur de la classe Fruit\nJe viens de créer self.taille, self.masse, self.saveur et self.forme\n(3) J'ai fini dans le constructeur de Citron, les attributs sont:\nself.taille: petite, self.masse: 50\nself.saveur: acide, self.forme: ellipsoïde\n(1) Je rentre dans la méthode .__str__() de la classe Citron\nJe vais lancer la méthode .affiche_conseil() héritée de la classe Fruit\n(2) Je suis dans la méthode .affiche_conseil() de la classe Fruit\nInstance Citron\ntaille: petite, masse: 50\nsaveur: acide, forme: ellipsoïde\nconseil: Bon en tarte :-p !\nPrenez bien le temps de suivre ce code pas à pas pour bien en comprendre toutes les étapes.\nVous pourrez vous poser la question « Pourquoi utilise-t-on en ligne 24 la syntaxe ? ». Cette\nFruit.__init__()\nsyntaxe est souvent utilisée lorsqu’une classe hérite d’une autre classe pour faire appel au constructeur de la classe mère.\nLa raison est que nous souhaitons appeler une méthode de la classe mère qui a le même nom qu’une méthode de la\nclasse fille. Dans ce cas, si on utilisait , cela correspondrait à la fonction de notre classe fille Citron.\nself.__init__()\nEn mettant systématiquement une syntaxe\non indique sans ambiguïté qu’on appelle le constructeur de la classe mère, en mettant explici-\nClasseMere.__init__()\ntement son nom. Ce mécanisme est assez souvent utilisé dans le module Tkinter (voir le chapitre 25 Fenêtres graphiques\net Tkinter (en ligne)) pour la construction d’interfaces graphiques, nous en verrons de nombreux exemples.\nRemarque\nSi vous utilisez des ressources externes, il se peut que vous rencontriez une syntaxe . La\nsuper().__init__()\nfonction Python interne appelle automatiquement la classe mère sans que vous ayez à donner son nom. Même\nsuper()\nsi cela peut paraître pratique, nous vous conseillons d’utiliser dans un premier temps la syntaxe\nqui est selon nous plus lisible (on voit explicitement le nom de la classe employée, même s’il\nClasseMere.__init__()\ny a plusieurs classes mères).\nCe mécanisme n’est pas obligatoirement utilisé, mais il est très utile lorsqu’une classe fille a besoin d’initialiser des\nattributs définis dans la classe mère. On le croise donc souvent car :\n•\nCela donne la garantie que toutes les variables de la classe mère sont bien initialisées. On réduit ainsi les risques\nde dysfonctionnement des méthodes héritées de la classe mère.\n•\nFinalement, autant ré-utiliser les « moulinettes » de la classe mère, c’est justement à ça que sert l’héritage ! Au\nfinal, on écrit moins de lignes de code.\nConseil\nPour les deux raisons citées ci-dessus, nous vous conseillons de systématiquement utiliser le constructeur de la classe\nmère lors de l’instanciation.\nVous avez à présent bien compris le fonctionnement du mécanisme de l’héritage. Dans notre exemple, nous pourrions\ncréer de nouveaux fruits avec un minimum d’effort. Ceux-ci pourraient hériter de la classe mère à nouveau, et\nFruit\nnous n’aurions pas à réécrire les mêmes méthodes pour chaque fruit, simplement à les appeler. Par exemple :\n276 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.4. Composition Chapitre 24. Avoir plus la classe avec les objets\n1\nclass Kaki(Fruit):\n2 def __init__(self, taille=None, masse=None, saveur=None, forme=None):\n3\nFruit.__init__(self, taille, masse, saveur, forme)\n4\n5\ndef __str__(self):\n6 return Fruit.affiche_conseil(self, \"Kaki\",\n7 \"Bon à manger cru, miam !\")\n8\n9\n10\nclass Orange(Fruit):\n11 def __init__(self, taille=None, masse=None, saveur=None, forme=None):\n12\nFruit.__init__(self, taille, masse, saveur, forme)\n13\n14\ndef __str__(self):\n15 return Fruit.affiche_conseil(self, \"Orange\", \"Trop bon en jus !\")\nCet exemple illuste la puissance de l’héritage et du polymorphisme et la facilité avec laquelle on les utilise en Python.\nPour chaque fruit, on utilise la méthode définie dans la classe mère sans avoir à la réécrire. Bien\n.affiche_conseil()\nsûr cet exemple reste simpliste et n’est qu’une « mise en bouche ». Vous verrez des exemples concrets de la puissance de\nl’héritage dans le chapitre 25 Fenêtres graphiques et Tkinter (en ligne) ainsi que dans les exercices du présent chapitre.\nAvec le module Tkinter, chaque objet graphique (bouton, zone de texte, etc.) est en fait une classe. On peut ainsi créer\nde nouvelles classes héritant des classes Tkinter afin de personnaliser chaque objet graphique."
  },
  {
    "title": "Composition",
    "content": "Un autre concept puissant rencontré en POO est la composition.\nDéfinition\nLa composition désigne le fait qu’une classe peut contenir des instances provenant d’autres classes. On parle parfois\nde classe Composite contenant des instances d’une classe Component (qu’on pourrait traduire par élément).\nPour vous illustrer cela, nous allons prendre un exemple sur notre fruit préféré, le citron. Un citron (classe Composite)\ncontient de la pulpe (classe Component). Voilà comment nous pourrions l’implémenter :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 277\nChapitre 24. Avoir plus la classe avec les objets 24.4. Composition\n1\nclass Pulpe:\n2 def __init__(self, quantite_jus):\n3\nself.quantite_jus = quantite_jus # En cL.\n4\n5\ndef __str__(self):\n6 return f\"Cette pulpe contient {self.quantite_jus} cL de jus\"\n7\n8\n9 class Citron:\n10\ndef __init__(self, pulpe=None):\n11 self.pulpe = pulpe\n12\n13 def presse_citron(self):\n14\nif self.pulpe:\n15 print(f\"Le pressage de la pulpe délivre \"\n16\nf\"{self.pulpe.quantite_jus} cL de jus\")\n17 self.pulpe = None\n18\nelse:\n19 print(\"Il n'y a plus rien à presser dans votre citron !\")\n20\n21 def __str__(self):\n22 if self.pulpe:\n23\nreturn f\"Votre citron contient {self.pulpe.quantite_jus} cL de jus\"\n24 else:\n25\nreturn \"Ce citron ne contient pas de pulpe\"\n26\n27\n28 if __name__ == \"__main__\":\n29\npulpe = Pulpe(10)\n30 print(pulpe)\n31\ncitron1 = Citron()\n32 print(citron1)\n33\nprint()\n34 citron2 = Citron(pulpe)\n35 print(citron2.pulpe)\n36\nprint(citron2)\n37 print()\n38\ncitron2.presse_citron()\n39 citron2.presse_citron()\n40\nprint(citron2)\nLignes 1 à 6. On crée une classe qui prend en argument à l’instanciation une quantité de jus (en cL) qu’elle\nPulpe\npeut délivrer si on la presse.\nLignes 9 à 25. On crée une classe qui prend un objet Pulpe à l’instanciation. Si aucun objet est passé, on\nCitron\naffecte . Cette classe contient une méthode qui pressera la pulpe pour délivrer le jus de citron.\nNone .presse_citron()\nUne fois le pressage effectué, il n’y aura plus de jus à délivrer.\nLa sortie sera la suivante :\nCette pulpe contient 10 cL de jus\nCe citron ne contient pas de pulpe\nCette pulpe contient 10 cL de jus\nVotre citron contient 10 cL de jus\nLe pressage de la pulpe délivre 10 cL de jus\nIl n'y a plus rien à presser dans votre citron !\nCe citron ne contient pas de pulpe\nDans cet exemple, la classe a utilisé une instance de la classe pour fonctionner. Un avantage de la\nCitron Pulpe\ncomposition est qu’on pourrait réutiliser cette classe dans une classe ou . Par ailleurs, si\nPulpe Orange Pamplemousse\non change des détails dans la classe , cela affectera peu la classe à partir du moment où on garde l’attribut\nPulpe Citron\n.\n.quantite_jus\nDe manière générale, la composition est considérée comme plus flexible que l’héritage car les classes Composite et\nComponent sont peu couplées. Le changement de l’une d’entre elle aura peu d’effet sur l’autre. Au contraire, pour\nl’héritage le changement d’une classe mère peut avoir des répercussions importantes pour les classes filles. Toutefois,\n278 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.5. Différence entre les attributs de classe et d’instance Chapitre 24. Avoir plus la classe avec les objets\ndans certains cas l’héritage peut s’avérer plus naturel. Nous vous parlions en introduction du chapitre 23 Avoir la classe\navec les objets de l’art pour concevoir des classes interagissant harmonieusement entre elles. Et bien nous y sommes !\nSi on a deux classes et , la relation entre elles dans l’héritage sera de type is a (avec qui hérite de ). Dans\nA B B A B A\nla composition, ce sera plutôt has a . Cela peut vous servir de piste dans la conception des relations entre vos classes.\nA B\nA-t-il plus de sens d’y avoir une relation is a ou bien has a ? Dans le premier cas vous irez plutôt vers l’héritage, alors\n7\nque dans le deuxième plutôt vers la composition. C’est ici que le langage UML peut être pratique pour avoir une vision\nd’ensemble sur comment les classes interagissent entre elles.\nBien sûr, il faudra vous entraîner sur des cas concrets pour acquérir l’expérience qui vous mènera aux bons choix.\nA la fin de ce chapitre, nous vous présentons un exercice pour vous entraîner dans un premier temps à la composition.\nDans le chapitre 25 Fenêtres graphiques et Tkinter (en ligne), vous aurez des illustrations et des exercices sur l’héritage\nqui est très utilisé en Tkinter.\nPour aller plus loin\nNous vous conseillons ce très bon article sur le site RealPython qui explique de manière approfondie la problématique\n8\nentre la composition et l’héritage .\nPour aller plus loin\nLe polymorphisme, l’héritage et la composition donnent toute la puissance à la POO. Toutefois, concevoir ses classes\nsur un projet, surtout au début de celui-ci, n’est pas chose aisée. Nous vous conseillons de lire d’autres ressources et de\nvous entraîner sur un maximum d’exemples. Si vous souhaitez allez plus loin sur la POO, nous vous conseillons de lire des\n9\nressources supplémentaires. En langue française, vous trouverez les livres de Gérard Swinnen , Bob Cordeau et Laurent\n10 11 12\nPointal , Vincent Legoff et Xavier Olive ."
  },
  {
    "title": "Différence entre les attributs de classe et d’instance",
    "content": "Dans cette rubrique, nous souhaitons éclairer le rôle des attributs de classe et des attributs d’instance, et comment\nils sont gérés par Python.\nOn a vu dans le chapitre précédent comment créer un attribut de classe, il suﬀit de créer une variable au sein de la\nclasse (en dehors de toute méthode). En général, les attributs de classe contiennent des propriétés générales à la classe\npuisqu’ils vont prendre la même valeur quelle que soit l’instance.\nAu contraire, les attributs d’instance sont spécifiques à chaque instance. Pour en créer, on a vu qu’il suﬀisait de les\ninitialiser dans la méthode en utilisant une syntaxe . On a vu aussi\n.__init__() self.nouvel_attribut = valeur\ndans la rubrique Ajout d’un attribut d’instance que l’on pouvait ajouter un attribut d’instance de l’extérieur avec une\nsyntaxe .\ninstance.nouvel_attribut = valeur\nBien que les deux types d’attributs soient fondamentalement différents au niveau de leur finalité, il existe des similitudes\nlorsqu’on veut accéder à leur valeur. Le code suivant illustre cela :\n7.\nhttps://fr.wikipedia.org/wiki/UML_(informatique)\n8. https://realpython.com/inheritance-composition-python/\n9.\nhttps://inforef.be/swi/python.htm\n10. https://perso.limsi.fr/pointal/python:courspython3\n11.\nhttps://openclassrooms.com/fr/courses/235344-apprenez-a-programmer-en-python\n12. https://www.xoolive.org/python/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 279\nChapitre 24. Avoir plus la classe avec les objets 24.5. Différence entre les attributs de classe et d’instance\n1\nclass Citron:\n2 forme = \"ellipsoïde\" # attribut de classe\n3\nsaveur = \"acide\" # attribut de classe\n4\n5\ndef __init__(self, couleur=\"jaune\", taille=\"standard\", masse=0):\n6 self.couleur = couleur # attribut d'instance\n7 self.taille = taille # attribut d'instance\n8\nself.masse = masse # attribut d'instance (masse en gramme)\n9\n10\ndef augmente_masse(self, valeur):\n11 self.masse += valeur\n12\n13\n14\nif __name__ == \"__main__\":\n15 citron1 = Citron()\n16\nprint(\"Attributs de classe :\", citron1.forme, citron1.saveur)\n17 print(\"Attributs d'instance :\", citron1.taille, citron1.couleur,\n18\ncitron1.masse)\n19 citron1.augmente_masse(100)\n20 print(\"Attributs d'instance :\", citron1.taille, citron1.couleur,\n21 citron1.masse)\nLignes 2 et 3. Nous créons deux variables de classe qui seront communes à toutes les instances (disons qu’un citron\nsera toujours ellipsoïde et acide !).\nLignes 6 à 8. Nous créons trois variables d’instance qui seront spécifiques à chaque instance (disons que la taille, la\ncouleur et la masse d’un citron peuvent varier !), avec des valeurs par défaut.\nLignes 10 et 11. On crée une nouvelle méthode qui augmente l’attribut d’instance .\n.augmente_masse() .masse\nLigne 14 à 21. Dans le programme principal, on instancie la classe sans passer d’argument (les valeurs par\nCitron\ndéfaut , et seront donc prises), puis on imprime les attributs.\n\"jaune\" \"standard\" 0\n13\nLa figure 24.1 montre l’état des variables après avoir exécuté ce code grâce au site Python Tutor .\nFigure 24.1 – Illustration de la signification des attributs de classe et d’instance avec Python Tutor.\nPython Tutor montre bien la différence entre les variables de classe et qui apparaissent directement\nforme saveur\ndans les attributs de la classe lors de sa définition et les trois variables d’instance , et\nCitron couleur taille masse\n13. http://www.pythontutor.com\n280 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.5. Différence entre les attributs de classe et d’instance Chapitre 24. Avoir plus la classe avec les objets\nqui sont liées à l’instance . Pour autant, on voit dans la dernière instruction qu’on peut accéder de la\ncitron1 print()\nmême manière aux variables de classe ou d’instance, lorsqu’on est à l’extérieur, avec une syntaxe .\ninstance.attribut\nAu sein des méthodes, on accède également de la même manière aux attributs de classe ou d’instance, avec une\nsyntaxe :\nself.attribut\n1\nclass Citron:\n2 saveur = \"acide\" # attribut de classe\n3\n4 def __init__(self, couleur=\"jaune\"):\n5\nself.couleur = couleur # attribut d'instance\n6\n7 def affiche_attributs(self):\n8\nprint(f\"attribut de classe: {self.saveur}\")\n9 print(f\"attribut d'instance: {self.couleur}\")\n10\n11\n12\nif __name__ == \"__main__\":\n13 citron1 = Citron()\n14\ncitron1.affiche_attributs()\nCe code va aﬀicher la phrase :\nattribut de classe: acide\nattribut d'instance: jaune\nEn résumé, qu’on ait des attributs de classe ou d’instance, on peut accéder à eux de l’extérieur par\ninstance.\net de l’intérieur par .\nattribut self.attribut\nQu’en est-il de la manière de modifier ces deux types d’attributs ? Les attributs d’instance peuvent se modifier sans\nproblème de l’extérieur avec une syntaxe et de l’intérieur\ninstance.attribut_d_instance = nouvelle_valeur\navec une syntaxe . Ce n’est pas du tout le cas avec les attributs\nself.attribut_d_instance = nouvelle_valeur\nde classe.\nAttention\nLes attributs de classe ne peuvent pas être modifiés ni à l’extérieur d’une classe via une syntaxe\ninstance.\n, ni à l’intérieur d’une classe via une syntaxe\nattribut_de_classe = nouvelle_valeur self.attribut_de_classe\n. Puisqu’ils sont destinés à être identiques pour toutes les instances, cela est logique de ne pas\n= nouvelle_valeur\npouvoir les modifier via une instance. Les attributs de classe Python ressemblent en quelque sorte aux attributs statiques\ndu C++.\nRegardons l’exemple suivant illustrant cela :\n1 class Citron:\n2\nsaveur = \"acide\"\n3\n4\n5 if __name__ == \"__main__\":\n6\ncitron1 = Citron()\n7 print(citron1.saveur)\n8 citron1.saveur = \"sucrée\"\n9\nprint(citron1.saveur) # on regarde ici avec Python Tutor\n10 del citron1.saveur\n11\nprint(citron1.saveur) # on regarde ici avec Python Tutor\n12 del citron1.saveur\nÀ la ligne 7, on pourrait penser qu’on modifie l’attribut de classe avec une syntaxe\nsaveur instance.attribut_de_classe\n. Que se passe-t-il exactement ? La figure 24.3 nous montre l’état des variables grâce au site\n= nouvelle_valeur\nPython Tutor. Celui-ci indique que la ligne 7 a en fait créé un nouvel attribut d’instance (contenant la\ncitron1.saveur\nvaleur ) qui est bien distinct de l’attribut de classe auquel on accédait avant par le même nom ! Tout ceci est dû\nsucrée\nà la manière dont Python gère les espaces de noms (voir rubrique Espaces de noms). Dans ce cas, l’attribut d’instance\nest prioritaire sur l’attribut de classe.\nÀ la ligne 9, on détruit finalement l’attribut d’instance qui contenait la valeur . Python\ncitron1.saveur sucrée\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 281\nChapitre 24. Avoir plus la classe avec les objets 24.5. Différence entre les attributs de classe et d’instance\nFigure 24.2 – Illustration avec Python Tutor de la non destruction d’un attribut de classe (étape 1).\nTutor nous montre que n’existe pas dans l’espace qui est vide ; ainsi, Python\ncitron1.saveur Citron instance\nutilisera l’attribut de classe qui contient toujours la valeur (cf. figure 24.3).\n.saveur acide\nFigure 24.3 – Illustration avec Python Tutor de la non destruction d’un attribut de classe (étape 2).\nLa ligne 11 va tenter de détruire l’attribut de classe . Toutefois, Python interdit cela, ainsi l’erreur suivante\n.saveur\nsera générée :\n282 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.6. Accès et modifications des attributs depuis l’extérieur Chapitre 24. Avoir plus la classe avec les objets\n1\nTraceback (most recent call last):\n2 File \"test.py\", line 11, in <module>\n3\ndel citron1.saveur\n4 ^^^^^^^^^^^^^^\n5\nAttributeError: 'Citron' object has no attribute 'saveur'\nEn fait, la seule manière de modifier un attribut de classe est d’utiliser une syntaxe\n,\nNomClasse.attribut_de_classe = nouvelle_valeur\ndans l’exemple ci-dessus cela aurait été . De même, pour sa destruction, il faudra utiliser\nCitron.saveur = \"sucrée\"\nla même syntaxe : .\ndel Citron.saveur\nConseil\nMême si on peut modifier un attribut de classe, nous vous déconseillons de le faire. Une utilité des attributs de classe\nest par exemple de définir des constantes (mathématique ou autre), donc cela n’a pas de sens de vouloir les modifier ! Il\nest également déconseillé de créer des attributs de classe avec des objets modifiables comme des listes et des dictionnaires,\ncela peut avoir des effets désastreux non désirés. Nous verrons plus bas un exemple concret d’attribut de classe qui est\ntrès utile, à savoir le concept d’objet de type property.\nSi vous souhaitez avoir des attributs modifiables dans votre classe, créez plutôt des attributs d’instance dans le\n.\n.__init__()"
  },
  {
    "title": "Accès et modifications des attributs depuis l’extérieur",
    "content": "24.6.1 Le problème\nOn a vu jusqu’à maintenant que Python était très permissif concernant le changement de valeur de n’importe quel\nattribut depuis l’extérieur. On a vu aussi qu’il était même possible de créer de nouveaux attributs depuis l’extérieur ! Dans\nd’autres langages orientés objet ceci n’est pas considéré comme une bonne pratique. Il est plutôt recommandé de définir\nune interface, c’est-à-dire tout un jeu de méthodes accédant ou modifiant les attributs. Ainsi, le concepteur de la classe\na la garantie que celle-ci est utilisée correctement du « côté client ».\nRemarque\nCette stratégie d’utiliser uniquement l’interface de la classe pour accéder aux attributs provient des langages orientés\nobjet comme Java et C++. Les méthodes accédant ou modifiant les attributs s’appellent aussi des getters et setters (en\nfrançais on dit accesseurs et mutateurs). Un des avantages est qu’il est ainsi possible de vérifier l’intégrité des données\ngrâce à ces méthodes : si par exemple on souhaitait avoir un entier seulement, ou bien une valeur bornée, on peut\nfacilement ajouter des tests dans le setter et renvoyer une erreur à l’utilisateur de la classe s’il n’a pas envoyé le bon type\n(ou la bonne valeur dans l’intervalle imposé).\nRegardons à quoi pourrait ressembler une telle stratégie en Python :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 283\nChapitre 24. Avoir plus la classe avec les objets 24.6. Accès et modifications des attributs depuis l’extérieur\n1\nclass Citron:\n2 def __init__(self, couleur=\"jaune\", masse=0):\n3\nself.couleur = couleur\n4 self.masse = masse # masse en g\n5\n6 def get_couleur(self):\n7 return self.couleur\n8\n9 def set_couleur(self, value):\n10\nself.couleur = value\n11\n12\ndef get_masse(self):\n13 return self.masse\n14\n15 def set_masse(self, value):\n16\nif value < 0:\n17 raise ValueError(\"Z'avez déjà vu une masse négative ?\")\n18\nself.masse = value\n19\n20\n21 if __name__ == \"__main__\":\n22 # définition de citron1\n23\ncitron1 = Citron()\n24 print(citron1.get_couleur(), citron1.get_masse())\n25\n# on change les attributs de citron1 avec les setters\n26 citron1.set_couleur(\"jaune foncé\")\n27\ncitron1.set_masse(100)\n28 print(citron1.get_couleur(), citron1.get_masse())\nLignes 6 à 10. On définit deux méthodes getters pour accéder à chaque attribut.\nLignes 12 à 18. On définit deux méthodes setters pour modifier chaque attribut. Notez qu’en ligne 16 nous testons\nsi la masse est négative, si tel est le cas nous générons une erreur avec le mot-clé (voir le chapitre 26 Remarques\nraise\ncomplémentaires (en ligne)). Ceci représente un des avantages des setters : contrôler la validité des attributs (on pourrait\naussi vérifier qu’il s’agit d’un entier, etc.).\nLignes 22 à 28. Après instanciation, on aﬀiche la valeur des attributs avec les deux fonctions getters, puis on les\nmodifie avec les setters et on les aﬀiche à nouveau.\nL’exécution de ce code donnera la sortie suivante :\njaune 0\njaune foncé 100\nSi on avait mis en ligne 26, la sortie aurait été la suivante :\ncitron1.set_masse(-100)\n1\njaune 0\n2 Traceback (most recent call last):\n3\nFile \"getter_setter.py\", line 27, in <module>\n4 citron1.set_masse(-100)\n5 File \"getter_setter.py\", line 17, in set_masse\n6 raise ValueError(\"Z'avez déjà vu une masse négative ???\")\n7 ValueError: Z'avez déjà vu une masse négative ???\nLa fonction interne nous a permis de générer une erreur, car l’utilisateur de la classe (c’est-à-dire nous dans le\nraise\nprogramme principal) n’a pas rentré une valeur correcte.\nOn comprend bien l’utilité d’une stratégie avec des getters et setters dans cet exemple. Toutefois, en Python, on\npeut très bien accéder et modifier les attributs même si on a des getters et des setters dans la classe. Imaginons la même\nclasse que ci-dessus, mais on utilise le programme principal suivant (notez que nous avons simplement ajouté les\nCitron\nlignes 9 à 12 ci-dessous) :\n284 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.6. Accès et modifications des attributs depuis l’extérieur Chapitre 24. Avoir plus la classe avec les objets\n1\nif __name__ == \"__main__\":\n2 # définition de citron1\n3\ncitron1 = Citron()\n4 print(citron1.get_couleur(), citron1.get_masse())\n5\n# on change les attributs de citron1 avec les setters\n6 citron1.set_couleur(\"jaune foncé\")\n7 citron1.set_masse(100)\n8\nprint(citron1.get_couleur(), citron1.get_masse())\n9 # on les rechange sans les setters\n10\ncitron1.couleur = \"pourpre profond\"\n11 citron1.masse = -15\n12\nprint(citron1.get_couleur(), citron1.get_masse())\nCela donnera la sortie suivante :\njaune 0\njaune foncé 100\npourpre profond -15\nMalgré la présence des getters et des setters, nous avons réussi à accéder et à modifier la valeur des attributs. De\nplus, nous avons pu mettre une valeur aberrante (masse négative) sans que cela ne génère une erreur !\nVous vous posez sans doute la question : mais dans ce cas, quel est l’intérêt de mettre des getters et des setters en\nPython ? La réponse est très simple : cette stratégie n’est pas une manière « pythonique » d’opérer (voir le chapitre 16\nBonnes pratiques en programmation Python pour la définition de « pythonique »). En Python, la lisibilité est la priorité.\nSouvenez-vous du Zen de Python « Readability counts » (voir le chapitre 16).\nDe manière générale, une syntaxe avec des getters et setters du côté client surcharge la lecture. Imaginons que l’on\nait une instance nommée et que l’on souhaite faire la somme de ses trois attributs , et :\nobj x y z\n1 # pythonique\n2\nobj.x + obj.y + obj.z\n3\n4\n# non pythonique\n5 obj.get_x() + obj.get_y() + obj.get_z()\nLa méthode pythonique est plus « douce » à lire, on parle aussi de syntactic sugar ou littéralement en français « sucre\nsyntaxique ». De plus, à l’intérieur de la classe, il faut définir un getter et un setter pour chaque attribut, ce qui multiple\nles lignes de code.\nTrès bien. Donc en Python, on n’utilise pas comme dans les autres langages orientés objet les getters et les setters ?\nMais, tout de même, cela avait l’air une bonne idée de pouvoir contrôler comment un utilisateur de la classe interagit\navec certains attributs (par exemple, rentre-t-il une bonne valeur ?). N’existe-t-il pas un moyen de faire ça en Python ? La\nréponse est : bien sûr il existe un moyen pythonique, la classe . Nous allons voir cette nouvelle classe dans la\nproperty\nprochaine rubrique et nous vous dirons comment opérer systématiquement pour accéder, modifier, voire détruire, chaque\nattribut d’instance de votre classe.\n24.6.2 La solution : la classe\nproperty\nDans la rubrique précédente, on vient de voir que les getters et setters traditionnels rencontrés dans d’autres langages\norientés objet ne représentent pas une pratique pythonique. En Python, pour des raisons de lisibilité, il faudra dans la\nmesure du possible conserver une syntaxe pour l’accès aux attributs d’instance, et une syntaxe\ninstance.attribut\npour les modifier.\ninstance.attribut = nouvelle_valeur\nToutefois, si on souhaite contrôler l’accès, la modification (voire la destruction) de certains attributs stratégiques,\nPython met en place une classe nommée . Celle-ci permet de combiner le maintien de la syntaxe lisible\nproperty\n, tout en utilisant en filigrane des fonctions pour accéder, modifier, voire détruire l’attribut (à\ninstance.attribut\nl’image des getters et setters évoqués ci-dessus, ainsi que des deleters ou encore destructeurs en français). Pour faire\ncela, on utilise la fonction Python interne qui crée un objet (ou instance) :\nproperty() property\n1 attribut = property(fget=accesseur, fset=mutateur, fdel=destructeur)\nLes arguments passés à sont systématiquement des méthodes dites callback, c’est-à-dire des noms de\nproperty()\nméthodes que l’on a définies précédemment dans notre classe, mais on ne précise ni argument, ni parenthèse, ni\nself\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 285\nChapitre 24. Avoir plus la classe avec les objets 24.6. Accès et modifications des attributs depuis l’extérieur\n(voir le chapitre 25 Fenêtres graphiques et Tkinter (en ligne)). Avec cette ligne de code, est un objet de type\nattribut\nproperty qui fonctionne de la manière suivante à l’extérieur de la classe :\n•\nL’instruction appellera la méthode .\ninstance.attribut .accesseur()\n•\nL’instruction appellera la méthode\ninstance.attribut = valeur\n.\n.mutateur()\n•\nL’instruction appellera la méthode\ndel instance.attribut\n.\n.destructeur()\nL’objet est de type property, et la vraie valeur de l’attribut est stockée par Python dans une variable\nattribut\nd’instance qui s’appellera par exemple (même nom, mais commençant par un underscore unique, envoyant\n_attribut\nun message à l’utilisateur qu’il s’agit d’une variable associée au comportement interne de la classe).\nComment cela fonctionne-t-il concrètement dans un code ? Regardons cet exemple (nous avons mis des un\nprint()\npeu partout pour bien comprendre ce qui se passe) :\n1\nclass Citron:\n2 def __init__(self, masse=0):\n3\nprint(\"(2) J'arrive dans le .__init__()\")\n4 self.masse = masse\n5\n6 def get_masse(self):\n7\nprint(\"Coucou je suis dans le get\")\n8 return self._masse\n9\n10\ndef set_masse(self, valeur):\n11 print(\"Coucou je suis dans le set\")\n12\nif valeur < 0:\n13 raise ValueError(\"Un citron ne peut pas avoir\"\n14\n\" de masse négative !\")\n15 self._masse = valeur\n16\n17 masse = property(fget=get_masse, fset=set_masse)\n18\n19\n20\nif __name__ == \"__main__\":\n21 print(\"(1) Je suis dans le programme principal, \"\n22 \"je vais instancier un Citron\")\n23 citron = Citron(masse=100)\n24 print(\"(3) Je reviens dans le programme principal\")\n25\nprint(f\"La masse de notre citron est {citron.masse} g\")\n26 # On mange le citron.\n27\ncitron.masse = 25\n28 print(f\"La masse de notre citron est {citron.masse} g\")\n29\nprint(citron.__dict__)\nPour une fois, nous allons commenter les lignes dans le désordre :\nLigne 17. Il s’agit de la commande clé pour mettre en place le système : devient ici un objet de type property\nmasse\n(si on regarde son contenu avec une syntaxe , donc ici , Python nous\nNomClasse.attribut_property Citron.masse\nrenverra quelque chose de ce style : ). Qu’est-ce que cela signifie ? Et bien la\n<property object at 0x7fd3615aeef8>\nprochaine fois qu’on voudra accéder au contenu de cet attribut , Python appellera la méthode , et\n.masse .get_masse()\nquand on voudra le modifier, Python appellera la méthode (ceci sera valable de l’intérieur ou de l’extérieur\n.set_masse()\nde la classe). Comme il n’y a pas de méthode destructeur (passée avec l’argument ), on ne pourra pas détruire cet\nfdel\nattribut : un conduirait à une erreur de ce type : .\ndel c.masse AttributeError: can't delete attribute\nLigne 4. Si vous avez bien suivi, cette commande dans le constructeur va appeler automa-\nself.masse = masse\ntiquement la méthode . Attention, dans cette commande, la variable à droite du signe est une\n.set_masse() masse =\nvariable locale passée en argument. Par contre, sera l’objet de type property. Si vous avez bien lu la rubrique\nself.masse\nDifférence entre les attributs de classe et d’instance, l’objet créé en ligne 16 est un attribut de classe, on peut\nmasse\ndonc y accéder avec une syntaxe au sein d’une méthode.\nself.masse\nConseil\nNotez bien l’utilisation de dans le constructeur (en ligne 4) plutôt que . Comme\nself.masse self._masse self.\nappelle la méthode , cela permet de contrôler si la valeur est correcte dès l’instanciation. C’est\nmasse .set_masse()\n286 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.6. Accès et modifications des attributs depuis l’extérieur Chapitre 24. Avoir plus la classe avec les objets\ndonc une pratique que nous vous recommandons. Si on avait utilisé , il n’y aurait pas eu d’appel à la\nself._masse\nfonction mutateur et on aurait pu mettre n’importe quoi, y compris une valeur aberrante, lors de l’instanciation.\nLignes 6 à 15. Dans les méthodes accesseur et mutateur, on utilise la variable\nqui contiendra la vraie valeur de la masse du citron (cela serait vrai pour tout autre objet de type property).\nself._masse\nAttention\nDans les méthodes accesseur et mutateur, il ne faut surtout pas utiliser à la place de .\nself.masse self._masse\nPourquoi ? Par exemple, dans l’accesseur, si on met cela signifie que l’on souhaite accéder à la valeur\nself.masse\nde l’attribut (comme dans le constructeur !). Ainsi, Python rappellera l’accesseur et retombera sur , ce qui\nself.masse\nrappellera l’accesseur et ainsi de suite : vous l’aurez compris, cela partira dans une récursion infinie et mènera à une erreur\ndu type . Cela serait vrai aussi si vous aviez une fonction\nRecursionError: maximum recursion depth exceeded\ndestructeur, il faudrait utiliser .\nself._masse\nL’exécution de ce code donnera :\n(1) Dans le programme principal, je vais instancier un Citron\n(2) J'arrive dans le .__init__()\nCoucou je suis dans le set\n(3) Je reviens dans le programme principal\nCoucou je suis dans le get\nLa masse de notre citron est 100 g\nCoucou je suis dans le set\nCoucou je suis dans le get\nLa masse de notre citron est 25 g\n{'_masse': 25}\nCette exécution montre qu’à chaque appel de ou on va utiliser les méthodes accesseur\nself.masse citron.masse\nou mutateur. La dernière commande qui aﬀiche le contenu de montre que la vraie valeur de l’attribut\ncitron.__dict__\nest stockée dans la variable d’instance ( de l’extérieur et de l’intérieur).\n._masse instance._masse self._masse\n24.6.3 Une meilleure solution : les décorateurs , et\n@property @attribut.setter @at-\ntribut.deleter\nNous venons de voir les objets property pour contrôler l’accès, la mutation et la supression d’attributs. Toutefois la\nsyntaxe est relativement lourde. Afin de la simplifier, une manière plus pythonique (sucre syntaxique) est d’utiliser un\ndécorateur. La syntaxe pour décorer une fonction est la suivante :\n1\n@decorateur\n2 def fonction():\n3\n[...]\nLa ligne 1 précise que va être modifiée par une autre fonction nommée . Le symbole\nfonction() decorateur() @\nen ligne 1 attend un nom de fonction qui sera la fonction décoratrice. Pour plus de détails sur comment les décorateurs\nfonctionnent, vous pouvez consulter le chapitre 26 Remarques complémentaires où une rubrique leur est consacrée. Ici,\nnous avons juste à savoir qu’un décorateur est une fonction qui modifie le comportement d’une autre fonction.\nEn reprenant l’exemple vu dans la rubrique précédente, voici comment on peut l’écrire avec des décorateurs :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 287\nChapitre 24. Avoir plus la classe avec les objets 24.6. Accès et modifications des attributs depuis l’extérieur\n1\nclass Citron:\n2 def __init__(self, masse=0):\n3\nprint(f\"(2) J'arrive dans le .__init__(), je vais mettre la masse = {masse}\")\n4 self.masse = masse\n5\n6 @property\n7 def masse(self):\n8\nprint(\"Coucou je suis dans le getter\")\n9 return self._masse\n10\n11 @masse.setter\n12\ndef masse(self, valeur):\n13 print(\"Coucou je suis dans le setter\")\n14\nif valeur < 0:\n15 raise ValueError(\"Un citron ne peut pas avoir\"\n16\n\" de masse négative !\")\n17 self._masse = valeur\n18\n19 @masse.deleter\n20 def masse(self):\n21 print(\"Coucou, je suis dans le deleter\")\n22 del self._masse\nOn voit que la syntaxe est plus lisible que celle de la rubrique précédente. Examinons les différences. La première\nchose est que les méthodes getter (ligne 7), setter (ligne 11) et deleter (ligne 19) s’appellent toutes ,\n.masse() masse\nétant le nom de notre objet property. Comme dans la syntaxe de la rubrique précédente, la masse réelle se trouve dans\nun attribut nommée pour ne pas confondre avec notre objet property. Afin de comprendre ce qu’il se passe,\n._masse\nnous vous avons concocté le programme principal suivant avec des un peu partout :\nprint()\n1\nif __name__ == \"__main__\":\n2 print(\"(1) Je suis dans le programme principal et \"\n3 \"je vais instancier un Citron\")\n4\nprint()\n5 citron = Citron(masse=100)\n6\nprint()\n7 print(\"(3) Je reviens dans le programme principal, je vais afficher \"\n8\n\"la masse du citron\")\n9 print(f\"La masse de notre citron est {citron.masse} g\")\n10\nprint()\n11 # On mange une partie du citron.\n12\nprint(\"(4)Je suis dans le prog principal \"\n13 \"et je vais changer la masse du citron\")\n14\ncitron.masse = 25\n15 print()\n16\nprint(f\"(5) Je suis dans le prog principal, je vais afficher \"\n17 \"la masse du citron\")\n18 print(f\"La nouvelle masse de notre citron est {citron.masse} g\")\n19\nprint(f\"L'attribut citron.__dict__ m'indique bien le nom réel \"\n20 f\"de l'attribut contenant la masse :\")\n21\nprint(citron.__dict__)\n22 print()\n23\n# On mange la fin du citron.\n24 print(f\"(6) Je suis dans le prog principal, \"\n25\nf\"je détruis l'attribut .masse\")\n26 del citron.masse\n27\nprint(f\"Ainsi, citron.__dict__ est maintenant vide :\")\n28 print(citron.__dict__)\nL’exécution donnera la sortie suivante :\n288 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.6. Accès et modifications des attributs depuis l’extérieur Chapitre 24. Avoir plus la classe avec les objets\n(1) Je suis dans le programme principal et je vais instancier un Citron\n(2) J'arrive dans le .__init__(), je vais mettre la masse = 100\nCoucou je suis dans le setter\n(3) Je reviens dans le programme principal, je vais afficher la masse du citron\nCoucou je suis dans le getter\nLa masse de notre citron est 100 g\n(4)Je suis dans le prog principal et je vais changer la masse du citron\nCoucou je suis dans le setter\n(5) Je suis dans le prog principal, je vais afficher la masse du citron\nCoucou je suis dans le getter\nLa nouvelle masse de notre citron est 25 g\nL'attribut citron.__dict__ m'indique bien le nom réel de l'attribut contenant la masse :\n{'_masse': 25}\n(6) Je suis dans le prog principal, je détruis l'attribut .masse\nCoucou, je suis dans le deleter\nAinsi, citron.__dict__ est maintenant vide :\n{}\nExaminez bien les phrases et essayez de comprendre pourquoi elles apparaissent. Bien\nCoucou je suis dans [...]\nque nos trois méthodes soient définies comme , vous pouvez constater qu’elles sont appelées lorsque on\ndef masse()\ninvoque , ou (à l’intérieur de la classe, ce serait ,\ncitron.masse citron.masse = 25 del citron.masse self.masse\nou ). Autrement dit, on n’utilise jamais la syntaxe . Ceci est justement\nself.masse = 25 del self.masse .masse()\ndû au fait que est un objet de type property.\n.masse\nConseil\nLorsque vous souhaitez créer des objets property , nous vous conseillons la syntaxe pythonique ,\n@property @nom_attribut\net plutôt que celle de la rubrique précédente avec la ligne\n.setter @nom_attribut.deleter masse = property(\n. Cette syntaxe améliore grandement la lisibilité.\nfget=get_masse, fset=set_masse, fdel=del_masse)\n24.6.4 Le décorateur seul\n@property\nUne méthode décorée avec peut être utile seule sans avoir le setter et/ou le deleter correspondant(s).\n@property\nOn rencontre cela lorsqu’on souhaite créer un « d’attribut dynamique » plutôt qu’avoir un appel de méthode explicite.\nRegardons un exemple :\n1 class ADN:\n2\ndef __init__(self):\n3 self.sequence = []\n4\n5 def __repr__(self):\n6\nreturn f\"La séquence de mon brin d'ADN est {self.sequence}\"\n7\n8\ndef ajoute_base(self, nom_base):\n9 self.sequence.append(nom_base)\n10\n11 @property\n12\ndef len(self):\n13 return len(self.sequence)\nVoici un dans l’interpréteur :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 289\nChapitre 24. Avoir plus la classe avec les objets 24.7. Bonnes pratiques pour construire et manipuler ses classes\n>>> brin_adn = ADN()\n>>> brin_adn.ajoute_base(\"A\")\n>>> brin_adn.ajoute_base(\"T\")\n>>> brin_adn\nLa séquence de mon brin d'ADN est ['A', 'T']\n>>> brin_adn.len\n2\n>>> brin_adn.ajoute_atome(\"G\")\n>>> brin_adn\nLa séquence de mon brin d'ADN est ['A', 'T', 'G']\n>>> brin_adn.len\n3\nLorsqu’on utilise l’attribut , ceci invoque finalement l’appel de l’objet property qui, in fine, est\nbrin_adn.len len\nune méthode. Ainsi, la valeur renvoyée sera calculée à chaque fois, bien que dans la syntaxe on n’a pas une notation\n, mais plutôt . Voilà pourquoi nous avons parlé d’attribut dynamique. Cela permet d’alléger la\n.methode() .attribut\nsyntaxe quand il n’y a pas spécifiquement d’arguments à passer à la méthode qui se trouve derrière cet attribut."
  },
  {
    "title": "Bonnes pratiques pour construire et manipuler ses classes",
    "content": "Nous allons voir dans cette rubrique certaines pratiques que nous vous recommandons lorsque vous construisez vos\npropres classes.\n24.7.1 L’accès aux attributs\nOn a vu dans la rubrique Accès et modifications des attributs depuis l’extérieur que nous avions le moyen de contrôler\ncet accès avec la classe property. Toutefois, cela peut parfois alourdir inutilement le code, ce qui va à l’encontre de\ncertains préceptes de la PEP 20 comme « Sparse is better than dense », « Readability counts », etc. (voir le chapitre 16\nBonnes pratiques en programmation Python).\nConseil\nSi on souhaite contrôler ce que fait le client de la classe pour certains attributs « délicats » ou « stratégiques », on peut\nutiliser la classe property. Toutefois, nous vous conseillons de ne l’utiliser que lorsque cela se révèle vraiment nécessaire,\ndonc avec parcimonie. Le but étant de ne pas surcharger le code inutilement. Cela va dans le sens des recommandations\ndes développeurs de Python (comme décrit dans la PEP8).\nLes objets property ont deux avantages principaux :\n•\nils permettent de garder une lisibilité du côté client avec une syntaxe\n;\ninstance.attribut\n•\nmême si un jour vous décidez de modifier votre classe et de mettre en place un contrôle d’accès à certains attributs\navec des objets property, cela ne changera rien du côté client. Ce dernier utilisera toujours\ninstance.attribut\nou\n. Tout cela contribuera à une meilleure maintenance du code client utilisant votre\ninstance.attribut = valeur\nclasse.\nCertains détracteurs disent qu’il est parfois diﬀicile de déterminer qu’un attribut est contrôlé avec un objet property.\nLa réponse à cela est simple, dites-le clairement dans la documentation de votre classe via les docstrings (voir la rubrique\nci-dessous).\n24.7.2 Note sur les attributs publics et non publics\nCertains langages orientés objet mettent en place des attributs dits privés dont l’accès est impossible de l’extérieur de\nla classe. Ceux-ci existent afin d’éviter qu’un client n’aille perturber ou casser quelque chose dans la classe. Les arguments\nauxquels l’utilisateur a accès sont dits publics.\nAttention\n290 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.7. Bonnes pratiques pour construire et manipuler ses classes Chapitre 24. Avoir plus la classe avec les objets\nEn Python, il n’existe pas d’attributs privés comme dans d’autres langages orientés objet. L’utilisateur a accès à tous\nles attributs quels qu’ils soient, même s’ils contiennent un ou plusieurs caractère(s) underscore(s) (voir ci-dessous) !\nAu lieu de ça, on parle en Python d’attributs publics et non publics.\nDéfinition\nEn Python les attributs non publics sont des attributs dont le nom commence par un ou deux caractère(s) underscore.\nPar exemple, , ou .\n_attribut __attribut\nLa présence des underscores dans les noms d’attributs est un signe clair que le client ne doit pas y toucher. Toutefois,\ncela n’est qu’une convention, et comme dit ci-dessus le client peut tout de même modifier ces attributs.\nPar exemple, reprenons la classe de la rubrique précédente dont l’attribut est contrôlé avec un objet\nCitron .masse\nproperty :\n1\n>>> citron = Citron()\n2 Coucou je suis dans le set\n3\n>>> citron.masse\n4 Coucou je suis dans le get\n5\n0\n6 >>> citron.masse = -16\n7\nCoucou je suis dans le set\n8 Traceback (most recent call last):\n9\nFile \"<stdin>\", line 1, in <module>\n10 File \"<stdin>\", line 11, in set_masse\n11\nValueError: Un citron ne peut pas avoir de masse négative !\n12 >>> citron.masse = 16\n13\nCoucou je suis dans le set\n14 >>> citron.masse\n15 Coucou je suis dans le get\n16\n16\n17 >>> citron._masse\n18\n16\n19 >>> citron._masse = -8364\n20\n>>> citron.masse\n21 Coucou je suis dans le get\n22\n-8364\n23 >>>\nMalgré l’objet , nous avons pu modifier l’attribut non public directement !\nproperty ._masse\nIl existe également des attributs dont le nom commence par deux caractères underscores. Nous n’avons encore jamais\ncroisé ce genre d’attribut. Ces derniers mettent en place le name mangling.\nDéfinition\n14\nLe name mangling , ou encore substantypage ou déformation de nom en français, correspond à un mécanisme de\nchangement du nom d’un attribut selon si on est à l’intérieur ou à l’extérieur d’une classe.\nRegardons un exemple :\n14. https://en.wikipedia.org/wiki/Name_mangling\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 291\nChapitre 24. Avoir plus la classe avec les objets 24.7. Bonnes pratiques pour construire et manipuler ses classes\n1\nclass Citron:\n2 def __init__(self):\n3\nself.__mass = 100\n4\n5\ndef get_mass(self):\n6 return self.__mass\n7\n8\n9 if __name__ == \"__main__\":\n10\ncitron1 = Citron()\n11 print(citron1.get_mass())\n12\nprint(citron1.__mass)\nCe code va donner la sortie suivante :\n1 100\n2 Traceback (most recent call last):\n3 File \"mangling.py\", line 12, in <module>\n4\nprint(citron1.__mass)\n5 ^^^^^^^^^^^^^^\n6\nAttributeError: 'Citron' object has no attribute '__mass'\nLa ligne 12 du code a donc conduit à une erreur : Python prétend ne pas connaître l’attribut . On pourrait\n.__mass\ncroire que cela constitue un mécanisme de protection des attributs. En fait il n’en est rien, car on va voir que l’attribut\nest toujours accessible et modifiable. Si on modifiait le programme principal comme suit :\n1\nif __name__ == \"__main__\":\n2 citron1 = Citron()\n3\nprint(citron1.__dict__)\nOn obtiendrait en sortie le dictionnaire .\n{'_Citron__mass': 100}\nLe name mangling est donc un mécanisme qui transforme le nom à l’intérieur de la classe en\nself.__attribut\nà l’extérieur de la classe. Ce mécanisme a été conçu initialement pour pouvoir\ninstance._NomClasse__attribut\nretrouver des noms d’attributs identiques lors de l’héritage. Si par exemple une classe mère et une classe fille ont chacune\nun attribut nommé , le name mangling permet d’éviter les conflits de nom. Par exemple :\n__attribut\n1\nclass Fruit:\n2 def __init__(self):\n3\nself.__mass = 100\n4\n5\n6 class Citron(Fruit):\n7 def __init__(self):\n8\nFruit.__init__(self)\n9 self.__mass = 200\n10\n11 def print_masse(self):\n12\nprint(self._Fruit__mass)\n13 print(self.__mass)\n14\n15\n16\nif __name__ == \"__main__\":\n17 citron1 = Citron()\n18\ncitron1.print_masse()\nCe code aﬀiche puis . La ligne 12 a permis d’accéder à l’attribut de la classe mère , et la\n100 200 .__mass Fruit\nligne 13 a permis d’accéder à l’attribut de la classe .\n.__mass Citron\nLe name mangling n’est donc pas un mécanisme de « protection » d’un attribut, il n’a pas été conçu pour ça. Les\nconcepteurs de Python le disent clairement dans la PEP 8 : « Generally, double leading underscores should be used only\nto avoid name conflicts with attributes in classes designed to be subclassed ».\nDonc en Python, on peut tout détruire, même les attributs délicats contenant des underscores. Pourquoi Python\npermet-il un tel paradoxe ? Selon le concepteur de Python, Guido van Rossum : « We’re all consenting adults here »,\nnous sommes ici entre adultes, autrement dit nous savons ce que nous faisons !\n292 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.7. Bonnes pratiques pour construire et manipuler ses classes Chapitre 24. Avoir plus la classe avec les objets\nConseil\nEn résumé, n’essayez pas de mettre des barrières inutiles vers vos attributs. Cela va à l’encontre de la philosophie\nPython. Soignez plutôt la documentation et faites confiance aux utilisateurs de votre classe !\n24.7.3 Classes et docstrings\nLes classes peuvent bien sûr contenir des docstrings comme les fonctions et les modules. C’est d’ailleurs une pratique\nvivement recommandée. Voici un exemple sur notre désormais familière classe :\nCitron\n1\nclass Citron:\n2 \"\"\"Voici la classe Citron.\n3\n4 Il s'agit d'une classe assez impressionnante qui crée des objets\n5\ncitrons.\n6 Par défaut une instance de Citron contient l'attribut de classe\n7\nsaveur.\n8 \"\"\"\n9\nsaveur = \"acide\"\n10\n11 def __init__(self, couleur=\"jaune\", taille=\"standard\"):\n12\n\"\"\"Constructeur de la classe Citron.\n13\n14\nCe constructeur prend deux arguments par mot-clé\n15 couleur et taille.\"\"\"\n16\nself.couleur = couleur\n17 self.taille = taille\n18\n19 def __str__(self):\n20\n\"\"\"Redéfinit le comportement avec print().\"\"\"\n21 return f\"saveur: {saveur}, couleur: {couleur}, taille: {taille}\"\n22\n23 def affiche_coucou(self):\n24 \"\"\"Méthode inutile qui affiche coucou.\"\"\"\n25\nprint(\"Coucou !\")\nSi on fait dans l’interpréteur, on obtient :\nhelp(Citron)\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 293\nChapitre 24. Avoir plus la classe avec les objets 24.7. Bonnes pratiques pour construire et manipuler ses classes\n1\nHelp on class Citron in module __main__:\n2\n3\nclass Citron(builtins.object)\n4 | Citron(couleur='jaune', taille='standard')\n5\n|\n6 | Voici la classe Citron.\n7 |\n8\n| Il s'agit d'une classe assez impressionnante qui crée des objets\n9 | citrons.\n10\n| Par défaut une instance de Citron contient l'attribut de classe\n11 | saveur.\n12\n|\n13 | Methods defined here:\n14\n|\n15 | __init__(self, couleur='jaune', taille='standard')\n16\n| Constructeur de la classe Citron.\n17 |\n18\n| Ce constructeur prend deux arguments par mot-clé\n19 | couleur et taille.\n20 |\n21 | __str__(self)\n22 | Redéfinit le comportement avec print().\n23\n|\n24 | affiche_coucou(self)\n25\n| Méthode inutile qui affiche coucou.\n26 |\n27\n[...]\n28 |\n29\n| Data and other attributes defined here:\n30 |\n31\n| saveur = 'acide'\nPython formate automatiquement l’aide comme il le fait avec les modules (voir chapitre 15 Création de modules).\nComme nous l’avons dit dans le chapitre 16 Bonnes pratiques en programmation Python, n’oubliez pas que les docstrings\nsont destinées aux utilisateurs de votre classe. Elles doivent donc contenir tout ce dont un utilisateur a besoin pour\ncomprendre ce que fait la classe et comment l’utiliser.\nNotez que si on instancie la classe et qu’on invoque l’aide sur l’instance , on\ncitron1 = Citron() help(citron1)\nobtient la même page d’aide. Comme pour les modules, si on invoque l’aide pour une méthode de la classe\n, on obtient l’aide pour cette méthode seulement.\nhelp(citron1.affiche_coucou)\nToutes les docstrings d’une classe sont en fait stockées dans un attribut spécial nommé . Cet\ninstance.__doc__\nattribut est une chaîne de caractères contenant la docstring générale de la classe. Ceci est également vrai pour les\nmodules, méthodes et fonctions. Si on reprend notre exemple ci-dessus :\n1 >>> citron1 = Citron()\n2\n>>> print(citron1.__doc__)\n3 Voici la classe Citron.\n4\n5\nIl s'agit d'une classe assez impressionnante qui crée des objets\n6 citrons.\n7\nPar défaut une instance de Citron contient l'attribut de classe\n8 saveur.\n9\n10 >>> print(citron1.affiche_coucou.__doc__)\n11\nMéthode inutile qui affiche coucou.\nL’attribut est automatiquement créé par Python au moment de la mise en mémoire de la classe (ou module,\n.__doc__\nméthode, fonction, etc.).\n24.7.4 Autres bonnes pratiques\nVoici quelques points en vrac auxquels nous vous conseillons de faire attention :\n•\nUne classe ne se conçoit pas sans méthode. Si on a besoin d’une structure de données séquentielles ou si on veut\ndonner des noms aux variables (plutôt qu’un indice), utilisez plutôt les dictionnaires. Une bonne alternative peut\nêtre les namedtuples (voir la rubrique suivante).\n294 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.7. Bonnes pratiques pour construire et manipuler ses classes Chapitre 24. Avoir plus la classe avec les objets\n•\nNous vous déconseillons de mettre comme paramètre par défaut une liste vide (ou tout autre objet séquentiel\nmodifiable) :\n1\ndef __init__(self, liste=[]):\n2 self.liste = liste\nSi vous créez des instances sans passer d’argument lors de l’instanciation, toutes ces instances pointeront vers la\nmême liste. Cela peut avoir des effets désastreux.\n•\nNe mettez pas non plus une liste vide (ou tout autre objet séquentiel modifiable) comme attribut de classe.\n1 class Citron:\n2\nliste = []\nIci chaque instance pourra modifier la liste, ce qui n’est pas souhaitable. Souvenez-vous, la modification des attributs\nde classe doit se faire par une syntaxe (et non pas via les instances).\nCitron.attribut = valeur\n•\nComme abordé dans la rubrique Différence entre les attributs de classe et d’instance, nous vous conseillons de ne\njamais modifier les attributs de classe. Vous pouvez néanmoins les utiliser comme constantes.\n•\nSi vous avez besoin d’attributs modifiables, utilisez des attributs d’instance et initialisez-les dans la méthode\n.\n(et nulle part ailleurs). Par exemple, si vous avez besoin d’une liste comme attribut, créez la plutôt\n__init__()\ndans le constructeur :\n1 class Citron:\n2\ndef __init__(self):\n3 self.liste = []\nAinsi, vous aurez des listes réellement indépendantes pour chaque instance.\n24.7.5 Namedtuples\nImaginons que l’on souhaite stocker des éléments dans un conteneur, que l’on puisse retrouver ces éléments avec une\nsyntaxe et que ces éléments soient non modifiables. On a vu ci-dessus, les classes ne sont pas faites\nconteneur.element\npour cela, il n’est pas conseillé de les utiliser comme des conteneurs inertes, on les conçoit en général afin d’y créer aussi\n15\ndes méthodes. Dans ce cas, les namedtuples sont faits pour vous ! Ce type de conteneur est issu du module collections\nque nous avions évoqué dans le chapitre 14 Conteneurs.\n1 >>> import collections\n2\n>>> Citron = collections.namedtuple(\"Citron\", \"masse couleur saveur forme\")\n3 >>> Citron\n4\n<class '__main__.Citron'>\n5 >>> citron = Citron(10, \"jaune\", \"acide\", \"ellipsoide\")\n6\n>>> citron\n7 Citron(masse=10, couleur='jaune', saveur='acide', forme='ellipsoide')\n8\n>>> citron.masse\n9 10\n10\n>>> citron.forme\n11 'ellipsoide'\nLignes 2 à 4. La fonction renvoie une classe qui sert à créer de nouveaux objets citrons. Attention\nnamedtuple()\ncette classe est différente de celles que l’on a rencontrées jusqu’à maintenant, car elle hérite de la classe\nbuiltins.tuple\n(on peut le voir en faisant ). En ligne 2, on passe en argument le nom de la classe souhaitée (i.e. ),\nhelp(Citron) Citron\npuis une chaîne de caractères avec des mots séparés par des espaces qui correspondront aux attributs (on pourrait aussi\npasser une liste ).\n[\"masse\", \"couleur\", \"saveur\", \"forme\"]\nLigne 5. On instancie un nouvel objet .\ncitron\nLignes 6 à 11. On peut retrouver les différents attributs avec une syntaxe .\ninstance.attribut\nMais dans namedtuple, il y a tuple ! Ainsi, l’instance hérite de tous les attributs des tuples :\ncitron\n15. https://docs.python.org/fr/3/library/collections.html#collections.namedtuple\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 295\nChapitre 24. Avoir plus la classe avec les objets 24.8. Note finale de sémantique\n1\n>>> citron[0]\n2 10\n3\n>>> citron[3]\n4 'ellipsoide'\n5\n>>> citron.masse = 100\n6 Traceback (most recent call last):\n7 File \"<stdin>\", line 1, in <module>\n8\nAttributeError: can't set attribute\n9 >>> for elt in citron:\n10\n... print(elt)\n11 ...\n12\n10\n13 jaune\n14\nacide\n15 ellipsoide\nLignes 1 à 4. On peut retrouver les attributs également par indice.\nLignes 5 à 8. Les attributs / éléments sont non modifiables !\nLignes 9 à 15. Les namedtuples sont itérables.\nUn namedtuple est non modifiable, mais on peut en générer un nouveau avec la méthode , à l’image\n._replace()\nde la méthode pour les chaînes de caractères :\n.replace()\n1 >>> citron._replace(masse=30)\n2\nCitron(masse=30, couleur='jaune', saveur='acide', forme='ellipsoide')\n3 >>> citron\n4\nCitron(masse=10, couleur='jaune', saveur='acide', forme='ellipsoide')\n5 >>> citron = citron._replace(masse=30)\n6\n>>> citron\n7 Citron(masse=30, couleur='jaune', saveur='acide', forme='ellipsoide')\nLignes 1 et 2. On crée un nouveau namedtuples avec la méthode . Notez qu’il faut passer un (ou\n._replace()\nplusieurs) argument(s) par mot-clé à cette méthode désignant les attributs à modifier.\nLignes 3 et 4. L’objet initial est intact puisqu’un namedtuples est non modifiable.\ncitron\nLignes 5 à 7. En ré-affectant ce que renvoie la méthode dans dans un objet de même nom ,\n._replace() citron\non peut faire évoluer son contenu comme on a pu le faire avec les chaînes de caractères.\nEnfin, il est possible de convertir un namedtuple en dictionnaire (ordonné) avec la méthode :\n._asdict()\n1 >>> citron._asdict()\n2 OrderedDict([('masse', 10), ('couleur', 'jaune'), ('saveur', 'acide'), ('forme', 'ellipsoide')])\nQuand utiliser les namedtuples ? Vous souvenez-vous de la différence entre les listes et les dictionnaires ? Ici, c’est\nun peu la même chose entre les tuples et les namedtuples. Les namedtuples permettent de créer un code plus lisible en\nremplaçant des numéros d’indice par des noms. Le fait qu’ils soient non modifiables peut aussi avoir un avantage par\nrapport à l’intégrité des données. Si vous trouvez les namedtuples limités, sachez que vous pouvez créer votre propre\nclasse qui hérite d’un namedtuple afin de lui ajouter de nouvelles méthodes « maison ».\nPour aller plus loin\n16\nPour aller plus loin, vous pouvez consulter le très bon article de Dan Bader."
  },
  {
    "title": "Note finale de sémantique",
    "content": "Jusqu’à présent, lorsque nous avons évoqué les outils pour créer ou convertir des objets Python tels que ,\nint()\n, , etc., nous avons toujours parlé de fonctions. Ceci parce-que nous avions une syntaxe ,\nlist() range() fonction()\nc’est-à-dire suivie de parenthèses . Toutefois, vous vous êtes peut-être déjà demandé pourquoi Python\nfonction ()\nindiquait lorsqu’on tapait le nom de ces fonctions dans l’interpréteur (ou en invoquant ) :\nclass help()\n16. https://dbader.org/blog/writing-clean-python-with-namedtuples\n296 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.9. Exercices Chapitre 24. Avoir plus la classe avec les objets\n1\n>>> int\n2 <class 'int'>\n3\n>>> list\n4 <class 'list'>\n5\n>>> range\n6 <class 'range'>\n7 >>> property\n8\n<class 'property'>\nEt bien, c’est parce-que ce sont bel et bien des classes ! Donc, lorsqu’on invoque par exemple , on\nliste1 = list()\ncrée finalement une instance de la classe . Python ne met pas en CamelCase car ce sont des classes natives\nlist list\n(built-in classes). En effet, les auteurs de Python ont décidé que les classes et fonctions natives sont en minuscules, et\n17\nles exceptions en CamelCase (voir ce lien ).\nFinalement, la création d’une instance à partir d’une classe ou l’appel d’une fonction possède la même syntaxe\n:\nmot_clé()\n1\n>>> class Citron:\n2 ... pass\n3\n...\n4 >>> Citron()\n5\n<__main__.Citron object at 0x7fb776308a10>\n6 >>> def fct():\n7\n... return \"Coucou\"\n8 ...\n9\n>>> fct()\n10 'Coucou'\nOn peut le voir aussi quand on invoque l’aide sur un de ces outils, par exemple :\nhelp(int)\nHelp on class int in module builtins:\nclass int(object)\n| int([x]) -> integer\n| int(x, base=10) -> integer\n[...]\nIl est bien précise que est une classe.\nint\nSi on prend des fonctions natives (built-in functions) de Python comme ou , l’interpréteur nous\nlen() sorted()\nconfirme bien qu’il s’agit de fonctions :\n1 >>> len\n2\n<built-in function len>\n3 >>> sorted\n4\n<built-in function sorted>\nPar conséquent, d’un point de vue purement sémantique nous devrions parler de classe plutôt que de fonction pour\nles instructions comme , , etc. Toutefois, nous avons décidé de garder le nom fonction pour ne pas\nlist() range()\ncompliquer les premiers chapitres de ce cours."
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell.\n24.9.1 Classe molécule\nPour illustrer le mécanisme de la composition en POO, on se propose de créer un programme qui\nmolecule.py\npermettra de décrire une molécule en utilisant les classes. Nous allons créer une classe représentant une molécule (qui\nsera notre classe Composite) et celle-ci contiendra des instances d’une classe décrivant un atome (classe Component).\n17. https://peps.python.org/pep-0008/#class-names\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 297\nChapitre 24. Avoir plus la classe avec les objets 24.9. Exercices\n18\nOn se propose de tester cela sur la molécule simple de benzene. Vous aurons besoin du fichier pour\nbenzene.pdb\nréaliser cet exercice.\nAprès les import nécessaires, le programme contiendra une constante donnant les masses des atomes sous forme de\ndictionnaire : .\nATOM_MASSES = {\"C\": 12.0, \"O\": 16.0, \"H\": 1.0}\nCréer une classe en vous inspirant des exercices du chapitre 23 Avoir la classe avec les objets. Cette classe devra\nAtom\ninstancier des objets contenant les attributs d’instance suivants :\n•\nnom d’atome (par exemple )\nC1\n•\ntype d’atome (une seule lettre, déduit du nom d’atome, par exemple )\nC\n•\ncoordonnée x\n•\ncoordonnée y\n•\ncoordonnée z\nLe nom d’atome et coordonnées cartésiennes seront passés au constructeur.\nAjouter les méthodes , (center of mass). Ajouter une méthode\ncalc_distance() calc_com() mute_atom(name\nqui change le nom de l’atome, où est un nouveau nom d’atome (par exemple ). Cette méthode changera\n) name O1\négalement l’attribut d’instance décrivant le type d’atome.\nCréer une classe qui construit les attributs d’instance : - Nom de la molécule - Une liste d’atomes (vide à\nMolecule\nl’instanciation) : - Une liste indiquant la connectivité (la liste des atomes connectés, vide à l’instanciation) :\nlist_atoms\nlist_connectivity\nLe constructeur prendra en argument seulement le nom de la molécule.\nCréer une méthode qui vérifie si l’argument passé est bien une instance de la classe , et qui\nadd_atom(atom) Atom\najoute dans la liste d’atomes.\natom\nCréer une autre méthode qui prend en argument un nom de fichier pdb. La\nbuild_mlc_from_pdb(filename)\nméthode lit le fichier pdb, et pour chaque atome lu, crée une instance de la classe , et ajouter celle-ci à\nAtom list_atoms\n.\nAjouter une méthode qui calcule et renvoie masse de la molécule.\ncalc_mass()\nCréer une méthode qui cette fois-ci calcule et renvoie le centre de masse de la molécule entière.\ncalc_com()\nAjouter la méthode qui calcule et renvoie une liste décrivant la connectivité entre les atomes.\ncalc_connectivity()\nDeux atomes sont considérés connectés s’il y a une liaison covalente entre eux, on peut pour cela calculer la distance\nentre eux qui doit être inférieure à 1.6 Å. La liste de connectivité pourra être construite dans ce style :\n[(\"C1\", \"H1\")\n.\n, (\"C1\", \"C2\"), ...]\nChaque paire d’atome doit apparaitre une seule fois (pas de .\n[(\"C1\", \"H1\"), [(\"H1\", \"C1\"), ...]\nCréer une méthode spéciale aﬀichant les caractéristiques de la molécule lorsqu’on utilise avec une instance\nprint()\nde cette classe , par exemple . Cette méthode pourra par exemple aﬀicher avant d’avoir créé\nMolecule print(benzene)\nla molécule :\nMolecule benzene\nNo atom for the moment\nNo connectivity for the moment\nOu bien, lorsque la molécule est créée et la connectivité déterminée, elle s’aﬀichera comme ceci :\nMolecule benzene\natom C1, type C, mass = 12.0 amu, coor( -2.145, 0.973, -0.003)\natom H1, type H, mass = 1.0 amu, coor( -3.103, 0.460, -0.005)\n[...]\nConnectivity\nC1 connected to H1\nC1 connected to C2\n[...]\nPour lancer le programme dans un premier temps, vous pourrez instancier une molécule benzene, puis y ajouter les\natomes :\n1 if __name__ == \"__main__\":\n2 benzene = Molecule(\"benzene\")\n3\nprint(benzene)\n4 benzene.build_mlc_from_pdb(\"benzene.pdb\")\n5\nprint(benzene)\n18. %22https://python.sdv.u-paris.fr/data-files/benzene.pdb%22\n298 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n24.9. Exercices Chapitre 24. Avoir plus la classe avec les objets\nDans un deuxième temps, le programme principal calculera la masse et le centre de masse de benzene et les aﬀichera.\nMuter ensuite l’atome en et recalculer la masse et le centre de masse et les aﬀicher.\nH1 O1\nPour aller plus loin, vous pouvez ajouter une méthode qui calcule et aﬀiche un graphe de la molécule avec le module\n19 20\nnetworkx . La page de tutorial pourra vous être utile.\nPar exemple :\nFigure 24.4 – Graphe représentant une molécule de benzène.\n19.\nhttps://networkx.org/\n20. https://networkx.org/documentation/latest/tutorial.html#drawing-graphs\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 299"
  },
  {
    "title": "Fenêtres graphiques et Tkinter",
    "content": "Conseil\nDans ce chapitre, nous allons utiliser des classes, nous vous conseillons de bien relire les chapitres 23 Avoir la classe\navec les objets et 24 Avoir plus la classe avec les objets (en ligne). Par ailleurs, nous vous conseillons de relire également\nla rubrique Arguments positionnels et arguments par mot-clé du chapitre 10 sur les fonctions."
  },
  {
    "title": "Utilité d’une GUI",
    "content": "Dans votre carrière « pythonesque » il se peut que vous soyez amené à vouloir développer une application graphique,\non parle encore de graphical user interface ou GUI. Jusqu’à maintenant, vous avez fait en sorte qu’un utilisateur interagisse\navec votre code via la ligne de commande, par exemple :\n$ python mon_script.py file.gbk blabla blublu\nLes arguments passés à la ligne de commande sont tout à fait classiques dans le monde de la bioinformatique. Toutefois,\nil se peut que vous développiez un programme pour une communauté plus large, qui n’a pas forcément l’habitude d’utiliser\nun shell et la ligne de commande. Une GUI permettra un usage plus large de votre programme, il est donc intéressant\nde regarder comment s’y prendre. Dans notre exemple ci-dessus on pourrait par exemple développer une interface où\nl’utilisateur choisirait le nom du fichier d’entrée par l’intermédiaire d’une boîte de dialogue, et de contrôler les options en\ncliquant sur des boutons, ou des « listes de choix ». Une telle GUI pourrait ressembler à la figure 25.1.\nAu delà de l’aspect convivial pour l’utilisateur, vous pourrez, avec une GUI, construire des fenêtres illustrant des\néléments que votre programme génère à la volée. Ainsi, vous « verrez » ce qui se passe de manière explicite et en direct !\nPar exemple, si on réalise une simulation de particules, on a envie de voir un « film » des particules en mouvement, c’est-\nà-dire comment ces particules bougent au fur et à mesure que les pas de simulation avancent. Une GUI vous permettra\nune telle prouesse ! Enfin, sachez que certains logiciels scientifiques ont été développés avec la bibliothèque graphique Tk\n(par exemple pymol, vmd, etc.). Qui sait, peut-être serez-vous le prochain développeur d’un outil incontournable ?\n1 2 3\nIl existe beaucoup de modules pour construire des applications graphiques. Par exemple : Tkinter , wxpython , PyQt ,\n1. https://wiki.python.org/moin/TkInter\n2.\nhttp://www.wxpython.org/\n3. https://pyqt.readthedocs.io\n300\n25.2. Quelques concepts liés à la programmation graphique Chapitre 25. Fenêtres graphiques et Tkinter\nFigure 25.1 – Exemple de GUI.\n4\nPyGObject , etc. Nous présentons dans ce chapitre le module Tkinter qui est présent de base dans les distributions Python\n(pas besoin a priori de faire d’installation de module externe). Tkinter permet de piloter la bibliothèque graphique Tk\n(Tool Kit), Tkinter signifiant tk interface. On pourra noter que cette bibliothèque Tk peut être également pilotée par\nd’autres langages (Tcl, perl, etc.)."
  },
  {
    "title": "Quelques concepts liés à la programmation graphique",
    "content": "Lorsque l’on développe une GUI, nous créons une fenêtre graphique contenant notre application, ainsi que des widgets\ninclus dans la fenêtre.\nDéfinition\nLes widgets (window gadget) sont des objets graphiques permettant à l’utilisateur d’interagir avec votre programme\nPython de manière conviviale. Par exemple, dans la fenêtre sur la figure 25.1, les boutons, les listes de choix, ou encore\nla zone de texte sont des widgets.\nL’utilisation d’une GUI va amener une nouvelle manière d’aborder le déroulement d’un programme, il s’agit de la\nprogrammation dite « événementielle ». Jusqu’à maintenant vous avez programmé « linéairement », c’est-à-dire que\nles instructions du programme principal s’enchaînaient les unes derrière les autres (avec bien sûr de possibles appels à\ndes fonctions). Avec une GUI, l’exécution est décidée par l’utilisateur en fonction de ses interactions avec les différents\nwidgets. Comme c’est l’utilisateur qui décide quand et où il clique dans l’interface, il va falloir mettre en place ce qu’on\nappelle un « gestionnaire d’événements ».\nDéfinition\nLe gestionnaire d’événements est une sorte de « boucle infinie » qui est à l’affût de la moindre action de la part de\nl’utilisateur. C’est lui qui effectuera une action lors de l’interaction de l’utilisateur avec chaque widget de la GUI. Ainsi,\nl’exécution du programme sera réellement guidée par les actions de l’utilisateur.\nLa bibliothèque Tk que nous piloterons avec le module Python Tkinter propose tous les éléments cités ci-dessus (fe-\nnêtre graphique, widgets, gestionnaire d’événements). Nous aurons cependant besoin d’une dernière notion : les fonctions\ncallback.\nDéfinition\n4. https://pygobject.readthedocs.io/en/latest/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 301\nChapitre 25. Fenêtres graphiques et Tkinter 25.3. Notion de fonction callback\nUne fonction callback est une fonction passée en argument d’une autre fonction.\nUn exemple de fonction callback est présenté dans la rubrique suivante."
  },
  {
    "title": "Notion de fonction callback",
    "content": "Conseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nJusqu’à maintenant nous avons toujours appelé les fonctions ou les méthodes de cette manière :\n1 var = fct(arg1, arg2)\n2\n3 obj.methode(arg)\noù les arguments étaient des objets « classiques » (par exemple une chaîne de caractères, un entier, un float, etc.).\nSachez qu’il est possible de passer en argument une fonction à une autre fonction ! Par exemple :\n1 def fct_callback(arg):\n2\nprint(f\"J'aime bien les {arg} !\")\n3\n4\n5\ndef une_fct(ma_callback):\n6 print(\"Je suis au début de une_fct(), \"\n7\n\"et je vais exécuter la fonction callback :\")\n8 ma_callback(\"fraises\")\n9\nprint(\"une_fct() se termine.\")\n10\n11\nif __name__ == \"__main__\":\n12 une_fct(fct_callback)\nSi on exécute ce code, on obtient :\nJe suis au début de une_fct() et je vais exécuter la fonction callback :\nJ'aime bien les fraises !\nune_fct() se termine.\nVous voyez que dans le programme principal, lors de l’appel de , on lui passe comme argument une autre\nune_fct()\nfonction mais sans aucune parenthèses ni argument, c’est-à-dire tout court. En d’autres termes, cela\nfct_callback\nest différent de\n.\nune_fct(fct_callback(\"scoubidous\"))\nDans une telle construction, serait d’abord évaluée, puis ce serait la valeur ren-\nfct_callback(\"scoubidous\")\nvoyée par cet appel qui serait passée à (n’essayez pas sur notre exemple car cela mènerait à une erreur !).\nune_fct()\nQue se passe-t-il en filigrane lors de l’appel ? Python passe une référence vers la fonction\nune_fct(fct_callback)\n(en réalité il s’agit d’un pointeur, mais tout ceci est géré par Python et est transparent pour l’utilisateur).\nfct_callback\nVous souvenez-vous ce qui se passait avec une liste passée en argument à une fonction (voir le chapitre 13 Plus sur les\n5\nfonctions) ? C’était la même chose, une référence était envoyée plutôt qu’une copie. Python Tutor nous confirme cela\n(cf. figure 25.2).\nLorsqu’on est dans on pourra utiliser bien sûr des arguments lors de l’appel de notre fonction callback\nune_fct()\nsi on le souhaite. Notez enfin que dans la fonction callback reçue en argument peut avoir un nom différent\nune_fct()\n(comme pour tout type de variable).\nÀ quoi cela sert-il ? À première vue cette construction peut sembler ardue et inutile. Toutefois, vous verrez que dans\nle module Tkinter les fonctions callback sont incontournables. En effet, on utilise cette construction pour lancer une\nfonction lors de l’interaction de l’utilisateur avec un widget : par exemple, lorsque l’utilisateur clique sur un bouton et\nqu’on souhaite lancer une fonction particulière suite à ce clic. Notez enfin que nous les avons déjà croisées avec :\n5. http://pythontutor.com\n302 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n25.4. Prise en main du module Tkinter Chapitre 25. Fenêtres graphiques et Tkinter\nFigure 25.2 – Exemple de fonction callback dans Python Tutor.\n•\nle tri de dictionnaire par valeur avec la syntaxe (voir le chapitre 8 Dictionnaires\nsorted(dico, key=dico.get)\net tuples) ;\n•\nle tri par longueur de mots avec la syntaxe (voir chapitre 12 Plus sur les listes) ;\nsorted(liste, key=len)\n•\nles objets avec la syntaxe (voir le chapitre 24 Avoir\nproperty property(fget=get_masse, fset=set_masse)\nplus la classe avec les objets (en ligne))."
  },
  {
    "title": "Prise en main du module Tkinter",
    "content": "Le module Tkinter est très vaste. Notre but n’est pas de vous faire un cours exhaustif mais plutôt de vous montrer\nquelques pistes. Pour apprendre à piloter ce module, nous pensons qu’il est intéressant de vous montrer des exemples. Nous\nallons donc en présenter quelques-uns qui pourraient vous être utiles, à vous ensuite de consulter de la documentation\nsupplémentaire si vous souhaitez aller plus loin (cf. la rubrique Bibliographie pour aller plus loin).\n25.4.1 Un premier exemple dans l’interpréteur\nCommençons par construire un script qui aﬀichera une simple fenêtre avec un message et un bouton. Regardons\nd’abord comment faire dans l’interpréteur (nous vous conseillons de tester ligne par ligne ce code tout en lisant les\ncommentaires ci-dessous) :\n1 >>> import tkinter as tk\n2\n>>> racine = tk.Tk()\n3 >>> label = tk.Label(racine, text=\"J'adore Python !\")\n4\n>>> bouton = tk.Button(racine, text=\"Quitter\", fg=\"red\",\n5 ... command=racine.destroy)\n6\n>>> label.pack()\n7 >>> bouton.pack()\n8\n>>>\nLigne 2. On crée la fenêtre principale (vous la verrez apparaître !). Pour cela, on crée une instance de la classe\ntk.Tk\ndans la variable . Tous les widgets que l’on créera ensuite seront des fils de cette fenêtre. On pourra d’ailleurs\nracine\nnoter que cette classe ne s’instancie en général qu’une seule fois par programme. Vous pouvez, par curiosité, lancer\ntk.Tk\nune commande ou , vous verrez ainsi les très nombreuses méthodes et attributs associés à\ndir(racine) help(racine)\nun tel objet Tk.\nLigne 3. On crée un label, c’est-à-dire une zone dans la fenêtre principale où on écrit un texte. Pour cela, on a créé\nune variable qui est une instance de la classe . Cette variable contient donc notre widget, nous la\nlabel tk.Label label\nréutiliserons plus tard (par exemple pour placer ce widget dans la fenêtre). Notez le premier argument positionnel\nracine\npassé à la classe , celui-ci indique la fenêtre parente où doit être dessinée le label. Cet argument doit toujours\ntk.Label\nêtre passé en premier et il est vivement conseillé de le préciser. Nous avons passé un autre argument avec le nom\npour indiquer, comme vous l’avez deviné, le texte que nous souhaitons voir dans ce label. La classe\ntext tk.Label\n6\npeut recevoir de nombreux autres arguments, en voici la liste exhaustive . Dans les fonctions Tkinter qui construisent\n6. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/label.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 303\nChapitre 25. Fenêtres graphiques et Tkinter 25.4. Prise en main du module Tkinter\nun widget, les arguments possibles pour la mise en forme de celui-ci sont nombreux, si bien qu’ils sont toujours des\narguments par mot-clé. Si on ne précise pas un de ces arguments lors de la création du widget, l’argument prendra\nalors une valeur par défaut. Cette liste des arguments par mot-clé est tellement longue qu’en général on ne les précisera\npas tous. Heureusement, Python autorise l’utilisation des arguments par mot-clé dans un ordre quelconque. Comme nous\nl’avons vu dans le chapitre 10 Fonctions, souvenez vous que leur utilisation dans le désordre implique qu’il faudra toujours\npréciser leur nom : par exemple vous écrirez et non pas tout court.\ntext=\"blabla\" \"blabla\"\nLigne 4. De même, on crée un bouton « Quitter » qui provoquera la fermeture de la fenêtre et donc l’arrêt de\nl’application si on clique dessus. À nouveau, on passe la fenêtre parente en premier argument, le texte à écrire dans le\nbouton, puis la couleur de ce texte. Le dernier argument va indiquer la fonction / méthode\ncommand=racine.destroy\nà exécuter lorsque l’utilisateur clique sur le bouton. On pourra noter que l’instance de la fenêtre mère (que nous\ntk.Tk\navons nommée ) possède une méthode qui va détruire le widget sur lequel elle s’applique. Comme\nracine .destroy()\non tue la fenêtre principale (que l’on peut considérer comme un widget contenant d’autres widgets), tous les widgets\nfils seront détruits et donc l’application s’arrêtera. Vous voyez par ailleurs que cette méthode est\nracine.destroy\npassée à l’argument sans parenthèses ni arguments : il s’agit donc d’une fonction callback comme expliqué\ncommand=\nci-dessus. Dans tous les widgets Tkinter, on doit passer à l’argument une fonction / méthode callback.\ncommand=...\n7\nLa liste exhaustive des arguments possibles de la classe se trouve ici .\ntk.Button\nLignes 6 et 7. Vous avez noté que lors de la création de ce label et de ce bouton, rien ne s’est passé dans la fenêtre.\nC’est normal, ces deux widgets existent bien, mais il faut maintenant les placer à l’intérieur de la fenêtre. On appelle pour\nça la méthode , avec une notation objet : à ce moment précis, vous verrez votre label apparaître\n.pack() widget.pack()\nainsi que la fenêtre qui se redimensionne automatiquement en s’adaptant à la grandeur de votre label. L’invocation de la\nmême méthode pour le bouton va faire apparaître celui-ci juste en dessous du label et redimensionner la fenêtre. Vous\nl’aurez compris la méthode place les widgets les uns en dessous des autres et ajuste la taille de la fenêtre. On\n.pack()\nverra plus bas que l’on peut passer des arguments à cette méthode pour placer les widgets différemment (en haut, à\ndroite, à gauche).\nAu final, vous devez obtenir une fenêtre comme sur la figure 25.3.\n25.4.2 Le même exemple dans un script.\nTentons maintenant de faire la même chose dans un script :\ntk_exemple.py\n1\nimport tkinter as tk\n2\n3\nracine = tk.Tk()\n4 label = tk.Label(racine, text=\"J'adore Python !\")\n5\nbouton = tk.Button(racine, text=\"Quitter\", command=racine.quit)\n6 bouton[\"fg\"] = \"red\"\n7\nlabel.pack()\n8 bouton.pack()\n9\nracine.mainloop()\n10 print(\"C'est fini !\")\npuis lançons ce script depuis un shell :\n$ python tk_exemple.py\nVous voyez maintenant la même fenêtre avec les mêmes fonctionnalités par rapport à la version dans l’interpréteur\n(voir la figure 25.3). Nous commentons ici les différences (dans le désordre) :\nLigne 6. Le bouton a été créé en ligne 5, mais on voit qu’il est possible de préciser une option de rendu du widget\naprès cette création (ici on met le texte en rouge avec l’option ). La notation ressemble à celle d’un dictionnaire\n\"fg\"\navec une syntaxe générale .\nwidget[\"option\"] = valeur\nLigne 9. L’instruction va lancer le gestionnaire d’événements que nous avons évoqué ci-dessus.\nracine.mainloop()\nC’est lui qui interceptera la moindre action de l’utilisateur, et qui lancera les portions de code associées à chacune de ses\nactions. Bien sûr, comme nous développerons dans ce qui va suivre toutes nos applications Tkinter dans des scripts (et\nnon pas dans l’interpréteur), cette ligne sera systématiquement présente. Elle sera souvent à la fin du script, puisque, à\nl’image de ce script, on écrit d’abord le code construisant l’interface, et on lance le gestionnaire d’événements une fois\nl’interface complètement décrite, ce qui lancera au final l’application.\n7. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/button.html\n304 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n25.5. Construire une application Tkinter avec une classe Chapitre 25. Fenêtres graphiques et Tkinter\nLigne 10. Cette ligne ne s’exécute qu’après l’arrêt de l’application (soit en cliquant sur le bouton « Quitter », soit en\ncliquant sur la croix).\nLigne 5. Pour quitter l’application, on utilise ici la méthode . Celle-ci casse la et arrête ainsi\n.quit() .mainloop()\nle gestionnaire d’événements. Cela mène à l’arrêt de l’application. Dans le premier exemple dans l’interpréteur, on avait\nutilisé la méthode sur la fenêtre principale. Comme son nom l’indique, celle-ci détruit la fenêtre principale\n.destroy()\net mène aussi à l’arrêt de l’application. Cette méthode aurait donc également fonctionné ici. Par contre, la méthode\nn’aurait pas fonctionné dans l’interpréteur car, comme on l’a vu, la boucle n’y est pas présente.\n.quit() .mainloop()\nComme nous écrirons systématiquement nos applications Tkinter dans des scripts, et que la boucle y est\n.mainloop()\nobligatoire, vous pourrez utiliser au choix ou pour quitter l’application.\n.quit() .destroy()\nFigure 25.3 – Exemple basique de fenêtre Tkinter."
  },
  {
    "title": "Construire une application Tkinter avec une classe",
    "content": "De manière générale, il est vivement conseillé de développer ses applications Tkinter en utilisant une classe. Cela\nprésente l’avantage d’encapsuler l’application de manière eﬀicace et d’éviter ainsi l’utilisation de variables globales.\nSouvenez-vous, elles sont à bannir définitivement ! Une classe crée un espace de noms propre à votre application, et\ntoutes les variables nécessaires seront ainsi des attributs de cette classe. Reprenons notre petit exemple avec un label et\nun bouton :\n1\nimport tkinter as tk\n2\n3\nclass Application(tk.Tk):\n4 def __init__(self):\n5 tk.Tk.__init__(self)\n6\nself.creer_widgets()\n7\n8\ndef creer_widgets(self):\n9 self.label = tk.Label(self, text=\"J'adore Python !\")\n10\nself.bouton = tk.Button(self, text=\"Quitter\", command=self.quit)\n11 self.label.pack()\n12\nself.bouton.pack()\n13\n14\n15 if __name__ == \"__main__\":\n16\napp = Application()\n17 app.title(\"Ma Première App :-)\")\n18 app.mainloop()\nLigne 3. On crée notre application en tant que classe. Notez que cette classe porte un nom qui commence par\n8\nune majuscule (comme recommandé dans les bonnes pratiques de la PEP8 , voir le chapitre 16 Bonnes pratiques en\nprogrammation Python). L’argument passé dans les parenthèses indique que notre classe hérite de la\nApplication\nclasse . Par ce mécanisme, nous héritons ainsi de toutes les méthodes et attributs de cette classe mère, mais nous\ntk.Tk\npouvons en outre en ajouter de nouvelles/nouveaux (on parle aussi de « redéfinition » de la classe ) !\ntk.Tk\nLigne 4. On crée un constructeur, c’est-à-dire une méthode qui sera exécutée lors de l’instanciation de notre classe\n(à la ligne 16).\nLigne 5. On appelle ici le constructeur de la classe mère . Pourquoi fait-on cela ? On se souvient\ntk.Tk.__init__()\ndans la version linéaire de l’application, on avait utilisé une instanciation classique : . Ici, l’effet de\nracine = tk.Tk()\nl’appel du constructeur de la classe mère permet d’instancier la fenêtre Tk dans la variable directement. C’est-à-dire\nself\nque la prochaine fois que l’on aura besoin de cette instance (lors de la création des widgets par exemple, cf. lignes 9 et\n8. https://www.python.org/dev/peps/pep-0008/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 305\nChapitre 25. Fenêtres graphiques et Tkinter 25.6. Le widget canvas\n10), on utilisera directement plutôt que ou tout autre nom donné à l’instance. Comme vu dans le chapitre\nself racine\n23 Avoir la classe avec les objets, appeler le constructeur de la classe mère est une pratique classique lorsqu’une classe\nhérite d’une autre classe.\nLigne 6. On appelle la méthode de notre classe . Pour rappel, le avant\nself.creer_widgets() Application self\nle indique qu’il s’agit d’une méthode de notre classe (et non pas d’une fonction classique).\n.creer_widgets()\nLigne 8. La méthode va créer des widgets dans l’application.\n.creer_widgets()\nLigne 9. On crée un label en instanciant la classe . Notez que le premier argument passé est maintenant\ntk.Label()\n(au lieu de précédemment) indiquant la fenêtre dans laquelle sera construit ce widget.\nself racine\nLigne 10. De même on crée un widget bouton en instanciant la classe . Là aussi, l’appel à la méthode\ntk.Button()\nse fait par puisque la fenêtre est instanciée dans la variable . Par ailleurs, on ne met ni\n.quit() self.quit self\nparenthèses ni arguments à car il s’agit d’une fonction callback (comme dans la rubrique précédente).\nself.quit\nLignes 11 et 12. On place les deux widgets dans la fenêtre avec la méthode .\n.pack()\nLigne 15. Ici on autorise le lancement de notre application Tkinter en ligne de commande (\npython tk_application.\n), ou bien de réutiliser notre classe en important en tant que module (\npy tk_application.py import tk_application\n) (voir le chapitre 15 Création de modules).\nLigne 16. On instancie notre application.\nLigne 17. On donne un titre dans la fenêtre de notre application. Comme on utilise de petits widgets avec la méthode\n, il se peut que le titre ne soit pas visible lors du lancement de l’application. Toutefois, si on « étire » la fenêtre\npack()\nà la souris, le titre le deviendra. On pourra noter que cette méthode est héritée de la classe mère Tk.\n.title()\nLigne 18. On lance le gestionnaire d’événements.\nAu final, vous obtiendrez le même rendu que précédemment (cf. figure 25.3). Alors vous pourrez-vous poser la\nquestion, « pourquoi ai-je besoin de toute cette structure alors que le code précédent semblait plus direct ? ». La réponse\nest simple, lorsqu’un projet de GUI grossit, le code devient très vite illisible s’il n’est pas organisé en classe. De plus,\nla non-utilisation de classe rend quasi-obligatoire l’utilisation de variables globales, ce qui on l’a vu, est à proscrire\ndéfinitivement ! Dans la suite du chapitre, nous verrons quelques exemples qui illustrent cela (cf. la rubrique suivante)."
  },
  {
    "title": "Le widget canvas",
    "content": "25.6.1 Un canvas simple et le système de coordonnées\n9\nLe widget canvas de Tkinter est très puissant. Il permet de dessiner des formes diverses (lignes, cercles, etc.), et\nmême de les animer !\nLa classe crée un widget canvas (ou encore canevas en français). Cela va créer une zone (i.e. le canevas\ntk.Canvas\nen tant que tel) dans laquelle nous allons dessiner divers objets tels que des ellipses, lignes, polygones, etc., ou encore\ninsérer du texte ou des images. Regardons tout d’abord un code minimal qui construit un widget canvas, dans lequel on\ny dessine un cercle et deux lignes :\n1 import tkinter as tk\n2\n3 racine = tk.Tk()\n4\ncanv = tk.Canvas(racine, bg=\"white\", height=200, width=200)\n5 canv.pack()\n6\ncanv.create_oval(0, 0, 200, 200, outline=\"red\", width=10)\n7 canv.create_line(0, 0, 200, 200, fill=\"black\", width=10)\n8\ncanv.create_line(0, 200, 200, 0, fill=\"black\", width=10)\n9 racine.mainloop()\nLigne 4. On voit qu’il faut d’abord créer le widget canvas, comme d’habitude en lui passant l’instance de la fenêtre\nprincipale en tant qu’argument positionnel, puis les options. Notons que nous lui passons comme options la hauteur et la\nlargeur du canvas. Même s’il s’agit d’arguments par mot-clé, donc optionnels, c’est une bonne pratique de les préciser.\nEn effet, les valeurs par défaut risqueraient de nous mener à dessiner hors de la zone visible (cela ne génère pas d’erreur\nmais n’a guère d’intérêt).\nLigne 6 à 8. Nous dessinons maintenant des objets graphiques à l’intérieur du canevas avec les méthodes\n.create_oval\n(dessine une ellipse) et (dessine une ligne). Les arguments positionnels sont les coordonnées de\n() .create_line()\n9. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas.html\n306 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n25.6. Le widget canvas Chapitre 25. Fenêtres graphiques et Tkinter\n10\nl’ellipse (les deux points englobant l’ellipse, cf. ce lien pour la définition exacte) ou de la ligne. Ensuite, on passe comme\nd’habitude des arguments par mot-clé (vous commencez à avoir l’habitude !) pour mettre en forme ces objets graphiques.\nLe rendu de l’image est montré dans la figure 25.4 ainsi que le système de coordonnées associé au canvas. Comme\ndans la plupart des bibliothèques graphiques, l’origine du repère du canvas (i.e. la coordonnée (0,0)) est en haut à gauche.\nLes x vont de gauche à droite, et les y vont de haut en bas.\nFigure 25.4 – Exemple 1 de canvas avec le système de coordonnées. Le système de coordonnées est montré en vert et\nn’apparaît pas sur la vraie fenêtre Tkinter.\nAttention\nL’axe des y est inversé par rapport à ce que l’on représente en mathématique. Si on souhaite représenter une fonction\nmathématique (ou tout autre objet dans un repère régi par un repère mathématique), il faudra faire un changement de\nrepère.\n25.6.2 Un canvas encapsulé dans une classe\nVoici un exemple un peu plus conséquent d’utilisation du widget canvas qui est inclus dans une classe. Il s’agit d’une\napplication dans laquelle il y a une zone de dessin, un bouton dessinant des cercles, un autre des lignes et un dernier\nbouton qui quitte l’application (figure 25.5).\nLe code suivant crée une telle application :\n10. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/create_oval.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 307\nChapitre 25. Fenêtres graphiques et Tkinter 25.6. Le widget canvas\nFigure 25.5 – Exemple 2 de canvas.\n1\nimport tkinter as tk\n2 import random as rd\n3\n4 class AppliCanevas(tk.Tk):\n5\ndef __init__(self):\n6 tk.Tk.__init__(self)\n7\nself.size = 500\n8 self.creer_widgets()\n9\n10 def creer_widgets(self):\n11\n# création canevas\n12 self.canv = tk.Canvas(self, bg=\"light gray\", height=self.size,\n13 width=self.size)\n14\nself.canv.pack(side=tk.LEFT)\n15 # boutons\n16\nself.bouton_cercles = tk.Button(self, text=\"Cercle !\",\n17 command=self.dessine_cercles)\n18\nself.bouton_cercles.pack(side=tk.TOP)\n19 self.bouton_lignes = tk.Button(self, text=\"Lignes !\",\n20\ncommand=self.dessine_lignes)\n21 self.bouton_lignes.pack()\n22\nself.bouton_quitter = tk.Button(self, text=\"Quitter\",\n23 command=self.quit)\n24\nself.bouton_quitter.pack(side=tk.BOTTOM)\n25\n26 def rd_col(self):\n27 return rd.choice((\"black\", \"red\", \"green\", \"blue\", \"yellow\", \"magenta\",\n28 \"cyan\", \"white\", \"purple\"))\n29\n30 def dessine_cercles(self):\n31\nfor i in range(20):\n32 x, y = [rd.randint(1, self.size) for j in range(2)]\n33\ndiameter = rd.randint(1, 50)\n34 self.canv.create_oval(x, y, x+diameter, y+diameter,\n35\nfill=self.rd_col())\n308 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n36\n37\ndef dessine_lignes(self):\n38 for i in range(20):\n39\nx, y, x2, y2 = [rd.randint(1, self.size) for j in range(4)]\n40 self.canv.create_line(x, y, x2, y2, fill=self.rd_col())\n41\n42\n43 if __name__ == \"__main__\":\n44\napp = AppliCanevas()\n45 app.title(\"Mon Canevas Psychédélique !\")\n46\napp.mainloop()\n25.6. Le widget canvas Chapitre 25. Fenêtres graphiques et Tkinter\nLignes 4 à 6. Comme montré dans la rubrique Construire une application Tkinter avec une classe, notre classe\nhérite de la classe générale et la fenêtre Tk se retrouve dans la variable .\nAppliCanevas tk.Tk self\nLigne 7. On crée un attribut de la classe qui contiendra la taille (hauteur et largeur) du canvas. On\nself.size\nrappelle que cet attribut sera visible dans l’ensemble de la classe puisqu’il est « accroché » à celle-ci par le .\nself\nLigne 8. On lance la méthode (qui est elle aussi « accrochée » à la classe par le ).\n.creer_widgets() self\nLignes 12 à 14. On crée un widget canvas en instanciant la classe . On place ensuite le canvas dans la\ntk.Canvas\nfenêtre avec la méthode en lui précisant où le placer avec la variable Tkinter .\n.pack() tk.LEFT\nLignes 15 à 24. On crée des widgets boutons et on les place dans la fenêtre. À noter que chacun de ces widgets appelle\nune méthode différente, dont deux que nous avons créées dans la classe ( et ).\n.dessine_cercle() .dessine_lignes()\nLigne 26 à 28. Cette méthode renvoie une couleur au hasard sous forme de chaîne de caractères.\nLignes 30 à 40. On définit deux méthodes qui vont dessiner des paquets de 20 cercles (cas spécial d’une ellipse) ou 20\nlignes aléatoires. Lors de la création de ces cercles et lignes, on ne les récupère pas dans une variable car on ne souhaite\nni les réutiliser ni changer leurs propriétés par la suite. Vous pourrez noter ici l’avantage de programmer avec une classe,\nle canvas est directement accessible dans n’importe quelle méthode de la classe avec (pas besoin de le passer\nself.canv\nen argument ou de créer une variable globale).\n25.6.3 Un canvas animé dans une classe\nDans ce dernier exemple, nous allons illustrer la puissance du widget canvas en vous montrant que l’on peut animer\nles objets se trouvant à l’intérieur. Nous allons également découvrir une technique intéressante, à savoir, comment «\nintercepter » des clics de souris générés ou des touches pressées par l’utilisateur. L’application consiste en une « baballe\n» qui se déplace dans la fenêtre et dont on contrôle les propriétés à la souris (cf. figure 25.6). Vous pouvez télécharger\n11\nle script ici .\n11. https://python.sdv.u-paris.fr/data-files/tk_baballe.py\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 309\nChapitre 25. Fenêtres graphiques et Tkinter 25.6. Le widget canvas\n1\n\"\"\"Super appli baballe !!!\n2\n3\nUsage: python tk_baballe.py\n4 - clic gauche: faire grossir la baballe\n5\n- clic droit: faire rétrécir la baballe\n6 - clic central: relance la baballe (depuis le point du clic)\n7 dans une direction aléatoire\n8\n- touche Esc: quitte l'appli baballe\n9 \"\"\"\n10\n11 import tkinter as tk\n12\nimport random as rd\n13\n14\nclass AppliBaballe(tk.Tk):\n15 def __init__(self):\n16\n\"\"\"Constructeur de l'application.\"\"\"\n17 tk.Tk.__init__(self)\n18\n# Coord baballe.\n19 self.x, self.y = 200, 200\n20 # Rayon baballe.\n21 self.size = 50\n22 # Pas de deplacement.\n23\nself.dx, self.dy = 20, 20\n24 # Création et packing du canvas.\n25\nself.canv = tk.Canvas(self, bg='light gray', height=400, width=400)\n26 self.canv.pack()\n27\n# Création de la baballe.\n28 self.baballe = self.canv.create_oval(self.x, self.y,\n29\nself.x+self.size,\n30 self.y+self.size,\n31\nwidth=2, fill=\"blue\")\n32 # Binding des actions.\n33\nself.canv.bind(\"<Button-1>\", self.incr)\n34 self.canv.bind(\"<Button-2>\", self.boom)\n35 self.canv.bind(\"<Button-3>\", self.decr)\n36\nself.bind(\"<Escape>\", self.stop)\n37 # Lancer la baballe.\n38\nself.move()\n39\n40\ndef move(self):\n41 \"\"\"Déplace la baballe (appelée itérativement avec la méthode after).\"\"\"\n42\n# Incrémente coord baballe.\n43 self.x += self.dx\n44\nself.y += self.dy\n45 # Vérifier que la baballe ne sort pas du canvas (choc élastique).\n46\nif self.x < 10:\n47 self.dx = abs(self.dx)\n48 if self.x > 400-self.size-10:\n49 self.dx = -abs(self.dx)\n50 if self.y < 10:\n51\nself.dy = abs(self.dy)\n52 if self.y > 400-self.size-10:\n53\nself.dy = -abs(self.dy)\n54 # Mise à jour des coord.\n55\nself.canv.coords(self.baballe, self.x, self.y, self.x+self.size,\n56 self.y+self.size)\n57\n# Rappel de move toutes les 50ms.\n58 self.after(50, self.move)\n59\n60 def boom(self, mclick):\n61\n\"\"\"Relance la baballe dans une direction aléatoire au point du clic.\"\"\"\n62 self.x = mclick.x\n63 self.y = mclick.y\n64\nself.canv.create_text(self.x, self.y, text=\"Boom !\", fill=\"red\")\n65 self.dx = rd.choice([-30, -20, -10, 10, 20, 30])\n66\nself.dy = rd.choice([-30, -20, -10, 10, 20, 30])\n67\n68\ndef incr(self, lclick):\n69 \"\"\"Augmente la taille de la baballe.\"\"\"\n70\nself.size += 10\n71 if self.size > 200:\n72\nself.size = 200\n73\n74\ndef decr(self, rclick):\n310 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n75 \"\"\"Diminue la taille de la baballe.\"\"\"\n76 self.size -= 10\n77 if self.size < 10:\n78 self.size = 10\n79\n80 def stop(self, esc):\n81\n\"\"\"Quitte l'application.\"\"\"\n82 self.quit()\n83\n84\n85\nif __name__ == \"__main__\":\n86 myapp = AppliBaballe()\n87\nmyapp.title(\"Baballe !\")\n88 myapp.mainloop()\n25.6. Le widget canvas Chapitre 25. Fenêtres graphiques et Tkinter\nLignes 19 à 23. Les coordonnées de la baballe, ses pas de déplacement, et sa taille sont créés en tant qu’attributs de\nnotre classe. Ainsi ils seront visibles partout dans la classe.\nLignes 25 à 31. Le canvas est ensuite créé et placé dans la fenêtre, puis on définit notre fameuse baballe. À noter,\nles coordonnées et de la baballe représentent en fait son côté « nord-ouest » (en haut à gauche, voir le\nself.x self.y\n12\npoint (x , y ) dans la documentation oﬀicielle ).\n0 0\nLignes 33 à 35. Jusqu’à maintenant, nous avons utilisé des événements provenant de clics sur des boutons. Ici, on va\n« intercepter » des événements générés par des clics de souris sur le canvas et les lier à une fonction / méthode (comme\nnous l’avions fait pour les clics sur des boutons avec l’option ). La méthode pour faire cela est ,\ncommand=... .bind()\nvoilà pourquoi on parle de event binding en anglais. Cette méthode prend en argument le type d’événement à capturer\nen tant que chaîne de caractères avec un format spécial : par exemple correspond à un clic gauche de la\n\"<Button-1>\"\nsouris (de même et correspondent aux clics central et droit respectivement). Le deuxième\n\"<Button-2>\" \"<Button-3>\"\nargument de la méthode est une méthode / fonction callback à appeler lors de la survenue de l’événement\n.bind()\n(comme pour les clics de bouton, vous vous souvenez ? On l’appelle donc sans parenthèses ni arguments). On notera\nque tous ces événements sont liés à des clics sur le canvas, mais il est possible de capturer des événements de souris sur\nd’autres types de widgets.\nLigne 36. De même, on peut « intercepter » un événement lié à l’appui sur une touche, ici la touche Esc.\nLigne 38. La méthode est appelée, ainsi l’animation démarrera dès l’exécution du constructeur, donc peu\n.move()\naprès l’instanciation de notre application (Ligne 86).\nLignes 40 à 58. On définit une méthode qui va gérer le déplacement de la baballe avec des chocs élastiques\n.move()\nsur les parois (et faire en sorte qu’elle ne sorte pas du canvas).\nLignes 55 et 56. On utilise la méthode de la classe , qui « met à jour » les coordonnées de\n.coords() Canvas\nn’importe quel objet dessiné dans le canvas (c’est-à-dire que cela déplace l’objet).\nLigne 58. Ici, on utilise une autre méthode spécifique des objets Tkinter. La méthode rappelle une autre\n.after()\nméthode ou fonction (second argument) après un certain laps de temps (ici 50 ms, passé en premier argument). Ainsi la\nméthode se rappelle elle-même, un peu comme une fonction récursive. Toutefois, ce n’est pas une vraie fonction\n.move()\nrécursive comme celle vue dans le chapitre 13 (exemple du calcul de factorielle), car Python ne conserve pas l’état de la\nfonction lors de l’appel de . C’est comme si on avait un , tout l’espace mémoire alloué à la méthode\n.after() return\nest détruit lorsque Python rencontre la méthode . On obtiendrait un résultat similaire avec la boucle\n.move() .after()\nsuivante :\n1\nimport time\n2\n3\n...\n4\n5\nwhile True:\n6 move()\n7\ntime.sleep(0.05) # attendre 50 ms\nLe temps de 50 ms donne 20 images (ou clichés) par seconde. Si vous diminuez ce temps, vous aurez plus d’images\npar secondes et donc un « film » plus fluide.\nLigne 60 à 66. On définit la méthode de notre classe qui on se souvient est appelée lors d’un événement clic\n.boom()\ncentral sur le canvas. Vous noterez qu’outre le , cette fonction prend un autre argument que nous avons nommé\nself\nici . Il s’agit d’un objet spécial géré par Tkinter qui va nous donner des informations sur l’événement généré par\nmclick\nl’utilisateur. Dans les lignes 62 et 63, cet objet récupère les coordonnées où le clic a eu lieu grâce aux attributs\nmclick\net . Ces coordonnées sont réaffectées à la baballe pour la faire repartir de l’endroit du clic. Nous\nmclick.x mclick.y\ncréons ensuite un petit texte dans le canevas et affectons des valeurs aléatoires aux variables de déplacement pour faire\nrepartir la baballe dans une direction aléatoire.\nLignes 68 à 78. On a ici deux méthodes et appelées lors d’un clic gauche ou droit. Deux choses\n.incr() .decr()\nsont à noter : i) l’attribut est modifié dans les deux fonctions, mais le changement de diamètre de la boule ne\nself.size\nsera effectif dans le canvas que lors de la prochaine exécution de l’instruction (dans la méthode\nself.canv.coords()\n) ; ii) de même que pour la méthode , ces deux méthodes prennent un argument après le (\n.move() .boom() self lclick\nou ) récupérant ainsi des informations sur l’événement de l’utilisateur. Même si on ne s’en sert pas, cet argument\nrclick\naprès le est obligatoire car il est imposé par la méthode .\nself .bind()\nLignes 80 à 82. Cette méthode quitte l’application lorsque l’utilisateur fait un clic sur la touche Esc.\n12. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/create_oval.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 311\nChapitre 25. Fenêtres graphiques et Tkinter 25.7. Pour aller plus loin\nFigure 25.6 – Exemple de canvas animé à deux instants de l’exécution (panneau de gauche : au moment où on effectue\nun clic central ; panneau de droite : après avoir effectué plusieurs clics gauches).\nIl existe de nombreux autres événements que l’on peut capturer et lier à des méthodes / fonctions callback. Vous\n13\ntrouverez une liste complète ici ."
  },
  {
    "title": "Pour aller plus loin",
    "content": "25.7.1 D’autres widgets\nJusqu’à maintenant nous avons vu les widgets Button, Canvas, Label, mais il en existe bien d’autres. En voici la liste\navec une brève explication pour chacun :\n•\nCheckbutton : aﬀiche des cases à cocher.\n•\nEntry : demande à l’utilisateur de saisir une valeur / une phrase.\n•\nListbox : aﬀiche une liste d’options à choisir (comme dans la figure 25.1).\n•\nRadiobutton : implémente des « boutons radio ».\n•\nMenubutton et Menu : aﬀiche des menus déroulants.\n•\nMessage : aﬀiche un message sur plusieurs lignes (extensions du widget Label).\n•\nScale : aﬀiche une règle graduée pour que l’utilisateur choisisse parmi une échelle de valeurs.\n•\nScrollbar : aﬀiche des ascenseurs (horizontaux et verticaux).\n•\nText : crée une zone de texte dans lequel l’utilisateur peut saisir un texte sur plusieurs lignes (comme dans la figure\n25.1).\n•\nSpinbox : sélectionne une valeur parmi une liste de valeurs.\n•\ntkMessageBox : aﬀiche une boîte avec un message.\nIl existe par ailleurs des widgets qui peuvent contenir d’autres widgets et qui organisent le placement de ces derniers :\n•\nFrame : widget conteneur pouvant contenir d’autres widgets classiques, particulièrement utile lorsqu’on réalise une\nGUI complexe avec de nombreuses zones.\n•\nLabelFrame : comme Frame mais aﬀiche aussi un label sur le bord.\n•\nToplevel : pour créer des fenêtres indépendantes.\n•\nPanedWindow : conteneur pour d’autres widgets, mais ici l’utilisateur peut réajuster les zones affectées à chaque\nwidget fils.\nVous trouverez la documentation exhaustive pour tous ces widgets (ainsi que ceux que nous avons décrits dans les\n14\nrubriques précédentes) sur le site de l’Institut des mines et de technologie du Nouveau Mexique (MNT). Par ailleurs, la\n13.\nhttp://effbot.org/tkinterbook/tkinter-events-and-bindings.htm\n14. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html\n312 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n25.7. Pour aller plus loin Chapitre 25. Fenêtres graphiques et Tkinter\n15\npage Universal widget methods vous donnera une vue d’ensemble des différentes méthodes associées à chaque widget.\nIl existe également une extension de Tkinter nommée ttk, réimplémentant la plupart des widgets de base de Tkinter\net qui en propose de nouveaux (Combobox, Notebook, Progressbar, Separator, Sizegrip et Treeview). Typiquement, si\nvous utilisez ttk, nous vous conseillons d’utiliser les widgets ttk en priorité, et pour ceux qui n’existent pas dans ttk, ceux\nde Tkinter (comme Canvas qui n’existe que dans Tkinter). Vous pouvez importer le sous-module ttk de cette manière :\n.\nimport tkinter.ttk as ttk\nVous pourrez alors utiliser les classes de widget de ttk (par exemple , etc.). Si vous souhaitez importer\nttk.Button\nttk et Tkinter, il suﬀit d’utiliser ces deux lignes :\n1 import tkinter as tk\n2\nimport tkinter.ttk as ttk\nAinsi vous pourrez utiliser des widgets de Tkinter et de ttk en même temps.\n16\nPour plus d’informations, vous pouvez consulter la documentation oﬀicielle de Python , ainsi que la documentation\n17\ntrès complète du site du MNT .\n25.7.2 Autres pistes à approfondir\nSi vous souhaitez aller un peu plus loin en Tkinter, voici quelques notions / remarques qui pourraient vous être utiles.\nConseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\n25.7.2.1 Les variables de contrôle\nLorsque vous souhaitez mettre un jour un widget avec une certaine valeur (par exemple le texte d’un label), vous ne\npouvez pas utiliser une variable Python ordinaire, il faudra utiliser une variable Tkinter dite de contrôle. Par exemple,\nsi on souhaitait aﬀicher les coordonnées de notre baballe (cf. rubrique précédente) dans un label, et que cet aﬀichage\nse mette à jour au fur et à mesure des mouvements de la baballe, il faudrait utiliser des variables de contrôle. On peut\ncréer de telles variables avec les classes pour les chaînes de caractères, pour les floats, et\ntk.StringVar tk.DoubleVar\npour les entiers. Une fois créée, par exemple avec l’instruction , on peut modifier\ntk.IntVar var = tk.StringVar()\nla valeur d’une variable de contrôle avec la méthode : ceci mettra à jour tous les widgets\nvar.set(nouvelle_valeur)\nutilisant cette variable . Il existe aussi la méthode qui récupère la valeur actuelle contenue dans .\nvar var.get() var\nEnfin, il faudra lors de la création du label utiliser l’option avec votre variable de contrôle (par exemple\ntextvariable=\n) pour que cela soit fonctionnel.\ntk.Label(..., textvariable=var, ...)\n18\nÀ nouveau, vous trouverez une documentation précise sur le site du MNT .\n25.7.2.2 Autres méthodes de placement des widgets dans la fenêtre Tk\nDans les exemples montrés dans ce chapitre, nous avons systématiquement utiliser la méthode pour placer\n.pack()\nles widgets. Cette méthode très simple et directe « empaquette » les widgets les uns contre les autres et redimensionne\nla fenêtre automatiquement. Avec l’option et les variables , , et on place\nside= tk.BOTTOM tk.LEFT tk.TOP tk.RIGHT\nfacilement les widgets les uns par rapport aux autres. Toutefois, la méthode peut parfois présenter des limites,\n.pack()\nil existe alors deux autres alternatives.\nLa méthode permet, grâce à l’utilisation d’une grille, un placement mieux contrôlé des différents widgets. La\n.grid()\nméthode place enfin les widgets en utilisant les coordonnées de la fenêtre principale. Nous ne développerons\n.place()\npas plus ces méthodes, mais voici de la documentation supplémentaire en accès libre :\n•\n19\n;\n.pack()\n15. https://infohost.nmt.edu/tcc/help/pubs/tkinter/web/universal.html\n16.\nhttps://docs.python.org/3/library/tkinter.ttk.html\n17. http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/ttk.html\n18.\nhttps://infohost.nmt.edu/tcc/help/pubs/tkinter/web/control-variables.html\n19. http://effbot.org/tkinterbook/pack.htm\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 313\nChapitre 25. Fenêtres graphiques et Tkinter 25.7. Pour aller plus loin\n• 20 21\n, ;\n.grid()\n•\n22\n.\n.place()\n25.7.2.3 Hériter de la classe Frame pour vos applications ?\nComme illustré dans nos exemples, nous vous recommandons pour vos classes applications Tkinter d’hériter de la classe\nmère et d’utiliser le constructeur de la classe mère . Toutefois, il se peut qu’en consultant\ntk.Tk tk.Tk.__init__()\nd’autres ressources certains auteurs utilisent la technique d’héritage de la classe mère :\ntk.Frame\n1 import tkinter as tk\n2\n3 class Application(tk.Frame):\n4\ndef __init__(self, racine=None):\n5 tk.Frame.__init__(self, racine)\n6\nself.racine = racine\n7 self.create_widgets()\n8\n9 def create_widgets(self):\n10\nself.label = tk.Label(self.racine, text=\"J'adore Python !\")\n11 self.bouton = tk.Button(self.racine, text=\"Quitter\",\n12\nfg=\"green\", command=self.quit)\n13 self.label.pack()\n14 self.bouton.pack()\n15\n16\n17\nif __name__ == \"__main__\":\n18 racine = tk.Tk()\n19\nracine.title(\"Ma Première App :-)\")\n20 app = Application(racine)\n21\nracine.mainloop()\nLignes 17 à 21. Commentons d’abord le programme principal : ici on crée la fenêtre principale dans l’instance\nracine\npuis on instancie notre classe en passant en argument.\nracine\nLignes 4 et 5. Ici réside la principale différence par rapport à ce que nous vous avons montré dans ce chapitre : en\nligne 4 on passe l’argument à notre constructeur, puis en ligne 5 on passe ce même argument lors de\nracine racine\nl’appel du constructeur de la classe (ce qui était inutile lorsqu’on héritait de la classe ).\ntk.Frame Tk\nLigne 6. L’argument passé à la méthode est finalement une variable locale. Comme il s’agit\nracine .__init__()\nde l’instance de notre fenêtre principale à passer à tous nos widgets, il faut qu’elle soit visible dans toute la classe. La\nvariable est ainsi créée afin d’être réutilisée dans d’autres méthodes.\nself.racine\nVous pourrez vous posez la question : « Pourquoi en ligne 4 l’argument par mot-clé prend la valeur\nracine=None\npar défaut ? ». Et bien, c’est parce que notre classe Application peut s’appeler sans passer d’instance de fenêtre\nNone\nTk. Voici un exemple avec les lignes qui changent seulement (tout le reste est identique au code précédent) :\n1 [...]\n2 class Application(tk.Frame):\n3\ndef __init__(self, racine=None):\n4 tk.Frame.__init__(self)\n5\nself.racine = racine\n6 [...]\n7\n[...]\n8 if __name__ == \"__main__\":\n9\napp = Application()\n10 app.mainloop()\nDans un tel cas, l’argument prend la valeur par défaut lorsque la méthode de notre\nracine None .__init__()\nclasse est exécutée. L’appel au constructeur de la classe Frame en ligne 4 instancie automatiquement une fenêtre Tk (car\ncela est strictement obligatoire). Dans la suite du programme, cette instance de la fenêtre principale sera\nself.racine\net il n’y aura pas de changement par rapport à la version précédente. Cette méthode reste toutefois peu intuitive car\ncette instance de la fenêtre principale vaut finalement !\nself.racine None\n20. http://effbot.org/tkinterbook/grid.htm\n21.\nhttps://infohost.nmt.edu/tcc/help/pubs/tkinter/web/grid.html\n22. http://effbot.org/tkinterbook/place.htm\n314 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n25.7. Pour aller plus loin Chapitre 25. Fenêtres graphiques et Tkinter\nHériter de la classe Frame ou de la classe Tk sont deux manières tout à fait valides pour créer des applications\nTkinter. Le choix de l’une ou de l’autre relève plus de préférences que l’on acquiert en pratiquant, voire de convictions\nphilosophiques sur la manière de programmer. Toutefois, nous pensons qu’hériter de la classe est une manière\ntk.Tk\nplus générale et plus compacte : tout ce qui concerne le fenêtrage Tkinter se situera dans votre classe Application, et le\nprogramme principal n’aura qu’à instancier l’application et à lancer le gestionnaire d’événements (les choses seront ainsi\nmieux « partitionnées »). C’est donc la méthode que nous vous recommandons.\n25.7.2.4 Passage d’arguments avec et\n*args **kwargs\nSi vous allez chercher de la documentation supplémentaire sur Tkinter, il se peut que vous tombiez sur ce style de\nsyntaxe lorsque vous créez votre classe contenant l’application graphique :\n1\nclass MonApplication(tk.Tk):\n2 def __init__(self, *args, **kwargs):\n3\ntk.Tk.__init__(self, *args, **kwargs)\n4 # ici débute la construction de votre appli\n5\n[...]\n6\n7 # programme principal\n8\nif __name__ == \"__main__\":\n9 [...]\n10\napp = MonApplication()\n11 [...]\nLes arguments et récupérent facilement tous les arguments « positionnels » et « par mot-clé ». Pour\n*args **kwargs\nplus de détails sur comment et fonctionnent, reportez-vous au chapitre 26 Remarques complémentaires\n*args **kwargs\n(en ligne).\nDans l’exemple ci-dessus, et sont inutiles car lors de l’instanciation de notre application, on ne passe\n*args **kwargs\naucun argument : . Toutefois, on pourrait être intéressé à récupérer des arguments passés\napp = MonApplication()\nau constructeur, par exemple :\napp = MonApplication(arg1, arg2, option1=val1, option2=val2)\nAinsi certains auteurs laissent toujours ces et au cas où on en ait besoin dans le futur. Cela est\n*args **kwargs\nbien utile lorsqu’on distribue notre classe à la communauté et que l’on souhaite que les futurs utilisateurs puissent passer\ndes arguments Tkinter au constructeur de notre classe.\nToutefois, même si cela « ne coûte rien », nous vous recommandons de ne pas mettre ces et si vous\n*args **kwargs\nn’en avez pas besoin, comme nous vous l’avons montré dans les exemples de ce chapitre. Rappelons nous de la PEP 20\n(voir le chapitre 16 Bonnes Pratiques en programmation Python), les assertions « Simple is better than complex » ou «\nSparse is better than dense » nous suggèrent qu’il est inutile d’ajouter des choses dont on ne se sert pas.\n25.7.2.5 Toujours préciser l’instance de la fenêtre principale\nTkinter est parfois surprenant. Dans le code suivant, on pourrait penser que celui-ci n’est pas fonctionnel :\n1 >>> import tkinter as tk\n2\n>>> bouton = tk.Button(text=\"Quitter\")\n3 >>> bouton.pack()\nPour autant, cela fonctionne et on voit un bouton apparaître ! En fait, Tkinter va automatiquement instancier la\nfenêtre principale, si bien qu’il n’est pas obligatoire de passer cette instance en argument d’un widget. À ce moment, on\npeut se demander où est passé cette instance. Heureusement, Tkinter garde toujours une filiation des widgets avec les\nattributs et :\n.master .children\n1 >>> racine = bouton.master\n2\n>>> racine\n3 <tkinter.Tk object .>\n4\n>>> racine.children\n5 {'!button': <tkinter.Button object .!button>}\n6\n>>> bouton[\"command\"] = racine.destroy\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 315\nChapitre 25. Fenêtres graphiques et Tkinter 25.7. Pour aller plus loin\nLigne 1. On « récupère » l’instance de la fenêtre principale dans la variable racine.\nLes lignes 4 et 5 montrent que le bouton est un « enfant » de cette dernière.\nEnfin, ligne 6, on réassigne la destruction de la fenêtre lorsqu’on clique sur le bouton.\nCes attributs et existent pour tous widgets et sont bien pratiques lorsqu’on crée de grosses\n.master .children\napplications graphiques (où on utilise souvent des widgets parents contenant d’autres widgets enfants). Une autre source\nd’information sur les widgets se trouvent dans les méthodes dont le nom commence par . Par exemple, la méthode\nwinfo\nrenvoie la même information que l’attribut (une référence vers le widget parent).\n.winfo_toplevel() .master\nConseil\nMême si cela est possible, nous vous conseillons de systématiquement préciser l’instance de la fenêtre principale lors\nde la création de vos widgets.\n25.7.2.6 Passage d’arguments à vos fonctions callback\nComme vu dans nos exemples ci-dessus, les fonctions callback ne prennent pas d’arguments ce qui peut se révéler\nparfois limitant. Il existe toutefois une astuce qui utilise les fonctions lambda ; nous expliquons brièvement les fonctions\nlambda dans le chapitre 26 Remarques complémentaires (en ligne). Toutefois, nous ne développons pas leur utilisation\navec Tkinter et les fonctions callback car cela dépasse le cadre de cet ouvrage. Pour de plus amples explications sur cette\n23 24\nquestion, vous pouvez consulter le site pythonprogramming et le livre de Gérard Swinnen .\n25.7.2.7 Application Tkinter avec plusieurs pages\nDans ce chapitre d’introduction, nous vous avons montré des GUI simples avec une seule page. Toutefois, si votre\n25\nprojet se complexifie, il se peut que vous ayez besoin de créer plusieurs fenêtre différentes. Le livre de Gérard Swinnen\n26\net le site pythonprogramming sont des bonnes sources pour commencer et voir concrètement comment faire cela.\n25.7.3 Bibliographie pour aller plus loin\nVoici quelques ressources que vous pouvez utiliser pour continuer votre apprentissage de Tkinter :\n1. En anglais :\n• 27\nLa Documentation oﬀicielle de Python.\n• 28\nLe manuel de référence sur le site du MNT.\n•\n29\nLe site de Fredrik Lundh est également très complet.\n• 30\nPour avoir un exemple rapide de code pour chaque widget.\n•\n31\nLe livre de David Love Learn Tkinter By Example qui montre des exemples concrets d’applications Tkinter de\nplus en plus complexes (pdf en libre téléchargement).\n•\n32\nLe site très bien fait de Harisson (avec vidéos !) vous guidera dans la construction d’une GUI complète et complexe\navec de nombreuses fonctions avancées (comme par exemple mettre des graphes matplotlib qui se mettent à jour\ndans la GUI !).\n2. En français :\n• 33\nLe site bien complet d’Étienne Florent.\n•\n34\nLe livre de Gérard Swinnen qui montre de nombreux exemples d’applications tkinter (pdf en libre téléchargement).\n23. https://pythonprogramming.net/passing-functions-parameters-tkinter-using-lambda/\n24.\nhttps://inforef.be/swi/python.htm\n25. https://inforef.be/swi/python.htm\n26. https://pythonprogramming.net/change-show-new-frame-tkinter/\n27.\nhttps://wiki.python.org/moin/TkInter\n28. https://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html\n29.\nhttp://effbot.org/tkinterbook/\n30. https://www.tutorialspoint.com/python/python_gui_programming.htm\n31.\nhttps://github.com/Dvlv/Tkinter-By-Example\n32. https://pythonprogramming.net/tkinter-depth-tutorial-making-actual-program/\n33.\nhttp://tkinter.fdex.eu/index.html\n34. https://inforef.be/swi/python.htm\n316 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n25.8. Exercices Chapitre 25. Fenêtres graphiques et Tkinter"
  },
  {
    "title": "Exercices",
    "content": "Conseil\nPour ces exercices, créez des scripts puis exécutez-les dans un shell. Nous vous recommandons de concevoir une classe\npour chaque exercice.\n25.8.1 Application de base\nConcevez une application qui aﬀiche l’heure dans un label (par exemple ) et qui possède un boutton quitter.\n09:10:55\nL’heure aﬀichée sera celle au moment du lancement de l’application. Pour « attraper » l’heure, vous pourrez utiliser la\nfonction du module .\nstrftime() time\n25.8.2 Horloge\nSur la base de l’application précédente, faites une application qui aﬀiche l’heure dans un label en se mettant à jour\nsur l’heure de l’ordinateur une fois par seconde. Vous concevrez une méthode qui met à jour\n.mise_a_jour_heure()\nl’heure dans le label et qui se rappelle elle-même toutes les secondes (n’oubliez pas la méthode , cf. rubrique\n.after()\nUn canvas animé dans une classe ci-dessus). Pour cette mise à jour, vous pourrez utiliser la méthode , par\n.configure()\nexemple : où est une chaîne de caractères représentant l’heure actuelle.\nself.label.configure(text=heure) heure\n25.8.3 Compte à rebours\nCréer une application aﬀichant un compte à rebours dans un label. L’utilisateur choisira entre 1 et 240 minutes\nen passant un argument au lancement du script, par exemple : signifiera un\npython tk_compte_a_rebours.py 34\ncompte à rebours de 34’ (le programme vérifiera qu’il s’agit d’un entier entre 1 et 240 inclus). Il y aura un bouton «\nLancer » pour démarrer le compte à rebours et un boutton « Quitter » au cas où on veuille quitter avant la fin. À la fin\ndu rebours, le programme aﬀichera 10 fois la phrase « C’est fini !!! » dans le shell et quittera automatiquement le script.\nUne image du résultat attendu est montrée dans la figure 25.7.\nFigure 25.7 – Compte à rebours.\n25.8.4 Triangle de Sierpinski\n35\nLe triangle de Sierpinski est une fractale classique. On se propose ici de la dessiner avec un algorithme tiré du jeu\n36\ndu chaos . Celui-ci se décompose en pseudo-code de la façon suivante :\n35.\nhttps://fr.wikipedia.org/wiki/Triangle_de_Sierpi%C5%84ski\n36. https://fr.wikipedia.org/wiki/Jeu_du_chaos\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 317\nChapitre 25. Fenêtres graphiques et Tkinter 25.8. Exercices\ndéfinir les 3 sommets d'un triangle isocèle ou équilatéral\npoint <- coordonnées (x, y) du centre du trianle\ndessiner(point) # un pixel de large\npour i de 0 à 25000:\nsommet_tmp <- choisir un sommet du triangle au hasard\npoint <- calculer(coordonnées(x, y) du centre entre point et sommet_tmp)\ndessiner(point)\nLe rendu final attendu est montré dans la figure 25.8. On utilisera un canevas de 400x400 pixels. Il y a aura un\nbouton « Quitter » et un bouton « Launch ! » qui calculera et aﬀichera 10000 points supplémentaires dans le triangle de\nSierpinski.\nFigure 25.8 – Triangle de Sierpinski.\n25.8.5 Polygone de Sierpinski (exercice +++)\nAméliorer l’application précédente en proposant une liste de choix supplémentaire demandant à l’utilisateur de choisir\nle nombre de sommets (de 3 à 10). Le programme calculera automatiquement la position des sommets. Pour prendre en\nmain le widget Listbox, voici un code minimal qui pourra vous aider. Celui-ci contient une et permet d’aﬀicher\nListbox\ndans le terminal l’élément sélectionné. Nous vous conseillons de bien étudier le code ci-dessous et d’avoir résolu l’exercice\nprécédent avant de vous lancer !\n318 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n25.8. Exercices Chapitre 25. Fenêtres graphiques et Tkinter\n1\nimport tkinter as tk\n2\n3\nclass MaListBox(tk.Tk):\n4 def __init__(self):\n5\n# Instanciation fenêtre Tk.\n6 tk.Tk.__init__(self)\n7 self.listbox = tk.Listbox(self, height=10, width=4)\n8\nself.listbox.pack()\n9 # Ajout des items à la listbox (entiers).\n10\nfor i in range(1, 10+1):\n11 # Utilisation de ma méthode .insert(index, element)\n12\n# Ajout de l'entier i (tk.END signifie en dernier).\n13 self.listbox.insert(tk.END, i)\n14\n# Selection du premier élément de listbox.\n15 self.listbox.select_set(0)\n16\n# Liaison d'une méthode quand clic sur listbox.\n17 self.listbox.bind(\"<<ListboxSelect>>\", self.clic_listbox)\n18\n19 def clic_listbox(self, event):\n20 # Récupération du widget à partir de l'objet event.\n21 widget = event.widget\n22 # Récupération du choix sélectionné dans la listbox (tuple).\n23\n# Par exemple renvoie `(5,)` si on a cliqué sur `5`.\n24 selection = widget.curselection()\n25\n# Récupération du nombre sélectionné (déjà un entier).\n26 choix_select = widget.get(selection[0])\n27\n# Affichage.\n28 print(f\"Le choix sélectionné est {choix_select}, \"\n29\nf\"son type est {type(choix_select)}\")\n30\n31\n32\n33\nif __name__ == \"__main__\":\n34 app = MaListBox()\n35 app.title(\"MaListBox\")\n36\napp.mainloop()\n25.8.6 Projet simulation d’un pendule\nVous souhaitez aller plus loin après ces exercices de « mise en jambe » ? Nous vous conseillons d’aller directement au\nchapitre 27 Mini projets (en ligne). Nous vous proposons de réaliser une application Tkinter qui simule le mouvement d’un\npendule. En réalisant une application complète de ce genre, un peu plus conséquente, vous serez capable de construire\nvos propres applications.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 319"
  },
  {
    "title": "Remarques complémentaires",
    "content": "Dans ce chapitre, nous présentons un certain nombre de points en vrac qui ne rentraient pas forcément dans les\nautres chapitres ou qui étaient trop avancés au moment où les chapitres étaient abordés. Outre quelques points mineurs,\nnous abordons les grandes différences entre Python 2 et Python 3, les anciennes méthodes de formatage des chaînes\nde caractères, les fonctions lambda, les itérateurs, la gestion des exceptions, les passage d’arguments avancés dans les\nfonctions et les décorateurs. Certains de ces points sont réellement avancés et nécessiteront d’avoir assimilé d’autres\nnotions avant de les aborder."
  },
  {
    "title": "Différences Python 2 et Python 3",
    "content": "Python 3 est la version de Python qu’il faut utiliser.\nNéanmoins, Python 2 a été employé pendant de nombreuses années par la communauté scientifique et vous serez\ncertainement confrontés à un programme écrit en Python 2. Voici quelques éléments pour vous en sortir :\n26.1.1 Le mot-clé / la fonction\nprint print()\nEn Python 2 est un mot-clé du langage (en anglais statement) au même titre que , , , etc. Il s’utilise\nprint for if def\nainsi sans parenthèse. Par exemple :\n1\n>>> print 12\n2 12\n3\n>>> print \"girafe\"\n4 girafe\nPar contre, en Python 3, est une fonction. Ainsi, si vous n’utilisez pas de parenthèse, Python vous renverra\nprint()\nune erreur :\n1 >>> print 12\n2\nFile \"<stdin>\", line 1\n3 print 12\n4\n^\n5 SyntaxError: Missing parentheses in call to 'print'\n26.1.2 Division d’entiers\nEn Python 3, la division de deux entiers, se fait naturellement, c’est-à-dire que l’opérateur renvoie systématiquement\n/\nun float. Par exemple :\n320\n26.1. Différences Python 2 et Python 3 Chapitre 26. Remarques complémentaires\n1\n>>> 3 / 4\n2 0.75\nIl est également possible de réaliser une division entière avec l’opérateur :\n//\n>>> 3 // 4\n0\nLa division entière renvoie finalement la partie entière du nombre , c’est-à-dire .\n0.75 0\nAttention ! En Python 2, la division de deux entiers avec l’opérateur correspond à la division entière, c’est-à-dire le\n/\nrésultat arrondi à l’entier inférieur. Par exemple :\n1 >>> 3 / 5\n2\n0\n3 >>> 4 / 3\n4\n1\nFaites très attention à cet aspect si vous programmez encore en Python 2, c’est une source d’erreur récurrente.\n26.1.3 La fonction\nrange()\nEn Python 3, la fonction renvoie un objet de type range (voir les chapitres 5 Boucles et comparaisons et\nrange()\n14 Conteneurs) :\n1\n>>> range(3)\n2 range(0, 3)\nComme on a vu au chapitre 5 Boucles et comparaisons, ces objets sont itérables produisant successivement les nombres\n, puis puis sur notre exemple :\n0 1 2\n1 >>> for i in range(3):\n2\n... print(i)\n3 ...\n4\n0\n5 1\n6\n2\nEn Python 2, la fonction renvoie une liste. Par exemple :\nrange()\n1 >>> range(3)\n2 [0, 1, 2]\n3 >>> range(2, 6)\n4\n[2, 3, 4, 5]\nLa création de liste avec était pratique, mais très peu eﬀicace en mémoire lorsque l’argument donné à\nrange()\nétait un grand nombre.\nrange()\nD’ailleurs la fonction est disponible en Python 2 pour faire la même chose que la fonction en\nxrange() range()\nPython 3. Attention, ne vous mélangez pas les pinceaux !\n1\n>>> range(3)\n2 [0, 1, 2]\n3\n>>> xrange(3)\n4 xrange(3)\nRemarque\nPour générer une liste d’entiers avec la fonction en Python 3, vous avez vu dans le chapitre 4 Listes qu’il\nrange()\nsuﬀisait de l’associer avec la fonction . Par exemple :\nlist()\n1\n>>> list(range(10))\n2 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 321\nChapitre 26. Remarques complémentaires 26.2. Anciennes méthodes de formatage des chaînes de caractères\nConseil\nPour une comparaison exhaustive entre en Python 2 et en Python 3, vous pouvez lire ce très\nxrange() range()\n1\nbon article tiré du blog de Trey Hunner.\n26.1.4 Fonction\nzip()\nEn Python 2, la fonction renvoie une liste de tuples, alors qu’en Python 3 elle renvoie un itérateur :\nzip()\n1 >>> # Python2.\n2\n>>> zip(range(4), range(10, 14))\n3 [(0, 10), (1, 11), (2, 12), (3, 13)]\n1\n>>> # Python3.\n2 >>> zip(range(4), range(10, 14))\n3 <zip object at 0x7f11423ffd80>\nVous pouvez lire la rubrique Itérables, itérateurs, générateurs et module itertools un peu plus bas dans ce chapitre\npour en savoir plus sur les itérateurs.\n26.1.5 Encodage et utf-8\nEn Python 3, vous pouvez utiliser des caractères accentués dans les commentaires ou dans les chaînes de caractères.\nCe n’est pas le cas en Python 2. Si un caractère accentué est présent dans votre code, cela occasionnera une erreur\nde ce type lors de l’exécution de votre script :\nSyntaxError: Non-ASCII character '\\xc2' in file xxx on line yyy, but no encoding\ndeclared; see http://python.org/dev/peps/pep-0263/ for details\nPour éviter ce genre de désagrément, ajoutez la ligne suivante en tout début de votre script :\n1\n# coding: utf-8\nSi vous utilisez un shebang (voir rubrique précédente), il faudra mettre la ligne sur la deuxième\n# coding: utf-8\n2\nligne (la position est importante ) de votre script :\n1\n#! /usr/bin/env python\n2 # coding: utf-8\nRemarque\nL’encodage utf-8 peut aussi être déclaré de cette manière :\n1 # -*- coding: utf-8 -*-\nmais c’est un peu plus long à écrire."
  },
  {
    "title": "Anciennes méthodes de formatage des chaînes de caractères",
    "content": "Dans les premières versions de Python jusqu’à la 2.6, il fallait utiliser l’opérateur , puis de la version 2.7 jusqu’à la 3.5\n%\nil était plutôt conseillé d’utiliser la méthode . Même si les f-strings sont devenues la manière conseillée pour\n.format()\nmettre en place l’écriture formatée, ces deux anciennes manières, sont encore pleinement compatibles avec les versions\nmodernes de Python.\nMême si elle fonctionne encore, la première manière avec l’opérateur est maintenant clairement déconseillée pour un\n%\n3\ncertain nombre de raisons . Néanmoins, nous rappelons ci-dessous son fonctionnement, car il se peut que vous tombiez\ndessus dans d’anciens livres ou si vous lisez de vieux programmes Python.\n1. https://treyhunner.com/2018/02/python-3-s-range-better-than-python-2-s-xrange/\n2.\nhttp://www.python.org/dev/peps/pep-0263/\n3. https://docs.python.org/fr/3/library/stdtypes.html?highlight=sprintf#printf-style-string-formatting\n322 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.2. Anciennes méthodes de formatage des chaînes de caractères Chapitre 26. Remarques complémentaires\nLa deuxième manière avec la méthode est encore utilisée et reste tout à fait valide. Elle est clairement\n.format()\nplus puissante et évite un certain nombre de désagréments par rapport à l’opérateur . Vous la croiserez sans doute\n%\nde temps en temps dans des programmes et ouvrages plus ou moins récents. Heureusement elle a un fonctionnement\nrelativement proche des f-strings, donc vous ne serez pas totalement perdus !\nEnfin, nous indiquons à la fin de cette rubrique nos conseils sur quelle méthode utiliser.\n26.2.1 L’opérateur\n%\nOn a vu avec les entiers que l’opérateur ou modulo renvoyait le reste d’une division entière. Cet opérateur existe\n%\naussi pour les chaînes de caractères mais il met en place l’écriture formatée. En voici un exemple :\n1\n>>> x = 32\n2 >>> nom = \"John\"\n3 >>> print(\"%s a %d ans\" % (nom, x))\n4\nJohn a 32 ans\n5 >>> nb_G = 4500\n6\n>>> nb_C = 2575\n7 >>> prop_GC = (nb_G + nb_C)/14800\n8\n>>> print(\"On a %d G et %d C -> prop GC = %.2f\" % (nb_G, nb_C, prop_GC))\n9 On a 4500 G et 2575 C -> prop GC = 0.48\nLa syntaxe est légèrement différente. Le symbole est d’abord appelé dans la chaîne de caractères (dans l’exemple\n%\nci-dessus , et ) pour :\n%d %d %.2f\n•\nDésigner l’endroit où sera placée la variable dans la chaîne de caractères.\n•\nPréciser le type de variable à formater, pour un entier ( fonctionne également) ou pour un float.\nd i f\n•\nÉventuellement pour indiquer le format voulu. Ici signifie une précision de deux décimales.\n.2\nLe signe est rappelé une seconde fois ( ) pour indiquer les variables à formater.\n% % (nb_G, nb_C, prop_GC)\n26.2.2 La méthode .format()\nDepuis la version 2.7 de Python, la méthode a apporté une nette amélioration pour mettre en place\n.format()\nl’écriture formatée. Celle-ci fonctionne de la manière suivante :\n1\n>>> x = 32\n2 >>> nom = \"John\"\n3\n>>> print(\"{} a {} ans\".format(nom, x))\n4 John a 32 ans\n5\n>>> nb_G = 4500\n6 >>> nb_C = 2575\n7\n>>> prop_GC = (nb_G + nb_C)/14800\n8 >>> print(\"On a {} G et {} C -> prop GC = {:.2f}\".format(nb_G, nb_C, prop_GC))\n9\nOn a 4500 G et 2575 C -> prop GC = 0.48\n•\nDans la chaîne de caractères, les accolades vides précisent l’endroit où le contenu de la variable doit être inséré.\n{}\n•\nJuste après la chaîne de caractères, l’instruction fournit la liste des variables à insérer, d’abord\n.format(nom, x)\nla variable puis la variable .\nnom x\n•\nOn peut éventuellement préciser le formatage en mettant un caractère deux-points puis par exemple ici qui\n: .2f\nsignifie deux chiffres après la virgule.\n•\nLa méthode agit sur la chaîne de caractères à laquelle elle est attachée par le point.\n.format()\nTout ce que nous avons vu avec les f-strings sur la manière de formater l’aﬀichage d’une variable (après les\n:\nau sein des accolades) est identique avec la méthode . Par exemple , , , etc.,\n.format() {:.2f} {:0>6d} {:.6e}\nfonctionneront de la même manière. La différence notable est qu’on ne met pas directement le nom de la variable au\nsein des accolades. Comme pour l’opérateur , c’est l’emplacement dans les arguments passés à la méthode\n% .format()\nqui dicte quelle variable doit être remplacée. Par exemple, dans , les\n\"{} {} {}\".format(bidule, machin, truc)\npremières accolades remplaceront la variable , les deuxièmes la variable , les troisièmes la variable .\nbidule machin truc\nLe formatage avec la méthode se rapproche de la syntaxe des f-strings (accolades, deux-points), mais\n.format()\nprésente l’inconvénient – comme avec l’opérateur – de devoir mettre la liste des variables tout à la fin, alourdissant\n%\nainsi la syntaxe. En effet, dans l’exemple avec la proportion de GC, la ligne équivalente avec une f-string apparait tout\nde même plus simple à lire :\n1 >>> print(f\"On a {nb_G} G et {nb_C} C -> prop GC = {prop_GC:.2f}\")\n2\nOn a 4500 G et 2575 C -> prop GC = 0.48\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 323\nChapitre 26. Remarques complémentaires 26.3. Fonctions lambda\nConseil\nPour conclure, ces deux anciennes façons de formater une chaîne de caractères avec l’opérateur ou la méthode\n%\nvous sont présentées à titre d’information. La première avec l’opérateur est clairement déconseillée. La\n.format() %\ndeuxième avec la méthode est encore tout à fait valable. Si vous débutez Python, nous vous conseillons\n.format()\nfortement d’apprendre et d’utiliser les f-strings. C’est ce que vous rencontrerez dans la suite de ce cours. Si vous connaissez\ndéjà Python et que vous utilisez la méthode , nous vous conseillons de passer aux f-strings. Depuis que nous\n.format()\nles avons découvertes, aucun retour n’est envisageable pour nous tant elles sont puissantes et plus claires à utiliser !\nPour aller plus loin\nEnfin, si vous souhaitez aller plus loin, voici deux articles (en anglais) très bien faits sur le site RealPython : sur\n4 5\nl’écriture formatée et sur les f-strings"
  },
  {
    "title": "Fonctions lambda",
    "content": "26.3.1 Définition\nDéfinition\nUne fonction lambda est une fonction qui s’écrit sur une ligne. En Python, il s’agit du moyen d’implémenter une\n6\nfonction anonyme (en anglais anonymous function), c’est-à-dire, une fonction qui est la plupart du temps non reliée\nà un nom (d’où le terme anonyme). Une fonction lambda s’utilise en général à la volée. On parle aussi d’expressions\nlambda utilisées pour fabriquer des fonctions lambda.\nVoici un premier exemple :\n1\n>>> lambda x: x**2\n2 <function <lambda> at 0x7fcbd9c58b80>\n3\n>>> (lambda x: x**2)(4)\n4 16\n5 >>> (lambda x: x**2)(10)\n6\n100\n•\nLigne 1. On a ici une expression lambda typique définissant une fonction lambda. La syntaxe est (dans l’ordre) :\nle mot-clé (statement) lambda, zero ou un ou plusieurs argument(s), deux-points, une expression utilisant ou pas\nles arguments.\n•\nLigne 2. Python confirme qu’il s’agit d’une fonction.\n•\nLignes 3 à 6. Pour utiliser la fonction lambda, pour l’instant, on la met entre parenthèses et on utilise un autre\njeu de parenthèses pour l’appeler et éventuellement passer des arguments.\nAttention\nUne fonction lambda ne s’écrit que sur une ligne. Si vous essayez de l’écrire sur plusieurs lignes, Python lèvera une\nexception .\nSyntaxError: invalid syntax\nComme pour les fonctions classiques, le nombre d’arguments est variable et doit être cohérent avec l’appel :\n4. https://realpython.com/python-string-formatting\n5.\nhttps://realpython.com/python-f-strings/\n6. https://en.m.wikipedia.org/wiki/Anonymous_function\n324 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.3. Fonctions lambda Chapitre 26. Remarques complémentaires\n1\n>>> (lambda: 1/2)()\n2 0.5\n3\n>>> (lambda x, y: x + y)(1, 2)\n4 3\n5\n>>> (lambda x, y: x + y)(4, 5)\n6 9\n7 >>> (lambda: 1/2)(5)\n8\nTraceback (most recent call last):\n9 File \"<stdin>\", line 1, in <module>\n10\nTypeError: <lambda>() takes 0 positional arguments but 1 was given\n11 >>> (lambda x, y: x + y)(4)\n12\nTraceback (most recent call last):\n13 File \"<stdin>\", line 1, in <module>\n14\nTypeError: <lambda>() missing 1 required positional argument: 'y'\n•\nLigne 1. Fonction lambda à zéro argument.\n•\nLignes 3 et 5. Fonction lambda à deux arguments.\n•\nLignes 7 à 10. Le nombre d’argument(s) est incorrect et génère une erreur. Dans cet exemple, on passe un\nargument alors que la fonction lambda créée ici n’en prend pas.\n•\nLignes 11 à 14. Le nombre d’argument(s) est incorrect et génère une erreur. Dans cet exemple, on passe un\nargument alors que la fonction lambda créée ici en prend deux.\n26.3.2 Assignation d’une fonction lambda à un nom ?\nBien que cela soit déconseillé, il est possible d’assigner une fonction lambda à un nom de variable :\n1\n>>> carre = lambda x: x**2\n2 >>> carre(3)\n3\n9\nL’équivalent avec une fonction classique serait :\n1 >>> def carre(x):\n2\n... return x**2\n3 ...\n4\n>>> carre(9)\n5 81\nDans les deux cas l’appel est identique, mais la fonction lambda requière une syntaxe à une ligne lors de sa définition.\nMême si on peut le faire, les dévelopeurs déconseillent toutefois d’assigner une fonction lambda à un nom dans\n7\nla PEP8 . Une des raisons est que si une erreur est générée, l’interpréteur ne renvoie pas le numéro de ligne dans la\nTraceback :\n1\n>>> inverse = lambda: 1/0\n2 >>> inverse()\n3 Traceback (most recent call last):\n4\nFile \"<stdin>\", line 1, in <module>\n5 File \"<stdin>\", line 1, in <lambda>\n6\nZeroDivisionError: division by zero\nLigne 5. L’indication de la ligne pour l’erreur dans la fonction lambda (line 1) correspond à celle de l’appel et non\npas de la définition.\nAlors qu’avec une fonction classique :\n>>> def inverse():\n... return 1/0\n...\n>>> inverse()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 2, in inverse\nZeroDivisionError: division by zero\nLigne 5. Cette fois-ci, la Traceback indique bien la bonne ligne (line 2) dans la fonction.\n7. https://peps.python.org/pep-0008/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 325\nChapitre 26. Remarques complémentaires 26.3. Fonctions lambda\nConseil\nPour cette raison, n’assignez pas une fonction lambda à un nom, mais utilisez la seulement à la volée (voir ci-dessous).\nUne autre raison est que cela peut nuire à la lisibilité. Si une fonction lambda s’écrit en une ligne, c’est bien pour qu’on\npuisse la lire quand elle est utilisée.\n26.3.3 Utilité des fonctions lambda\nJusqu’à maintenant nous avons défini les fonctions lambda et montré ce qu’il ne fallait pas faire. Vous vous posez\nsans doute la question, mais à quoi servent-elles vraiment ? Nous vous montrons ici deux utilisations principales.\n8\nLa première est qu’elles sont utiles pour implémenter des concepts de programmation fonctionnelle . Dans ce para-\ndigme de programmation, on cherchera à « emboiter » les fonctions les unes dans les autres. Nous avions déjà croisé\ncette idée avec la fonction dans le chapitre 11 Plus sur les chaînes de caractères. Celle-ci permet d’appliquer une\nmap()\nfonction à tous les éléments d’un objet itérable. Par exemple, convertir en entier les différents éléments d’une chaîne de\ncaractères :\n1 >>> ligne = \"3 5 -10\"\n2\n>>> list(map(int, ligne.split()))\n3 [3, 5, -10]\nLigne 2. On a converti l’objet map en liste pour voir ce qu’il contenait.\nL’utilisation impliquant une fonction lambda permet par exemple d’appliquer une opération à tous les éléments d’une\nliste :\n1\n>>> liste1 = [3, 5, -10]\n2 >>> list(map(lambda x: x**2, liste1))\n3\n[9, 25, 100]\n4 >>> list(map(lambda x: 1/x, liste1))\n5\n[0.3333333333333333, 0.2, -0.1]\nLignes 2 et 4. La fonction lambda permet de lire clairement quelle opération on réalise plutôt que de se référer à\nune fonction classique se trouvant à un autre endroit. Ainsi, cela améliore la lisibilité.\nCela vous rappelle peut-être ce qu’on a rencontré avec les objets NumPy et les opérations vectorielles :\n1\n>>> import numpy as np\n2 >>> array1 = np.arange(10)\n3\n>>> array1\n4 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n5\n>>> array1 * 2\n6 array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18])\n7\n>>>\n8 >>> liste1 = list(range(10))\n9\n>>> liste1\n10 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n11\n>>> list(map(lambda x: x*2, liste1))\n12 [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\nLigne 5. Nativement, l’opération se fait vectoriellement (élément par élément) avec un array NumPy.\narray1 * 2\nLigne 11. La fonction applique l’opération de la lambda sur tous les éléments de la liste. Ainsi, on obtient\nmap() * 2\nle même effet que sur l’array NumPy.\nBien que cela s’avère pratique, nous verrons dans la rubrique suivante sur les itérateurs qu’il existe une syntaxe plus\nPythonique avec les listes de compréhensions et les expressions génératrices.\nLa deuxième grande utilité des fonctions lambda concerne leur utilisation pour faire des tris puissants. Dans le chapitre\n14 Conteneurs, nous avions vu les tris de dictionnaires par valeurs :\n1 >>> dico = {\"a\": 15, \"b\": 5, \"c\":20}\n2\n>>> sorted(dico, key=dico.get)\n3 ['b', 'a', 'c']\n8. https://fr.wikipedia.org/wiki/Programmation_fonctionnelle\n326 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.3. Fonctions lambda Chapitre 26. Remarques complémentaires\nLigne 2. On passe à l’argument par mot-clé la callback (cette méthode renvoie initialement les valeurs\nkey dico.get\nd’un dictionnaire). Cela permet finalement de trier par ce que renvoie cette méthode, à savoir les valeurs.\nCet argument par mot-clé peut prendre d’autres callback, par exemple . Dans l’exemple suivant, on prend 10 mots\nlen\nau hasard dans le dictionnaire et on les trie par leur longueur :\n1 >>> mots = ['étudier', 'pie-grièche', 'figurerait', 'retraitait', 'allégerais',\n2\n'distribuent', 'affilierait', 'ramassa', 'galettes', 'connu']\n3 >>> sorted(mots, key=len)\n4\n['connu', 'étudier', 'ramassa', 'galettes', 'figurerait', 'retraitait',\n5 'allégerais', 'pie-grièche', 'distribuent', 'affilierait']\nBien sûr, on peut utiliser aussi une fonction lambda. Celle-ci va nous permettre de passer une fonction de tri à la\nvolée au moment de l’appel de la fonction . Par exemple, si on reprend le même exemple que le dictionnaire\nsorted()\nmais sous forme d’une liste de tuples :\n1\nliste1 = [('a', 15), ('b', 5), ('c', 20)]\nComment trier en fonction du deuxième élément de chaque tuple ? Réponse, avec une fonction lambda bien sûr !\nRegardez :\n1 >>> sorted(liste1, key=lambda x: x[1])\n2\n[('b', 5), ('a', 15), ('c', 20)]\nAutre exemple, on souhaite trier une liste d’entiers aléatoires non pas par leur valeur, mais par le résultat de la fonction\n:\nx**2\n1\n>>> liste1 = [-5, 2, 5, 8, 6, 3, -9, 4, -10, 2]\n2 >>> sorted(liste1, key=lambda x: x**2)\n3\n[2, 2, 3, 4, -5, 5, 6, 8, -9, -10]\nPour comprendre comment le tri est opéré en ligne 3, voici la liste initiale et une autre liste avec les carrés :\n1 >>> liste1\n2\n[-5, 2, 5, 8, 6, 3, -9, 4, -10, 2]\n3 >>> [x**2 for x in liste1]\n4\n[25, 4, 25, 64, 36, 9, 81, 16, 100, 4]\nLe tri de ci-dessus est bien effectué en fonction des valeurs montrées en ligne 4.\nliste1\nL’agument par mot-clé existe dans d’autres fonctions ou méthodes. Bien sûr il existe dans la méthode\nkey .sort()\nqui trie les listes sur place. Mais aussi, dans les fonctions natives et . Enfin, on le croise dans la fonction\nmin() max()\ndu module itertools (voir rubrique suivante). Dans tous ces cas, on peut utiliser une fonction lambda pour\ngroupby()\nl’argument .\nkey\nPar exemple, dans le code suivant :\n1 >>> liste = ['baccalauréat', 'abaissera', 'barricadé', 'zouave', 'tabac',\n2\n'typographie', 'dactylographes', 'éclipse']\n3 >>> min(liste)\n4 'abaissera'\n5\n>>> max(liste)\n6 'éclipse'\n7\n>>> min(liste, key=lambda x: x.count(\"a\"))\n8 'éclipse'\n9\n>>> max(liste, key=lambda x: x.count(\"a\"))\n10 'baccalauréat'\n•\nLigne 1. On prend une liste de mots du dictionnaire.\n•\nLignes 2 et 4. Les fonctions et considèrent l’ordre ASCII par défaut. Elles renvoient le premier et\nmin() max ()\ndernier élément de la liste après un tel tri.\n•\nLignes 6 et 8. Comprenez-vous la règle que nous avons utilisée avec la lambda ?\nRegardons comment se passe le tri :\n1 >>> liste.sort(key=lambda x: x.count(\"a\"))\n2\n>>> liste\n3 ['éclipse', 'zouave', 'typographie', 'barricadé', 'tabac', 'dactylographes',\n4\n'abaissera', 'baccalauréat']\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 327\nChapitre 26. Remarques complémentaires 26.4. Itérables, itérateurs, générateurs et module itertools\nVous l’aurez sans doute compris, avec notre fonction lambda, nous avons trié en fonction du nombre de lettres dans\na\nchaque mot !\n26.3.4 Conclusion\nNous avons vu que les fonctions lambda permettaient des définitions de fonction rapidement sur une ligne. Il faut\nabsolument éviter de les assigner à un nom. Elles ont toute leur utilité lorsqu’on les utilise avec pour appliquer\nmap()\nune opération à tous les éléments d’un conteneur, ou pour des tris puissants avec .\nsorted()\nConseil\n9 10 11\nPour aller plus loin, vous pouvez consulter ces quelques articles : Dataquest , Trey Hunner , RealPython et Dan\n12\nBader ."
  },
  {
    "title": "Itérables, itérateurs, générateurs et module itertools",
    "content": "26.4.1 Itérables et itérateurs\nDans le chapitre 14 Conteneurs, nous avons défini le mot itérable lorsque nous avions un objet de type conteneur sur\nlequel on pouvait itérer (comme les listes, tuples, dictionnaires, etc.). En général, nous le faisions avec une boucle .\nfor\nVoyons ce qu’est maintenant un itérateur.\nDéfinition\nUn itérateur est un objet Python qui permet d’itérer sur une suite de valeurs avec la fonction jusqu’à temps\nnext()\nqu’elles soient épuisées. Si on itère sur une partie des valeurs seulement, l’itérateur garde en mémoire là où il s’est arrêté.\nSi on le resollicite avec un il repartira de l’élément suivant. Une règle est toutefois importante : les valeurs ne\nnext()\npeuvent être parcourues qu’une seule fois.\nOn peut générer un itérateur avec la fonction à partir de n’importe quel conteneur :\niter()\n1 >>> animaux = [\"chien\", \"chat\", \"souris\"]\n2\n>>> iterateur = iter(animaux)\n3 >>> iterateur\n4\n<list_iterator object at 0x7f917e907a30>\nUne fois l’itérateur généré, on peut accéder à l’élément suivant avec la fonction :\nnext()\n1\n>>> next(iterateur)\n2 'chien'\n3\n>>> next(iterateur)\n4 'chat'\n5 >>> next(iterateur)\n6\n'souris'\n7 >>> next(iterateur)\n8\nTraceback (most recent call last):\n9 File \"<stdin>\", line 1, in <module>\n10\nStopIteration\nQuand il n’y a plus de valeurs sur lesquelles itérer, la fonction lève une exception . En général,\nnext() StopIteration\non n’utilisera pas les itérateurs de cette manière, mais plutôt avec une boucle ce qui évitera cette levée d’exception :\nfor\n9.\nhttps://www.dataquest.io/blog/tutorial-lambda-functions-in-python/\n10. https://www.pythonmorsels.com/lambda-expressions/\n11.\nhttps://realpython.com/python-lambda/\n12. https://dbader.org/blog/python-lambda-functions\n328 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.4. Itérables, itérateurs, générateurs et module itertools Chapitre 26. Remarques complémentaires\n1\n>>> iterateur = iter(animaux)\n2 >>> for elt in iterateur:\n3\n... print(elt)\n4 ...\n5\nchien\n6 chat\n7 souris\nOn peut transformer un objet de type itérateur en un objet de type séquentiel, par exemple en tuple :\n1\n>>> iterateur = iter(animaux)\n2 >>> tuple(iterateur)\n3\n('chien', 'chat', 'souris')\nLe point important est qu’une fois toutes les valeurs parcourues, l’itérateur est épuisé et ne renvoie plus rien :\n1\n>>> iterateur = iter(animaux)\n2 >>> tuple(iterateur)\n3 ('chien', 'chat', 'souris')\n4\n>>> tuple(iterateur)\n5 ()\nAinsi, on ne pourra parcourir l’ensemble des valeurs d’un itérateur qu’une fois.\nÀ ce stade, on pourrait se dire que la construction d’un itérateur à partir d’une liste ci-dessus est inutile puisqu’on\npeut itérer directement sur la liste avec une boucle . Toutefois, lorsqu’on réalise une telle boucle, il y a un itérateur\nfor\nqui est généré implicitement même si on ne s’en rend pas compte. Pour prouver cela, essayons la fonction avec\nnext()\nune liste :\n1\n>>> next(animaux)\n2 Traceback (most recent call last):\n3 File \"<stdin>\", line 1, in <module>\n4 TypeError: 'list' object is not an iterator\nCeci n’est pas possible car une liste n’est pas un itérateur. Alors pourquoi peut-on itérer dessus avec une boucle ?\nfor\nEt bien, c’est parce que l’objet de type liste possède une méthode dunder spéciale nommée . Celle-ci génère\n.__iter__()\nun itérateur à partir d’elle-même permettant d’itérer sur ses éléments. L’objet itérateur ainsi généré possèdera une autre\nméthode dunder spéciale permettant de passer à l’élément suivant lorsqu’on itère dessus.\n.__next__()\nRemarque\nPour rappel, les méthodes dunder des classes ont été définies dans la rubrique 24.2.2 Méthodes magiques ou dunder\nmethods du chapitre 24 Avoir plus la classe avec les objets.\nLorsque vous construirez votre propre objet itérable, il faudra écrire une classe contenant ces deux méthodes dunder\net l’objet sera de facto un itérateur et itérable. Pour vous donnez une première idée, voici une classe minimale créant un\nobjet itérateur sur les lettres de l’alphabet :\n1 class Alphabet:\n2\ndef __init__(self):\n3 self.current = 97 # ASCII code for a.\n4\n5 def __iter__(self):\n6\nreturn self\n7\n8\ndef __next__(self):\n9 if self.current > 122: # ASCII code for z.\n10\nraise StopIteration\n11 letter = chr(self.current)\n12 self.current += 1\n13 return letter\n•\nLigne 3. Dans le constructeur, on crée un attribut d’instance qui gardera l’état de l’itérateur. On\nself.current\nl’initialise à 97 correspondant au code ASCII de la lettre .\na\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 329\nChapitre 26. Remarques complémentaires 26.4. Itérables, itérateurs, générateurs et module itertools\n•\nLignes 5 et 6. La méthode dunder est très simple à écrire. Elle renvoie correspondant à\n.__iter__() self\nl’itérateur lui-même. Si cette méthode n’est pas présente, l’objet n’est pas itérable.\n•\nLignes 8 à 13. La méthode dunder s’occupe de passer à l’élément suivant et de garder une mémoire\n.__next__()\nde là où l’itérateur est arrivé. Cela se passe en quatre étapes : i) levée d’une exception si on est\nStopIteration\narrivé au bout, ii) détermination de la lettre actuelle, iii) incrémenter le de 1 pour l’itération suivante\nself.current\net iv) retourner la lettre actuelle.\nSi on sauve cette classe dans un fichier , voici comment on pourrait l’utiliser :\niterator.py\n1\n>>> import iterator\n2 >>> iter_alphabet = iterator.Alphabet()\n3 >>> iter_alphabet\n4\n<iterator.Alphabet object at 0x7f308edc70b0>\n5 >>> for lettre in iter_alphabet:\n6\n... print(lettre)\n7 ...\n8\na\n9 b\n10\n[...]\n11 y\n12\nz\n13 >>> list(iter_alphabet)\n14\n[]\nÀ nouveau, une fois l’itérateur épuisé, il ne renvoie plus rien. Bien sûr, cela représente un exemple très simple et la\nplupart du temps on créera ses propres classes itérateurs en implémentant de nombreuses fonctionnalités et méthodes sup-\nplémentaires. Pour créer un itérateur basique comme celui-ci sur l’alphabet, il est plus commode d’utiliser les générateurs\n(voir rubrique Générateurs ci-dessous).\nPour aller plus loin\n13 14\nPour aller plus loin sur comment fonctionne les itérateurs, vous pouvez lire ces articles de Dan Bader , Trey Hunner\n15 16\net du site RealPython . Concernant la sémantique, cet article de Trey Hunner explique pourquoi les objets range ne\nsont pas des itérateurs.\n26.4.2 Autres fonctions builtins renvoyant des itérateurs\nDans les chapitres précédents, nous avons déjà croisé des itérateurs sans le savoir, car nous ne vous l’avons pas\ntoujours précisé explicitement ! Dans le chapitre 5 Boucles avec la fonction , dans le chapitre 11 Plus sur\nenumerate()\nles chaînes de caractères avec la fonction et dans le chapitre 12 Plus sur les listes avec la fonction . Ces\nmap() zip()\ntrois fonctions renvoient des itérateurs qui sont épuisés une fois utilisés :\n1 >>> animaux = [\"chien\", \"chat\", \"souris\"]\n2\n>>> obj_enum = enumerate(animaux)\n3 >>> obj_enum\n4\n<enumerate object at 0x7f917ebf93a0>\n5 >>> tuple(obj_enum)\n6 ((0, 'chien'), (1, 'chat'), (2, 'souris'))\n7\n>>> tuple(obj_enum)\n8 ()\n13.\nhttps://dbader.org/blog/python-iterators\n14. https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/\n15.\nhttps://realpython.com/python-iterators-iterables/\n16. https://treyhunner.com/2018/02/python-range-is-not-an-iterator/\n330 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.4. Itérables, itérateurs, générateurs et module itertools Chapitre 26. Remarques complémentaires\n1\n>>> line = \"9 11 25 92 49 98 62 72 63 74\"\n2 >>> obj_map = map(int, line.split())\n3\n>>> obj_map\n4 <map object at 0x7f029e47b9a0>\n5\n>>> min(obj_map)\n6 9\n7 >>> list(obj_map)\n8\n[]\n1\n>>> obj_zip = zip(range(5), range(5, 10))\n2 >>> list(obj_zip)\n3\n[(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]\n4 >>> list(obj_zip)\n5\n[]\nLorsque ces fonctions avaient été évoquées, nous n’avions pas vu ce problème d’épuisement car elles étaient utilisées\ndirectement dans une boucle. Par exemple :\n1\n>>> for i, j in zip(range(5), range(5, 10)):\n2 ... print(i, j)\n3\n...\n4 0 5\n5 1 6\n6\n2 7\n7 3 8\n8\n4 9\nAinsi, l’itérateur était généré à chaque fois qu’on lançait la boucle et n’était utilisé qu’une seule fois.\nUne derniere fonction renvoyant un itérateur qui existe nativement dans les fonctions builtins de Python est\nreversed\n. Celle-ci prend en argument un objet de type séquence (liste, tuple, chaîne de caractère ou range) et renvoie un itérateur\n()\nparcourant la séquence en sens inverse :\n1 >>> reversed(range(5))\n2\n<range_iterator object at 0x7f8b34227780>\n3 >>> rev_iterateur = reversed(range(5))\n4\n>>> for i in rev_iterateur:\n5 ... print(i)\n6\n...\n7 4\n8\n3\n9 2\n10\n1\n11 0\n12 >>> list(rev_iterateur)\n13\n[]\nPour finir, examinons les propriétés des itérateurs que nous avions vues pour les conteneurs. Un objet itérateur est\nbien sûr iterable et ordonné, par contre il n’est pas indexable. Il ne supporte pas la fonction , supporte l’opérateur\nlen()\net il est hachable.\nin\n1\n>>> animaux = [\"chien\", \"chat\", \"souris\"]\n2 >>> iterateur = iter(animaux)\n3 >>> len(iterateur)\n4\nTraceback (most recent call last):\n5 File \"<stdin>\", line 1, in <module>\n6\nTypeError: object of type 'list_iterator' has no len()\n7 >>> iterateur[1]\n8\nTraceback (most recent call last):\n9 File \"<stdin>\", line 1, in <module>\n10\nTypeError: 'list_iterator' object is not subscriptable\n11 >>> \"chien\" in iterateur\n12\nTrue\n13 >>> hash(iterateur)\n14\n8741535406492\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 331\nChapitre 26. Remarques complémentaires 26.4. Itérables, itérateurs, générateurs et module itertools\nAttention\nL’utilisation de l’opérateur pour un test d’appartenance sur un itérateur épuise ce dernier (au même titre que\nin\nl’utilisation de l’itérateur dans une boucle où avec la fonction ) :\nlist()\n1 >>> line = \"9 11 25 92 49 98 62 72 63 74\"\n2\n>>> obj_map = map(int, line.split())\n3 >>> 9 in obj_map\n4\nTrue\n5 >>> 9 in obj_map\n6\nFalse\nLigne 3, on fait un premier test qui parcourt l’itérateur et renvoie . Même si la valeur était présente initialement,\nTrue 9\nle deuxième test, ligne 5, renvoie car l’itérateur est épuisé.\nFalse\n26.4.3 Module itertools\n17\nIl existe de nombreuses fonctions générant des itérateurs. Le module en est particulièrement riche.\nitertools\nNous n’allons pas faire une liste exhaustive du contenu de ce module, mais nous parlerons de quelques fonctions qui nous\n18 19\nparaissent utiles, notamment . Son fonctionnement fait penser au produit extérieur (outer product en\nproduct()\n20\nanglais) de l’algèbre tensorielle. Nous montrerons également la fonction permettant de faire des regrou-\ngroupby()\npements puissants. Enfin, nous évoquerons rapidement les itérateurs infinis comme la fonction à la fin de la\ncount()\nrubrique.\n26.4.3.1 Fonction\nproduct()\nLa fonction prend (au moins) deux conteneurs en argument et génère toutes les combinaisons possibles\nproduct()\nd’association :\n1\n>>> import itertools\n2 >>> predateurs = [\"lion\", \"requin\", \"tigre\"]\n3\n>>> proies = [\"souris\", \"oiseau\", \"gazelle\"]\n4 >>> for pred, proie in itertools.product(predateurs, proies):\n5\n... print(pred, proie)\n6 ...\n7\nlion souris\n8 lion oiseau\n9\nlion gazelle\n10 requin souris\n11 requin oiseau\n12\nrequin gazelle\n13 tigre souris\n14\ntigre oiseau\n15 tigre gazelle\nIl est possible de passer plus de deux conteneurs à la fonction, par exemple :\n1\n>>> ma_liste = [1, 2]\n2 >>> list(itertools.product(ma_liste, ma_liste, ma_liste))\n3\n[(1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 2, 2), (2, 1, 1), (2, 1, 2), (2, 2, 1), (2, 2, 2)]\nOn a ici toutes les combinaisons possibles entre les trois objets passés en argument.\nma_liste\nAvec deux conteneurs en argument, cette fonction revient à faire une double boucle sur les deux conte-\nproduct()\nneurs. Elle est donc particulièrement adaptée pour parcourir toutes les éléments d’un tableau. Par exemple, la commande\nsuivante parcourera toutes les cases d’un échiquier :\n17.\nhttps://docs.python.org/fr/3.12/library/itertools.html\n18. https://docs.python.org/fr/3.12/library/itertools.html#itertools.product\n19.\nhttps://en.wikipedia.org/wiki/Outer_product\n20. https://docs.python.org/fr/3.12/library/itertools.html#itertools.groupby\n332 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.4. Itérables, itérateurs, générateurs et module itertools Chapitre 26. Remarques complémentaires\n1\n>>> parcours_echiquier = itertools.product(\"abcdefgh\", \"12345678\")\n2 >>> parcours_echiquier\n3\n<itertools.product object at 0x7f192e412040>\n4 >>> for col, ligne in parcours_echiquier:\n5\n... print(col, ligne)\n6 ...\n7 a 1\n8\na 2\n9 [...]\n10\nh 7\n11 h 8\nMais attention, la fonction est un itérateur. Donc quand elle est épuisée, on ne peut plus l’utiliser :\nproduct()\n1\n>>> list(parcours_echiquier)\n2 []\nUne utilisation particulièrement utile de en bioinformatique peut être de générer toutes les séquences\nproduct()\nd’ADN possibles (mots) de deux lettres :\n1 >>> bases = \"atgc\"\n2\n>>> list(itertools.product(bases, bases))\n3 [('a', 'a'), ('a', 't'), ('a', 'g'), ('a', 'c'), ('t', 'a'), ('t', 't'), ('t', 'g'),\n4\n('t', 'c'), ('g', 'a'), ('g', 't'), ('g', 'g'), ('g', 'c'), ('c', 'a'), ('c', 't'),\n5 ('c', 'g'), ('c', 'c')]\nDe même, itérera sur tous les mots de trois lettres possibles. Ou en-\nitertools.product(bases, bases, bases)\ncore, si on définit une chaîne de caractères contenant les vingt acides aminés comme suit\naas = \"acdefghiklmnpqrstvwy\n, produira tous les dipeptides possibles.\n\" itertools.product(aas, aas)\n26.4.3.2 Fonction\ngroupby()\nLa fonction permet de faire des regroupements puissants. Pour vous montrer son fonctionnement, nous\ngroupby()\nallons prendre un exemple. Nous partons d’une liste de mots que nous triions par longueur avec l’argument auquel\nkey\non passe la callback (voir chapitre 12 Plus sur les listes) :\nlen\n1 >>> mots = [\"bar\", \"babar\", \"bam\", \"ba\", \"bababar\", \"barre\", \"bla\", \"barbare\"]\n2\n>>> mots.sort(key=len)\n3 >>> mots\n4\n['ba', 'bar', 'bam', 'bla', 'babar', 'barre', 'bababar', 'barbare']\nLa fonction crée un itérateur particulier :\ngroupby()\n1\n>>> itertools.groupby(mots, key=len)\n2 <itertools.groupby object at 0x7f467a6d0ca0>\n3\n>>> list(itertools.groupby(mots, key=len))\n4 [(2, <itertools._grouper object at 0x7f467a8cf700>),\n5\n(3, <itertools._grouper object at 0x7f467a58c0d0>),\n6 (5, <itertools._grouper object at 0x7f467a58c100>),\n7\n(7, <itertools._grouper object at 0x7f467a58c040>)]\n•\nLignes 1 et 3. Il est important de passer à l’argument la même fonction callback que lors du tri initial.\nkey\n•\nLignes 4 à 7. En transformant cet itérateur en liste, on voit qu’il génère une liste de tuples. Le premier élément de\nchaque tuple est un entier correspondant à une longueur de mot, le second élément est un itérateur. Que contient\nce dernier ?\n1\n>>> for longueur, iterateur in itertools.groupby(mots, key=len):\n2 ... print(longueur, list(iterateur))\n3 ...\n4\n2 ['ba']\n5 3 ['bar', 'bam', 'bla']\n6\n5 ['babar', 'barre']\n7 7 ['bababar', 'barbare']\nLignes 4 à 7. La conversion de cet itérateur en liste montre qu’il contient tous les mots de même longueur.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 333\nChapitre 26. Remarques complémentaires 26.4. Itérables, itérateurs, générateurs et module itertools\nComme vu dans une rubrique précédente, on peut passer une fonction lambda à l’argument :\nkey\n1\n>>> mots.sort(key=lambda chaine: chaine.count(\"a\"))\n2 >>> mots\n3\n['ba', 'bar', 'bam', 'bla', 'barre', 'babar', 'barbare', 'bababar']\n4 >>> itertools.groupby(mots, key=lambda chaine: chaine.count(\"a\"))\n5\n<itertools.groupby object at 0x7f467a6d0ca0>\n6 >>> list(itertools.groupby(mots, key=lambda chaine: chaine.count(\"a\")))\n7\n[(1, <itertools._grouper object at 0x7f467a58c490>),\n8 (2, <itertools._grouper object at 0x7f467a58c100>),\n9\n(3, <itertools._grouper object at 0x7f467a58c040>)]\n10 >>> for nb_a, iterateur in itertools.groupby(mots, key=lambda chaine: chaine.count(\"a\")):\n11 ... print(nb_a, list(iterateur))\n12\n...\n13 1 ['ba', 'bar', 'bam', 'bla', 'barre']\n14\n2 ['babar', 'barbare']\n15 3 ['bababar']\nIci on a regroupé les mots suivant le nombre de lettres qu’ils contiennent.\na\nConseil\nAvant de faire un regroupement avec , pensez à trier la liste initiale avec ou en utilisant\ngroupby() .sort() sorted()\nla même fonction (ou fonction lambda) passée à l’argument .\nkey\nRemarque\nIl existe aussi une méthode qui procède à des regroupements sur les dataframes pandas. Son mode de\n.groupby()\nfonctionnement est assez différent par rapport à la fonction du module itertools. Vous pouvez consulter le\ngroupby()\nchapitre 22 Modules pandas pour en savoir un peu plus.\n26.4.4 Générateurs\nDéfinition\nUn générateur est un type d’itérateur particulier. On peut créer un générateur très facilement avec le mot-clé\nyield\nou avec les expression génératrices (generator expressions en anglais) qui ont une syntaxe similaire à celle des listes de\ncompréhension.\nLa création d’un générateur avec le mot-clé consiste à créer une fonction utilisant ce mot-clé. À partir de ce\nyield\nmoment là, la fonction renvoie un générateur. Avant de voir un exemple, imaginons une fonction qui crée et renvoie une\nliste :\n1 >>> def cree_alphabet():\n2\n... alphabet = []\n3 ... for i in range(97, 123):\n4\n... alphabet.append(chr(i))\n5 ... return alphabet\n6\n...\n7 >>> alphabet = cree_alphabet()\n8\n>>> alphabet\n9 ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',\n10 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\nPour créer un générateur équivalent, il suﬀira de remplacer le par un et d’enlever le :\n.append() yield return\n334 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.4. Itérables, itérateurs, générateurs et module itertools Chapitre 26. Remarques complémentaires\n1\n>>> def alphabet_generator():\n2 ... for i in range(97, 123):\n3\n... yield chr(i)\n4 ...\n5\n>>> gen = alphabet_generator()\n6 >>> gen\n7 <generator object alphabet_generator at 0x7fe1dffe39f0>\n8\n>>> for lettre in gen:\n9 ... print(lettre)\n10\n...\n11 a\n12\nb\n13 c\n14\n[...]\n15 y\n16\nz\n17 >>>\n18\n>>> list(gen)\n19 []\nComme pour tous les itérateurs, une fois tous les éléments parcourus le générateur est épuisé. Notez que le\nyield\nn’est pas une fonction mais un mot-clé, on n’utilise donc pas de parenthèses. Ce mot-clé n’a de sens que dans\nyield\nune fonction et ne s’utilise que pour créer des générateurs.\nLa technique avec une expression génératrice ressemble à la syntaxe des listes de compréhension (voir la rubrique\nListes de compréhension du chapitre 12 Plus sur les listes), mais on l’entoure de parenthèses à la place des crochets :\n1 >>> [n**2 for n in range(10)] # Liste de compréhension.\n2\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n3 >>> (n**2 for n in range(10)) # Expression génératrice.\n4\n<generator object <genexpr> at 0x7f917feb39f0>\n5 >>> gen = (n**2 for n in range(10))\n6\n>>> for n in gen:\n7 ... print(n)\n8 ...\n9\n0\n10 [...]\n11\n81\nÀ nouveau, le générateur est épuisé après avoir itéré dessus :\n1 >>> for nb in gen:\n2 ... print(nb)\n3\n...\n4 >>>\nPour aller plus loin\nUn générateur est un itérateur, mais l’inverse n’est pas vrai. Pour comprendre toutes les subtilités liées à cette\n21\ncomparaison, vous pouvez consulter cette page sur le site Datacamp.\nConseil\nComme vous le voyez, créer un générateur est extrêmement aisé avec le mot-clé ou les expressions génératrices\nyield\npar rapport à l’écriture d’une classe itérateur (voir ci-dessus). Ainsi nous vous conseillons d’utiliser plutôt les générateurs\nlorsque vous souhaitez créer des itérateurs simples.\n21. https://www.datacamp.com/tutorial/python-iterators-generators-tutorial\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 335\nChapitre 26. Remarques complémentaires 26.4. Itérables, itérateurs, générateurs et module itertools\n26.4.5 Pourquoi utiliser des itérateurs ?\nÀ ce stade, vous vous posez peut-être la question « Pourquoi utiliser des itérateurs ? ». Nous donnons quelques\nréponses dans cette rubrique.\n26.4.5.1 Consommation de resources optimisée\nLa première raison fondamentale est la consommation de resources. Lorsque vous créez un itérateur, Python ne va\npas construire l’ensemble des éléments dans la mémoire, mais plutôt préparer la « moulinette » qui réalisera les itérations.\nRésultat, le processsus est très peu consommateur de mémoire même en créant un itérateur itérant sur un très grand\nnombre d’éléments. Par ailleurs, Python crée les éléments au fur et à mesure et à la demande. C’est pour cela qu’on parle\n22\nparfois « d’évaluation paresseuse ou fainéante » dans le sens où la valeur suivante d’un itérateur n’est pas pré-calculée\n23\nmais plutôt évaluée quand on lui demande. Trey Hunner parle ainsi d’objets itérables « paresseux ».\nUn itérateur sera par ailleurs très rapide car en interne il fait appel à des routines optimisées en C. Mais aussi,\nl’utilisation de fonctions Python qui sont elles aussi optimisées (par exemple ) rend les itérateurs particulièrement\nsum()\neﬀicaces.\nAfin de quantifier cela, on propose de mesurer le temps d’exécution de trois petits morceaux de code faisant une\nsomme de tous les entiers de 1 à 100000 (cent mille) avec un générateur, une boucle Python classique et une liste de\n24\ncompréhension. Pour faire une telle mesure, nous utilisons le module timeit qui est particulièrement bien optimisé pour\ncela. Voici un exemple d’utilisation de :\ntimeit\n1 $ python -m timeit \"sum(n**2 for n in range(100000))\"\n2\n50 loops, best of 5: 3.76 msec per loop\nOn peut lancer directement à la ligne de commande Unix avec l’option suivie de l’instruction Python à\ntimeit -m\nexécuter entre guillemets. Python va effectuer plusieurs fois l’instruction (ici 50 fois) et donnera une approximation au\nplus juste du temps d’exécution de celle-ci. Le nombre d’exécutions de l’instruction dépendra du temps pris par celle-ci\net sera entièrement déterminé par Python.\nEn revenant à notre problématique, voici les résultats de notre somme de 1 à 100000 (testé sur un ordinateur portable\nrelativement récent avec la version Python 3.12 ) :\n$ python -m timeit \"sum(n**2 for n in range(100000))\"\n50 loops, best of 5: 3.76 msec per loop\n$ python -m timeit \"somme=0\" \"for n in range(100000): somme += n**2\"\n50 loops, best of 5: 3.59 msec per loop\n$ python -m timeit \"sum([n**2 for n in range(100000)])\"\n50 loops, best of 5: 4.89 msec per loop\n•\nLigne 1. On utilise un générateur et la fonction pour calculer cette somme. Notez que lorsqu’un générateur\nsum()\nest utilisé dans une fonction, les parenthèses ne sont pas obligatoires. Cela simplifie la syntaxe par rapport à\n.\nsum((n**2 for n in range(nb)))\n•\nLigne 3. On utilise une boucle Python classique pour calculer cette somme. Notez que pour pouvoir utiliser\ntimeit\nsur une ligne, on est obligé de passer deux arguments entre guillemets (initialisation de la variable et boucle).\nsomme\n•\nLigne 5. On utilise une liste de compréhension pour calculer cette somme.\nLa méthode avec les générateurs est à peu près équivalente à l’utilisation d’une boucle classique où on accumule la\nsomme, preuve que les deux méthodes sont bien optimisées. De manière spectaculaire, la liste de compréhension est bien\nplus lente (presque 1 ms de plus). Ceci vient du fait qu’il faut créer la liste de tous les éléments en mémoire, ce qui est\ncontre-productif. Le générateur ou la boucle classique se contentent d’itérer et sont bien plus économes.\nDernier point, un test réalisé avec la version Python 3.13 sortie en octobre 2024 conduit aux mêmes observations.\n26.4.5.2 Itérateurs infinis\nBien que la taille de la mémoire d’un ordinateur soit finie, il est possible de créer des itérateurs infinis ! Par exemple,\n25\nla fonction du module itertools itère de 0 (lorsqu’on l’appelle sans argument) jusqu’à l’infini :\ncount()\n22.\nhttps://en.m.wikipedia.org/wiki/Lazy_evaluation\n23. https://treyhunner.com/2018/06/how-to-make-an-iterator-in-python/\n24.\nhttps://docs.python.org/fr/3/library/timeit.html\n25. https://docs.python.org/3/library/itertools.html#itertools.count\n336 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.4. Itérables, itérateurs, générateurs et module itertools Chapitre 26. Remarques complémentaires\n1\n>>> iterateur = itertools.count()\n2 >>> import itertools\n3\n>>> iterateur = itertools.count()\n4 >>> for i in iterateur:\n5\n... print(i)\n6 ...\n7 0\n8\n1\n9 2\n10\n3\n11 [Boucle infinie]\nAttention de ne pas transformer cet itérateur en liste ou tuple sous peine de saturer la mémoire de l’ordinateur et de\nle faire planter !\n26 27\nDans le même module les fonctions et sont également des itérateurs infinis.\ncycle() repeat()\n26.4.5.3 Meilleure lisibilité\n28\nDe manière générale, l’utilisation d’itérateurs peut améliorer la lisibilité de vos programmes. Cet article fait remarquer\nque le simple fait de créer un itérateur et de le nommer donne un sens à ce qu’il contient. En reprenant notre exemple\nsur la somme des carrés :\n1 tous_les_carres = (n**2 for n in range(nb))\n2\nsomme = sum(tous_les_carres)\nSi on compare à la boucle :\nfor\n1\nsomme = 0\n2 for n in range(nb):\n3\nsomme += n**2\nOn voit que ce que représente l’objet n’existe tout simplement pas avec la boucle ! Par\ntous_les_carres for\nailleurs, outre l’avantage de rapidité, l’utilisation de la fonction rend la lecture très claire.\nsum()\nDernier point, les itérateurs et notamment les générateurs, donnent un moyen de faire de la programmation fonction-\n29\nnelle en Python. Sans rentrer dans les considérations théoriques, nous avons déjà vu l’idée générale lorsque nous avons\nabordé le method chaining sur les chaînes de caractères ou sur les dataframes pandas. Initialement, la programmation\nfonctionnelle en Python utilisait la fonction (ainsi que les fonctions et non abordées ici).\nmap() filter() reduce()\nMais depuis l’arrivée des générateurs, on préfère ces derniers qui sont considérés plus Pythoniques. Regardons un exemple\noù nous transformons une chaîne de caractères en entiers puis nous calculons la somme. D’abord avec un générateur :\n1 >>> ligne = \"9 11 25 92 49 98 62 72 63 74\"\n2\n>>> sum(int(nb) for nb in ligne.split())\n3 555\n4 >>>\nEnsuite avec la fonction :\nmap()\n1\n>>> line = \"9 11 25 92 49 98 62 72 63 74\"\n2 >>> sum(map(int, line.split()))\n3\n555\nNe trouvez-vous pas que la version avec le générateur est plus lisible ?\n30\nComme proposé par Dan Bader , on peut chainer les générateurs :\n26.\nhttps://docs.python.org/3/library/itertools.html#itertools.cycle\n27. https://docs.python.org/3/library/itertools.html#itertools.repeat\n28.\nhttps://treyhunner.com/2019/06/loop-better-a-deeper-look-at-iteration-in-python/#How_iterators_\ncan_improve_your_code\n29.\nhttps://fr.wikipedia.org/wiki/Programmation_fonctionnelle\n30. https://dbader.org/blog/python-iterator-chains\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 337\nChapitre 26. Remarques complémentaires 26.5. Gestion des exceptions\n1\n>>> import math\n2 >>> ligne = \"9 11 25 92 49 98 62 72 63 74\"\n3\n>>> nombres = (int(nb) for nb in ligne.split())\n4 >>> inverses = (nb**-1 for nb in nombres)\n5\n>>> cos_inverses = (math.cos(nb) for nb in inverses)\n6 >>> sum(cos_inverse)\n7 9.988141056338993\nUne chose à noter dans cet exemple est que lorsqu’on crée un générateur à partir d’un autre générateur, le générateur\ninitial n’est pas déclenché. Par exemple, en Ligne 4 pour le générateur n’est pas encore déclenché,\ninverses nombres\nou en Ligne 5 pour le générateur n’est pas déclenché non plus. Tous les générateurs seront\ncos_inverses inverses\ndéclenchés en chaine lorsqu’on exécutera la Ligne 6.\nConseil\nEn écrivant un générateur par ligne, le code est bien lisible. Evitez une syntaxe en une ligne qui s’avérera illisible :\n(math.cos(nb) for nb in (nb**-1 for nb in (int(nb) for nb in ligne.split())))"
  },
  {
    "title": "Gestion des exceptions",
    "content": "31\nLes langages de programmation comme Python contiennent un système de gestion des exceptions . Qu’est-ce\n32\nqu’une exception ? Sur la page anglaise de Wikipedia , une exception est définie comme une anomalie de l’exécution d’un\nprogramme requérant une action spéciale, en général l’arrêt de l’exécution. Le plus souvent, une exception correspond à\nune erreur que Python rencontre lorsqu’il tente d’exécuter les lignes de code qu’on lui soumet. Par exemple, un problème\nde syntaxe, une variable ou objet qui prend une valeur aberrante (par exemple diviser par 0, parcourir une liste au-delà\ndu nombre d’éléments, etc.).\nLe système de gestion des exceptions évite que votre programme « plante » en prévoyant vous-même les sources\nd’erreurs éventuelles.\nVoici un exemple dans lequel on demande à l’utilisateur d’entrer un nombre entier, puis on aﬀiche ce nombre.\n1 >>> nb = int(input(\"Entrez un nombre entier : \"))\n2\nEntrez un nombre entier : 23\n3 >>> print(nb)\n4\n23\nLa fonction demande à l’utilisateur de saisir une chaîne de caractères. Cette chaîne de caractères est ensuite\ninput()\ntransformée en nombre entier avec la fonction .\nint()\nSi l’utilisateur ne rentre pas un nombre, voici ce qui se passe :\n1 >>> nb = int(input(\"Entrez un nombre entier : \"))\n2\nEntrez un nombre entier : ATCG\n3 Traceback (most recent call last):\n4 File \"<stdin>\", line 1, in <module>\n5\nValueError: invalid literal for int() with base 10: 'ATCG'\nL’erreur provient de la fonction qui n’a pas pu convertir la chaîne de caractères en nombre entier, ce\nint() \"ATCG\"\nqui est parfaitement normal. En termes plus techniques, on dira que « Python a levé une exception de type\nValueError\n». Eh oui il y a de nombreux types d’exceptions différents (voir plus bas) ! Le nom de l’exception apparaît toujours comme\nle premier mot de la dernière ligne du message d’erreur. Si nous lancions ces lignes de code sous forme de script (du style\n), cet exemple conduirait à l’arrêt de l’exécution du programme.\npython script.py\nLe jeu d’instructions / permet de tester l’exécution d’une commande et d’intervenir en cas de levée\ntry except\nd’exception.\n31.\nhttps://fr.wikipedia.org/wiki/Syst%C3%A8me_de_gestion_d%27exceptions\n32. https://en.wikipedia.org/wiki/Exception_handling\n338 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.5. Gestion des exceptions Chapitre 26. Remarques complémentaires\n1\n>>> try:\n2 ... nb = int(input(\"Entrez un nombre entier : \"))\n3\n... except:\n4 ... print(\"Vous n'avez pas entré un nombre entier !\")\n5\n...\n6 Entrez un nombre entier : ATCG\n7 Vous n'avez pas entré un nombre entier !\nDans cet exemple, l’exception levée par la fonction (qui ne peut pas convertir en nombre entier) est\nint() \"ATCG\"\ninterceptée et déclenche l’aﬀichage du message d’avertissement.\nOn peut ainsi redemander sans cesse un nombre entier à l’utilisateur, jusqu’à ce que celui-ci en rentre bien un.\n1\n>>> while True:\n2 ... try:\n3\n... nb = int(input(\"Entrez un nombre entier : \"))\n4 ... print(\"Le nombre est\", nb)\n5\n... break\n6 ... except:\n7\n... print(\"Vous n'avez pas entré un nombre entier !\")\n8 ... print(\"Essayez encore\")\n9\n...\n10 Entrez un nombre entier : ATCG\n11\nVous n'avez pas entré un nombre entier !\n12 Essayez encore\n13 Entrez un nombre entier : toto\n14\nVous n'avez pas entré un nombre entier !\n15 Essayez encore\n16\nEntrez un nombre entier : 3.2\n17 Vous n'avez pas entré un nombre entier !\n18\nEssayez encore\n19 Entrez un nombre entier : 55\n20\nLe nombre est 55\nNotez que dans cet exemple, l’instruction est une boucle infinie car la condition est toujours\nwhile True True\nvérifiée. L’arrêt de cette boucle est alors forcé par la commande lorsque l’utilisateur a effectivement entré un\nbreak\nnombre entier.\nLa gestion des exceptions est très utile dès lors que des données extérieures entrent dans un programme Python, que\nce soit directement par l’utilisateur (avec la fonction ) ou par des fichiers. Cela est fondamental si vous distribuez\ninput()\nvotre code à la communauté : si les utilisateurs ne connaissent pas Python, un message comme\nVous n'avez pas entré\nreste plus clair que .\nun nombre entier ! ValueError: invalid literal for int() with base 10: 'ATCG'\nVous pouvez par exemple vérifier qu’un fichier a bien été ouvert.\n1 >>> nom = \"toto.pdb\"\n2\n>>> try:\n3 ... with open(nom, \"r\") as fichier:\n4\n... for ligne in fichier:\n5 ... print(ligne)\n6\n... except:\n7 ... print(\"Impossible d'ouvrir le fichier\", nom)\nSi une erreur est déclenchée, c’est sans doute que le fichier n’existe pas à l’emplacement indiqué sur le disque ou que\nvous n’avez pas les droits pour le lire.\nIl est également possible de spécifier le type d’erreur à gérer. Le premier exemple que nous avons étudié peut s’écrire :\n1 >>> try:\n2\n... nb = int(input(\"Entrez un nombre entier : \"))\n3 ... except ValueError:\n4\n... print(\"Vous n'avez pas entré un nombre entier !\")\n5 ...\n6\nEntrez un nombre entier : ATCG\n7 Vous n'avez pas entré un nombre entier !\nIci, on intercepte une exception de type , ce qui correspond bien à un problème de conversion avec\nValueError\n.\nint()\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 339\nChapitre 26. Remarques complémentaires 26.5. Gestion des exceptions\nAttention, si vous précisez le type d’exception comme , le n’empêchera pas la\nValueError except ValueError\nlevée d’une autre exception.\n1 >>> try:\n2\n... nb = int(variable)\n3 ... except ValueError:\n4\n... print(\"Vous n'avez pas entré un nombre entier !\")\n5 ...\n6\nTraceback (most recent call last):\n7 File \"<stdin>\", line 2, in <module>\n8 NameError: name 'variable' is not defined. Did you mean: 'callable'?\nIci l’exception levée est de type , car n’existe pas. Alors que si vous mettez tout court,\nNameError variable except\ncela intercepte n’importe quelle exception.\n1 >>> try:\n2\n... nb = int(variable)\n3 ... except:\n4\n... print(\"Vous n'avez pas entré un nombre entier !\")\n5 ...\n6\nVous n'avez pas entré un nombre entier !\n7 >>>\nVous voyez qu’ici cela pose un nouveau problème : le message d’erreur ne correspond pas à l’exception levée !\nConseil\n•\nNous vous conseillons vivement de toujours préciser le type d’exception dans vos . Cela évite d’intercepter\nexcept\nune exception que vous n’aviez pas prévue. Il est possible d’intercepter plusieurs types d’exceptions en passant un\ntuple à , par exemple : .\nexcept except (Exception1, Exception2)\n•\nPar ailleurs, ne mettez pas trop de lignes dans le bloc du . Dans un tel cas, il peut être très pénible de trouver la\ntry\nligne qui a conduit à l’exécution du . Pire encore, il se peut que des lignes que vous aviez prévues ne soient\nexcept\npas exécutées ! Donc gardez des choses simples dans un premier temps, comme par exemple tester les conversions\nde type ou vérifier qu’un fichier existe bien et que vous pouvez l’ouvrir.\nIl existe de nombreux types d’exception comme , , , , etc. Vous pouvez\nRuntimeError TypeError NameError IOError\n33\naller voir la liste complète sur le site de Python. Nous avions déjà croisé des noms d’exception au chapitre 23 (Avoir\nla classe avec les objets) en regardant ce que contient le module .\nbuiltins\n1\n>>> import builtins\n2 >>> dir(builtins)\n3\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n4 [...]\n5\n'UserWarning', 'ValueError', 'Warning', 'ZeroDivisionError'\n6 [...]\nLeur présence dans le module signifie qu’elles font partie du langage lui même, au même titre que les\nbuiltins\nfonctions de base comme , , etc.\nrange() list()\nAvez-vous aussi remarqué que leur nom commence toujours par une majuscule et qu’il peut en contenir plusieurs à\nla façon CamelCase ? Si vous avez bien lu le chapitre 16 Bonnes pratiques en programmation Python, avez-vous deviné\npourquoi ? Et bien, c’est parce que les exceptions sont des classes. C’est très intéressant car il est ainsi possible\nd’utiliser l’héritage pour créer ses propres exceptions à partir d’exceptions pré-existantes. Nous ne développerons pas cet\naspect, mais en guise d’illustration, regardez ce que renvoit un de l’exception .\nhelp() OverflowError\n33. https://docs.python.org/fr/3.12/library/exceptions.html#exceptions.TypeError\n340 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.6. Shebang et /usr/bin/env python3 Chapitre 26. Remarques complémentaires\n1\n>>> help(OverflowError)\n2 [...]\n3\nclass OverflowError(ArithmeticError)\n4 | Result too large to be represented.\n5\n|\n6 | Method resolution order:\n7 | OverflowError\n8\n| ArithmeticError\n9 | Exception\n10\n| BaseException\n11 | object\nL’exception hérite de , c’est-à-dire qu’ a été conçue à partir de\nOverflowError ArithmeticError OverflowError\net en hérite de tous ses attributs.\nArithmeticError\nUn autre aspect très important que nous avons croisé au chapitre 24 Avoir plus la classe avec les objets est la\npossibilité de lever vous-même une exception avec le mot-clé . Nous avions vu le code suivant :\nraise\nif valeur < 0:\nraise ValueError(\"Z'avez déjà vu une masse négative ?\")\nLa ligne 2 lève une exception lorsque la variable est négative. L’instruction est bien\nValueError valeur raise\npratique lorsque vous souhaitez stopper l’exécution d’un programme si une variable ne se trouve pas dans le bon intervalle\nou ne contient pas la bonne valeur. Vous avez sans doute compris maintenant pourquoi on parlait de « levée » d’exception…\nEnfin, on peut aussi être très précis dans le message d’erreur. Observez la fonction qui, avec le\ndownload_page()\nmodule urllib, télécharge un fichier sur internet.\n1\nimport urllib.request\n2\n3\ndef download_page(address):\n4 error = \"\"\n5\npage = \"\"\n6 try:\n7\ndata = urllib.request.urlopen(address)\n8 page = data.read()\n9 except IOError as e:\n10\nif hasattr(e, 'reason'):\n11 error = \"Cannot reach web server: \" + str(e.reason)\n12\nif hasattr(e, 'code'):\n13 error = f\"Server failed {e.code:d}\"\n14\nreturn page, error\n15\n16\ndata, error = download_page(\"https://files.rcsb.org/download/1BTA.pdb\")\n17\n18\nif error:\n19 print(f\"Erreur rencontrée : {error}\")\n20\nelse:\n21 with open(\"proteine.pdb\", \"w\") as prot:\n22 prot.write(data.decode(\"utf-8\"))\n23 print(\"Protéine enregistrée\")\nLa variable est une instance de l’exception . Certains de ses attributs sont testés avec la fonction\ne IOError hasattr()\npour ainsi aﬀiner le message renvoyé (ici contenu dans la variable ).\nerror\nSi tout se passe bien, la page est téléchargée est stockée dans la variable , puis enregistrée sur le disque dur.\ndata"
  },
  {
    "title": "Shebang et /usr/bin/env python3",
    "content": "Lorsque l’on programme sur un système Unix (Mac OS X ou Linux par exemple), on peut exécuter directement un\nscript Python, sans appeler explicitement la commande .\npython\nPour cela, deux opérations sont nécessaires :\nÉtape 1. Préciser la localisation de l’interpréteur Python en indiquant dans la première ligne du script :\n1 #! /usr/bin/env python\nPar exemple, si le script test.py contenait :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 341\nChapitre 26. Remarques complémentaires 26.7. Passage d’arguments avec et\n*args **kwargs\n1\nprint(\"Hello World !\")\nil va alors contenir :\n1 #!/usr/bin/env python\n2\n3 print(\"Hello World !\")\nÉtape 2.. Rendre le script Python exécutable en lançant l’instruction :\n$ chmod +x test.py\nRemarque\nLa ligne n’est pas considérée comme un commentaire par Python, ni comme une ins-\n#! /usr/bin/env python\ntruction Python d’ailleurs . Cette ligne a une signification particulière pour le système d’exploitation Unix.\nPour exécuter le script, il suﬀit alors de taper son nom précédé des deux caractères ./ (afin de préciser au shell où se\ntrouve le script) :\n$ ./test.py\nHello World !\nDéfinition\n34\nLe shebang correspond aux caractères qui se trouvent au début de la première ligne du script .\n#! test\nLe shebang est suivi du chemin complet du programme qui interprète le script ou du programme qui sait où se\ntrouve l’interpréteur Python. Dans l’exemple précédent, c’est le programme qui indique où se trouve\n/usr/bin/env\nl’interpréteur Python."
  },
  {
    "title": "*args **kwargs",
    "content": "Avant de lire cette rubrique, nous vous conseillons de bien relire et maîtriser la rubrique Arguments positionnels et\narguments par mot-clé du chapitre 10 Fonctions.\nDans le chapitre 10, nous avons vu qu’il était nécessaire de passer à une fonction tous les arguments positionnels\ndéfinis dans celle-ci. Il existe toutefois une astuce permettant de passer un nombre arbitraire d’arguments positionnels :\n1\n>>> def fct(*args):\n2 ... print(args)\n3\n...\n4 >>> fct()\n5\n()\n6 >>> fct(1)\n7\n(1,)\n8 >>> fct(1, 2, 5, \"Python\")\n9 (1, 2, 5, 'Python')\n10\n>>> fct(z=1)\n11 Traceback (most recent call last):\n12\nFile \"<stdin>\", line 1, in <module>\n13 TypeError: fct() got an unexpected keyword argument 'z'\nL’utilisation de la syntaxe permet d’empaqueter tous les arguments positionnels dans un tuple unique\n*args args\nrécupéré au sein de la fonction. L’avantage est que nous pouvons passer autant d’arguments positionnels que l’on veut.\nToutefois, on s’aperçoit en ligne 10 que cette syntaxe ne fonctionne pas avec les arguments par mot-clé.\nIl existe un équivalent avec les arguments par mot-clé :\n34. http://fr.wikipedia.org/wiki/Shebang\n342 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.7. Passage d’arguments avec et Chapitre 26. Remarques complémentaires\n*args **kwargs\n1\n>>> def fct(**kwargs):\n2 ... print(kwargs)\n3\n...\n4 >>> fct()\n5\n{}\n6 >>> fct(z=1, gogo=\"toto\")\n7 {'gogo': 'toto', 'z': 1}\n8\n>>> fct(z=1, gogo=\"toto\", y=-67)\n9 {'y': -67, 'gogo': 'toto', 'z': 1}\n10\n>>> fct(1, 2)\n11 Traceback (most recent call last):\n12\nFile \"<stdin>\", line 1, in <module>\n13 TypeError: fct() takes 0 positional arguments but 2 were given\nLa syntaxe permet d’empaqueter l’ensemble des arguments par mot-clé, quel que soit leur nombre, dans\n**kwargs\nun dictionnaire unique récupéré dans la fonction. Les clés et valeurs de celui-ci sont les noms des arguments et les\nkwargs\nvaleurs passées à la fonction. Toutefois, on s’aperçoit en ligne 9 que cette syntaxe ne fonctionne pas avec les arguments\npositionnels.\nSi on attend un mélange d’arguments positionnels et par mot-clé, on peut utiliser et en même\n*args **kwargs\ntemps :\n1 >>> def fct(*args, **kwargs):\n2\n... print(args)\n3 ... print(kwargs)\n4\n...\n5 >>> fct()\n6\n()\n7 {}\n8\n>>> fct(1, 2)\n9 (1, 2)\n10\n{}\n11 >>> fct(z=1, y=2)\n12\n()\n13 {'y': 2, 'z': 1}\n14 >>> fct(1, 2, 3, z=1, y=2)\n15\n(1, 2, 3)\n16 {'y': 2, 'z': 1}\nDeux contraintes sont toutefois à respecter. Il faut toujours :\n•\nmettre avant dans la définition de la fonction ;\n*args **kwargs\n•\npasser les arguments positionnels avant ceux par mot-clé lors de l’appel de la fonction.\nIl est possible de combiner des arguments positionnels avec et des arguments par mot-clé avec , par\n*args **kwargs\nexemple :\ndef fct(a, b, *args, **kwargs):\nDans un tel cas, il faudra obligatoirement passer les deux arguments et à la fonction, ensuite on pourra mettre\na b\nun nombre arbitraire d’arguments positionnels (récupérés dans le tuple ), puis un nombre arbitraire d’arguments par\nargs\nmot-clé (récupérés dans le dictionnaire ).\nkwargs\nConseil\nLes noms et sont des conventions en Python, ils rappellent les mots arguments et keyword argu-\n*args **kwargs\nments. Bien qu’on puisse mettre ce que l’on veut, nous vous conseillons de respecter ces conventions pour faciliter la\nlecture de votre code par d’autres personnes.\nL’utilisation de la syntaxe et est très classique dans le module Fenêtres graphiques et Tkinter\n*args **kwargs\nprésenté dans le chapitre 25 (en ligne).\nIl est possible d’utiliser ce mécanisme d’empaquetage / désempaquetage (packing / unpacking) dans l’autre sens :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 343\nChapitre 26. Remarques complémentaires 26.8. Décorateurs\n1\n>>> def fct(a, b, c):\n2 ... print(a,b,c)\n3\n...\n4 >>> t = (-5,6,7)\n5\n>>>\n6 >>> fct(*t)\n7 -5 6 7\nAvec la syntaxe on désempaquette le tuple à la volée lors de l’appel à la fonction. Cela est aussi possible avec un\n*t\ndictionnaire :\n1\n>>> def fct(x, y, z):\n2 ... print(x, y, z)\n3\n...\n4 >>> dico = {'x': -1, 'y': -2, 'z': -3}\n5\n>>> fct(**dico)\n6 -1 -2 -3\nAttention toutefois à bien respecter deux choses :\n•\nla concordance entre le nom des clés du dictionnaire et le nom des arguments dans la fonction (sinon cela renvoie\nune erreur) ;\n•\nl’utilisation d’une double étoile pour désempaqueter les valeurs du dictionnaire (si vous utilisez une seule étoile,\nPython désempaquettera les clés !).\nCe mécanisme de désempaquetage est aussi utilisable avec les objets zip, on parle de zip unpacking. Souvenons-nous,\nun objet zip permettait d’assembler plusieurs listes, éléments par éléments (voir Chapitre 12 Plus sur les listes) :\n1\n>>> animaux = [\"poulain\", \"renard\", \"python\"]\n2 >>> couleurs = [\"alezan\", \"roux\", \"vert\"]\n3\n>>> zip(range(3), animaux, couleurs)\n4 <zip object at 0x7f333febc880>\n5\n>>> triplets = list(zip(range(3), animaux, couleurs))\n6 >>> triplets\n7\n[(0, 'poulain', 'alezan'), (1, 'renard', 'roux'), (2, 'python', 'vert')]\nLignes 1 à 4. On crée un objet zip avec trois objets de trois éléments.\nLignes 5 à 7. Cet objet zip en conjonction avec la fonction nous permet d’associer les éléments par ordre\nlist()\nd’apparition (tous les éléments à la position 1 se retrouve ensemble, idem pour les positions 2 et 3). Au final, l’objet\nest une liste de tuples de trois éléments.\ntriplets\nL’opérateur en combinaison avec la fonction zip va nous permettre de désempaqueter pour récupérer\n* triplets\nles listes initiales ( , et ) :\nrange(3) animaux couleurs\n1\n>>> zip(*triplets)\n2 <zip object at 0x7f333fd44980>\n3\n>>> list(zip(*triplets))\n4 [(0, 1, 2), ('poulain', 'renard', 'python'), ('alezan', 'roux', 'vert')]\nBien sûr, on peut l’utiliser l’affectation multiple :\n1\n>>> numéros2, animaux2, couleurs2 = zip(*triplets)\n2 >>> numéros2\n3\n(0, 1, 2)\n4 >>> animaux2\n5\n('poulain', 'renard', 'python')\n6 >>> couleurs2\n7\n('alezan', 'roux', 'vert')\nAu final, on récupère des tuples au lieu des listes initiales. Mais à ce stade, vous devriez être capable de les retransformer\nen liste ;-)."
  },
  {
    "title": "Décorateurs",
    "content": "Dans le chapitre 24, nous avons rencontré la notion de décorateur pour déclarer des objets de type property. Cela\npermettait de rendre des méthodes accessibles comme des attributs (décorateur ), et plus généralement de\n@property\n344 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.8. Décorateurs Chapitre 26. Remarques complémentaires\ncontrôler l’accès, la modification et la destruction d’attributs (décorateurs et\n@nom_attribut.setter @nom_attribut\n). Il existe d’autres décorateurs prédéfinis en Python (e.g. , , etc.). Nous allons\n.deleter @staticmethod @classmethod\nvoir dans cette section comment on crée ses propres décorateurs et les mécanismes sous-jacents. Nous vous conseillons\nde bien relire commment fonctionne les fonctions de rappel, ou fonctions callback (chapitre 25 Tkinter).\nDéfinition\nUn décorateur est une fonction qui modifie le comportement d’une autre fonction.\nCeci étant dit, comme cela fonctionne-t-il ? Commençons par une fonction simple qui aﬀiche de la nourriture :\n1 def imprime_victuaille():\n2\nprint(\"tomate / mozza\")\nOn souhaite améliorer cette fonction et transformer cette victuaille en sandwich, en aﬀichant une tranche de pain avant\net après. La stratégie va être de créer une fonction spéciale, qu’on appelle décorateur, modifiant\nimprime_victuaille\n.\n()\n1\ndef transforme_en_sandwich(fonction_a_decorer):\n2 def emballage():\n3\nprint(\"Pain\")\n4 fonction_a_decorer()\n5\nprint(\"Pain\")\n6 return emballage\nLa fonction est notre décorateur, elle prend en argument la fonction que l’on sou-\ntransforme_en_sandwich()\nhaite décorer sous forme de callback (donc sans les parenthèses). On voit qu’à l’intérieur, on définit une sous-fonction\nqui va littéralement « emballer » (wrap) notre fonction à décorer, c’est-à-dire, effectuer une action avant\nemballage()\net après l’appel de la fonction à décorer. Enfin, le décorateur renvoie cette sous-fonction sous forme de\nemballage\ncallback. Pour que le décorateur soit actif, il faudra « transformer » la fonction à décorer avec notre fonction décoratrice :\n1 imprime_victuaille = transforme_en_sandwich(imprime_victuaille)\nVoici le code complet implémentant la fonction décorée :\nimprime_victuaille()\n1\ndef transforme_en_sandwich(fonction_a_decorer):\n2 def emballage():\n3 print(\"Pain\")\n4\nfonction_a_decorer()\n5 print(\"Pain\")\n6\nreturn emballage\n7\n8\ndef imprime_victuaille():\n9 print(\"tomate/ mozza\")\n10\n11 if __name__ == \"__main__\":\n12\nprint(\"Fonction non décorée:\")\n13 imprime_victuaille()\n14\nprint()\n15 print(\"Fonction décorée:\")\n16\nimprime_victuaille = transforme_en_sandwich(imprime_victuaille)\n17 imprime_victuaille()\nAu final l’idée est d’appeler la fonction décoratrice plutôt que la fonction elle-même.\nimprime_victuaille()\nRegardons ce que donne l’exécution de la fonction avant et après décoration :\nFonction non décorée:\ntomate/ mozza\nFonction décorée:\nPain\ntomate/ mozza\nPain\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 345\nChapitre 26. Remarques complémentaires 26.8. Décorateurs\nLe premier appel en ligne 13 exécute la fonction simple, alors que le second en ligne 17 exécute la fonction décorée.\nCette construction peut sembler ardue et diﬀicile à comprendre. Heureusement, Python a une notation en « sucre\nsyntaxique » (syntactic sugar) qui en facilite la lecture. Celle-ci utilise le symbole :\n@\n1 def transforme_en_sandwich(fonction_a_decorer):\n2\ndef emballage():\n3 print(\"Pain\")\n4\nfonction_a_decorer()\n5 print(\"Pain\")\n6\nreturn emballage\n7\n8\n@transforme_en_sandwich\n9 def imprime_victuaille():\n10\nprint(\"tomate / mozza\")\n11\n12\nif __name__ == \"__main__\":\n13 imprime_victuaille()\nLa ligne 8 transforme irrémédiablement la fonction en fonction décorée. Cela parait déjà\nimprime_victuaille()\nun peu plus lisible. L’exécution donnera bien sûr :\nPain\ntomate / mozza\nPain\nAu final, la notation :\n1 @decorator\n2\ndef fct():\n3 [...]\nest équivalente à :\n1\nfct = decorator(fct)\nCela fonctionne avec n’importe quelle fonction prenant en argument une autre fonction.\nConseil\nNous vous conseillons bien sûr d’utiliser systématiquement la notation qui est plus lisible et intuitive.\n@decorator\nSi tout cela vous semble ardu (on vous comprend…), vous devez vous dire « pourquoi utiliser une construction aussi\ncomplexe ? ». Et bien, c’est tout simplement parce qu’un décorateur est ré-utilisable dans n’importe quelle fonction. Si\non reprend la même fonction décoratrice que ci-dessus :\n1\n@transforme_en_sandwich\n2 def imprime_victuaille1():\n3\nprint(\"tomate / mozza\")\n4\n5 @transforme_en_sandwich\n6 def imprime_victuaille2():\n7 print(\"jambon / fromage\")\n8\n9 if __name__ == \"__main__\":\n10\nimprime_victuaille1()\n11 print()\n12\nimprime_victuaille2()\nOn a donc un décorateur permettant de transformer en sandwich n’importe quelle fonction imprimant une victuaille !\nCeci renverra :\n346 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n26.9. Un peu de transformée de Fourier avec NumPy Chapitre 26. Remarques complémentaires\nPain\ntomate / mozza\nPain\nPain\njambon / fromage\nPain\nUn exemple plus concret de décorateur pourrait être la mesure du temps d’exécution d’une fonction :\nimport time\ndef mesure_temps(fonction_a_decorer):\ndef emballage():\ntemps1 = time.time()\nfonction_a_decorer()\ntemps2 = time.time()\nprint(f\"Le temps d'éxécution de {fonction_a_decorer.__name__} est \"\nf\"{temps2 - temps1} s\")\nreturn emballage\nEn ligne 8, l’attribut renvoie le nom de la fonction sous forme de chaîne de caractères. Dans cet exemple,\n.__name__\nle décorateur mis devant n’importe quelle fonction aﬀichera systématiquement le temps d’exécution de\n@mesure_temps\ncelle-ci.\nPour finir, si on revient sur le décorateur vu dans le chapitre 24 Avoir plus la classe avec les objets, nous\n@property\navions vu également qu’il existait une fonction . Donc pour les décorateurs pré-existants que nous avons\nproperty()\nabordés dans le chapitre 24, il existe des fonctions équivalentes. Comme dans notre exemple, la notation\n@decorateur\nva finalement appeler la fonction décoratrice. Donc derrière une notation , il existe toujours une fonction\n@quelquechose\nremplissant ce rôle de décorateur.\nquelquechose()\nPour aller plus loin\n35\nPour aller plus loin, vous pouvez consulter ce très bon article sur le site RealPython. Il y est expliqué en outre\ncomment on peut gérer le passage d’arguments quand on utilise des décorateurs, ainsi que l’utilisation de décorateurs\nmultiples."
  },
  {
    "title": "Un peu de transformée de Fourier avec NumPy",
    "content": "La transformée de Fourier est très utilisée pour l’analyse de signaux, notamment lorsqu’on souhaite extraire des\npériodicités au sein d’un signal bruité. Le module NumPy possède la fonction (dans le sous-module fft) permettant\nfft()\nde calculer des transformées de Fourier.\nVoici un petit exemple sur la fonction cosinus de laquelle on souhaite extraire la période à l’aide de la fonction :\nfft()\n1 import numpy as np\n2\n3 debut = -2 * np.pi\n4\nfin = 2 * np.pi\n5 pas = 0.1\n6\nx = np.arange(debut,fin,pas)\n7 y = np.cos(x)\n8\n9\nTF = np.fft.fft(y)\n10 ABSTF = np.abs(TF)\n11\npas_xABSTF = 1/(fin-debut)\n12 x_ABSTF = np.arange(0,pas_xABSTF * len(ABSTF),pas_xABSTF)\nPlusieurs commentaires sur cet exemple :\nLigne 1. On charge le module NumPy avec le nom raccourci .\nnp\n− π π\nLignes 3 à 6. On définit l’intervalle (de 2 à 2 radians) pour les valeurs en abscisse ainsi que le pas (0,1 radians).\n35. https://realpython.com/primer-on-python-decorators/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 347\nChapitre 26. Remarques complémentaires 26.10. Sauvegardez votre historique de commandes\nLignes 7. On calcule directement les valeurs en ordonnées avec la fonction cosinus du module NumPy. On constate\nici que NumPy redéfinit certaines fonctions ou constantes mathématiques de base, comme , ou (valeur\npi cos() abs()\nabsolue, ou module d’un nombre complexe). Ces fonctions sont directement utilisables avec un objet array.\nLigne 9. On calcule la transformée de Fourier avec la fonction qui renvoie un vecteur (objet array à une\nfft()\ndimension) de nombres complexes. Eh oui, le module NumPy gère aussi les nombres complexes !\nLigne 10. On extrait le module du résultat précédent avec la fonction .\nabs()\n−\n1\nLigne 11. La variable représente l’abscisse du spectre (en radian ).\nx_ABSTFL\n−\n1\nLigne 12. La variable contient le spectre lui même. L’analyse de ce dernier nous donne un pic à 0,15 radian ,\nABSTF\nπ\nce qui correspond bien à 2 (c’est plutôt bon signe de retrouver ce résultat)."
  },
  {
    "title": "Sauvegardez votre historique de commandes",
    "content": "Vous pouvez sauvegarder l’historique des commandes utilisées dans l’interpréteur Python avec le module .\nreadline\n1\n>>> print(\"hello\")\n2 hello\n3 >>> a = 22\n4\n>>> a = a + 11\n5 >>> print(a)\n6\n33\n7 >>> import readline\n8\n>>> readline.write_history_file()\nQuittez Python. L’historique de toutes vos commandes est dans votre répertoire personnel, dans le fichier .\n.history\nRelancez l’interpréteur Python.\n1 >>> import readline\n2 >>> readline.read_history_file()\nVous pouvez accéder aux commandes de la session précédente avec la flèche du haut de votre clavier. D’abord les\ncommandes et de la session actuelle, puis ,\nreadline.read_history_file() import readline print(a) a = a +\n, …\n11 a = 22\n348 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Mini-projets",
    "content": "Dans ce chapitre, nous vous proposons quelques scénarios pour développer vos compétences en Python et mettre en\nœuvre les concepts que vous avez rencontrés dans les chapitres précédents."
  },
  {
    "title": "Description des projets",
    "content": "27.1.1 Mots anglais dans le protéome humain\nL’objectif de ce premier projet est de découvrir si des mots anglais peuvent se retrouver dans les séquences du protéome\nhumain, c’est-à-dire dans les séquences de l’ensemble des protéines humaines.\nVous aurez à votre disposition :\n•\n1\nLe fichier , qui contient les 3 000 mots anglais les plus fréquents, à raison d’1 mot\nenglish-common-words.txt\npar ligne.\n• 2\nLe fichier qui contient le protéome humain sous la forme de séquences au format\nhuman-proteome.fasta\nFASTA. Attention, ce fichier est assez gros. Ce fichier provient de la banque de données UniProt à partir de cette\n3\npage .\nConseil\nDes explications sur le format FASTA et des exemples de code sont fournis dans l’annexe A Quelques formats de\ndonnées en biologie.\n27.1.2 Genbank2fasta\nCe projet consiste à écrire un convertisseur de fichier, du format GenBank au format FASTA.\nPour cela, nous allons utiliser le fichier GenBank du chromosome I de la levure de boulanger Saccharomyces cerevisiae.\nVous pouvez télécharger ce fichier :\n• 4\nsoit via le lien sur le site du cours ;\nNC_001133.gbk\n1.\nhttps://python.sdv.u-paris.fr/data-files/english-common-words.txt\n2. https://python.sdv.u-paris.fr/data-files/human-proteome.fasta\n3.\nhttps://www.uniprot.org/help/human_proteome\n4. https://python.sdv.u-paris.fr/data-files/NC_001133.gbk\n349\nChapitre 27. Mini-projets 27.1. Description des projets\n• 5\nsoit directement sur la page de Saccharomyces cerevisiae S288c chromosome I, complete sequence sur le site du\nNCBI, puis en cliquant sur Send to, puis Complete Record, puis Choose Destination : File, puis Format : GenBank\n(full) et enfin sur le bouton Create File.\nVous trouverez des explications sur les formats FASTA et GenBank ainsi que des exemples de code dans l’annexe A\nQuelques formats de données en biologie.\nVous pouvez réaliser ce projet sans ou avec des expressions régulières (abordées dans le chapitre 17).\n27.1.3 Simulation d’un pendule\n6\nOn se propose de réaliser une simulation d’un pendule simple en Tkinter. Un pendule simple est représenté par\nune masse ponctuelle (la boule du pendule) reliée à un pivot immobile par une tige rigide et sans masse. On néglige les\neffets de frottement et on considère le champ gravitationnel comme uniforme. Le mouvement du pendule sera calculé en\nrésolvant numériquement l’équation différentielle suivante :\nθ\n2\nd g\n− ∗ θ\na (t) = (t) = sin( (t))\nθ\n2\ndt l\nθ\noù représente l’angle entre la verticale et la tige du pendule, a l’accélération angulaire, g la gravité, et l la longueur\nθ\n7\nde la tige (note : pour la dérivation d’une telle équation vous pouvez consulter la page wikipedia ou l’accompagnement\npas à pas, cf. la rubrique suivante).\nθ\n8\nPour trouver la valeur de en fonction du temps, on pourra utiliser la méthode semi-implicite d’Euler de résolution\n−g × θ\nd’équation différentielle. La formule ci-dessus donne l’accélération angulaire au temps t : a (t) = sin( (t)). À\nθ\nl\nδ × δ\npartir de celle-ci, la méthode propose le calcul de la vitesse angulaire au pas suivant : ( + ) = ( ) + ( )\nv t t v t a t t\nθ θ θ\nδ δ\n(où t représente le pas de temps entre deux étapes successives de la simulation). Enfin, cette vitesse v (t + t) donne\nθ\nθ θ δ θ δ ×δ δ\nl’angle au pas suivant : (t + t) = (t)+v (t + t) t. On prendra un pas de temps t = 0.05 s, une accélération\nθ\n−\n2\ngravitationnelle g = 9.8 m.s et une longueur de tige de l = 1 m.\nFigure 27.1 – Application pendule.\nPour la visualisation, vous pourrez utiliser le widget canvas du module Tkinter (voir le chapitre 25 Fenêtres graphiques\net Tkinter (en ligne), rubrique Un canvas animé dans une classe). On cherche à obtenir un résultat comme montré dans\nla figure 27.1.\n5.\nhttps://www.ncbi.nlm.nih.gov/nuccore/NC_001133\n6. https://fr.wikipedia.org/wiki/Pendule_simple\n7.\nhttps://en.wikipedia.org/wiki/Pendulum_(mathematics)#math_Eq._1\n8. https://en.wikipedia.org/wiki/Euler_method\n350 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.2. Accompagnement pas à pas Chapitre 27. Mini-projets\nθ\nNous vous conseillons de procéder d’abord à la mise en place du simulateur physique (c’est-à-dire obtenir en fonction\ndu temps ou du pas de simulation). Faites par exemple un premier script Python qui produit un fichier à deux colonnes\nθ\n(temps et valeur de ). Une fois que cela fonctionne bien, il vous faudra construire l’interface Tkinter et l’animer. Vous\npouvez ajouter un bouton pour démarrer / stopper le pendule et une règle pour modifier sa position initiale.\nθ\nN’oubliez pas, il faudra mettre dans votre programme final une fonction qui convertit l’angle en coordonnées\ncartésiennes x et y dans le plan du canvas. Faites également attention au système de coordonnées du canvas où les\nordonnées sont inversées par rapport à un repère mathématique. Pour ces deux aspects, reportez-vous à l’exercice\nPolygone de Sierpinski du chapitre 25 Fenêtres graphiques et Tkinter (en ligne)."
  },
  {
    "title": "Accompagnement pas à pas",
    "content": "Vous trouverez ci-après les différentes étapes pour réaliser les mini-projets proposés. Prenez le temps de bien com-\nprendre une étape avant de passer à la suivante.\n27.2.1 Mots anglais dans le protéome humain\nL’objectif de ce premier projet est de découvrir si des mots anglais peuvent se retrouver dans les séquences du protéome\nhumain, c’est-à-dire dans les séquences de l’ensemble des protéines humaines.\n27.2.1.1 Composition aminée\nDans un premier temps, composez 5 mots anglais avec les 20 acides aminés.\n27.2.1.2 Des mots\n9\nTéléchargez le fichier english-common-words.txt . Ce fichier contient les 3000 mots anglais les plus fréquents, à raison\nd’1 mot par ligne.\nCréez un script et écrivez la fonction qui va lire les mots contenus dans le\nwords_in_proteome.py read_words()\nfichier dont le nom est fourni en argument du script et renvoyer une liste contenant les mots convertis en majuscule et\ncomposés de 3 caractères ou plus.\nDans le programme principal, aﬀichez le nombre de mots sélectionnés.\n27.2.1.3 Des protéines\n10\nTéléchargez maintenant le fichier human-proteome.fasta . Attention, ce fichier est assez gros. Ce fichier provient de\n11\nla banque de données UniProt à partir de cette page .\nVoici les premières lignes de ce fichier ( indique une coupure que nous avons faite) :\n[...]\n>sp|O95139|NDUB6_HUMAN NADH dehydrogenase [ubiquinone] 1 beta [...]\nMTGYTPDEKLRLQQLRELRRRWLKDQELSPREPVLPPQKMGPMEKFWNKFLENKSPWRKM\nVHGVYKKSIFVFTHVLVPVWIIHYYMKYHVSEKPYGIVEKKSRIFPGDTILETGEVIPPM\nKEFPDQHH\n>sp|O75438|NDUB1_HUMAN NADH dehydrogenase [ubiquinone] 1 beta [...]\nMVNLLQIVRDHWVHVLVPMGFVIGCYLDRKSDERLTAFRNKSMLFKRELQPSEEVTWK\n>sp|Q8N4C6|NIN_HUMAN Ninein OS=Homo sapiens OX=9606 GN=NIN PE=1 SV=4\nMDEVEQDQHEARLKELFDSFDTTGTGSLGQEELTDLCHMLSLEEVAPVLQQTLLQDNLLG\nRVHFDQFKEALILILSRTLSNEEHFQEPDCSLEAQPKYVRGGKRYGRRSLPEFQESVEEF\nPEVTVIEPLDEEARPSHIPAGDCSEHWKTQRSEEYEAEGQLRFWNPDDLNASQSGSSPPQ\nToujours dans le script , écrivez la fonction qui va lire le protéome\nwords_in_proteome.py read_sequences()\ndans le fichier dont le nom est fourni en second argument du script. Cette fonction va renvoyer un dictionnaire dont les\nclefs sont les identifiants des protéines (par exemple, , , ) et dont les valeurs associées sont les\nO95139 O75438 Q8N4C6\nséquences.\nDans le programme principal, aﬀichez le nombre de séquences lues. À des fins de test, aﬀichez également la séquence\nassociée à la protéine .\nO95139\n9. https://python.sdv.u-paris.fr/data-files/english-common-words.txt\n10.\nhttps://python.sdv.u-paris.fr/data-files/human-proteome.fasta\n11. https://www.uniprot.org/help/human_proteome\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 351\nChapitre 27. Mini-projets 27.2. Accompagnement pas à pas\n27.2.1.4 À la pêche aux mots\nÉcrivez maintenant la fonction qui prend en argument la liste de mots et le dic-\nsearch_words_in_proteome()\ntionnaire contenant les séquences des protéines et qui va compter le nombre de séquences dans lesquelles un mot est\nprésent. Cette fonction renverra un dictionnaire dont les clefs sont les mots et les valeurs le nombre de séquences qui\ncontiennent ces mots. La fonction aﬀichera également le message suivant pour les mots trouvés dans le protéome :\nACCESS found in 1 sequences\nACID found in 38 sequences\nACT found in 805 sequences\n[...]\nCette étape prend quelques minutes. Soyez patient.\n27.2.1.5 Et le mot le plus fréquent est…\nPour terminer, écrivez maintenant la fonction qui prend en argument le dictionnaire\nfind_most_frequent_word()\nrenvoyé par la précédente fonction et qui aﬀiche le mot trouvé dans le plus de protéines,\nsearch_words_in_proteome()\nainsi que le nombre de séquences dans lesquelles il a été trouvé, sous la forme :\n=> xxx found in yyy sequences\nQuel est ce mot ?\nQuel pourcentage des séquences du protéome contiennent ce mot ?\n27.2.1.6 Pour être plus complet\nJusqu’à présent, nous avions déterminé, pour chaque mot, le nombre de séquences dans lesquelles il apparaissait.\nNous pourrions aller plus loin et calculer aussi le nombre de fois que chaque mot apparaît dans les séquences.\nPour cela modifier la fonction de façon à compter le nombre d’occurrences d’un\nsearch_words_in_proteome()\nmot dans les séquences. La méthode vous sera utile.\n.count()\nDéterminez alors quel mot est le plus fréquent dans le protéome humain.\n27.2.2 genbank2fasta (sans expression régulière)\nCe projet consiste à écrire un convertisseur de fichier, du format GenBank au format FASTA. L’annexe A Quelques\nformats de données en biologie rappelle les caractéristiques de ces deux formats de fichiers.\nLe jeu de données avec lequel nous allons travailler est le fichier GenBank du chromosome I de la levure du boulanger\nSaccharomyces cerevisiae. Les indications pour le télécharger sont indiqués dans la description du projet.\nDans cette rubrique, nous allons réaliser ce projet sans expression régulière.\n27.2.2.1 Lecture du fichier\nCréez un script et créez la fonction qui prend en argument le nom du fichier et\ngenbank2fasta.py lit_fichier()\nqui renvoie le contenu du fichier sous forme d’une liste de lignes, chaque ligne étant elle-même une chaîne de caractères.\nTestez cette fonction avec le fichier GenBank et aﬀichez le nombre de lignes lues.\nNC_001133.gbk\n27.2.2.2 Extraction du nom de l’organisme\nDans le même script, ajoutez la fonction qui prend en argument le contenu du fichier\nextrait_organisme()\nprécédemment obtenu avec la fonction (sous la forme d’une liste de lignes) et qui renvoie le nom de\nlit_fichier()\nl’organisme. Pour récupérer la bonne ligne vous pourrez tester si les premiers caractères de la ligne contiennent le mot-clé\n.\nORGANISM\nTestez cette fonction avec le fichier GenBank et aﬀichez le nom de l’organisme.\nNC_001133.gbk\n352 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.2. Accompagnement pas à pas Chapitre 27. Mini-projets\n27.2.2.3 Recherche des gènes\nDans le fichier GenBank, les gènes sens sont notés de cette manière :\ngene 58..272\nou\ngene <2480..>2707\net les gènes antisens (ou encore complémentaires) de cette façon :\ngene complement(55979..56935)\nou\ngene complement(<13363..>13743)\nLes valeurs numériques séparées par indiquent la position du gène dans le génome (numéro de la première base,\n..\nnuméro de la dernière base).\nRemarque\nLe symbole indique un gène partiel sur l’extrémité 5’, c’est-à-dire que le codon START correspondant est incomplet.\n<\nRespectivement, le symbole désigne un gène partiel sur l’extrémité 3’, c’est-à-dire que le codon STOP correspondant\n>\n12\nest incomplet. Pour plus de détails, consultez la documentation du NCBI sur les délimitations des gènes . Nous vous\nproposons ici d’ignorer ces symboles et .\n> <\nRepérez ces différents gènes dans le fichier . Pour récupérer ces lignes de gènes il faut tester si la\nNC_001133.gbk\nligne commence par\ngene\n(c’est-à-dire 5 espaces, suivi du mot , suivi de 12 espaces). Pour savoir s’il s’agit d’un gène sur le brin direct ou\ngene\ncomplémentaire, il faut tester la présence du mot dans la ligne lue.\ncomplement\nEnsuite si vous souhaitez récupérer la position de début et de fin de gène, nous vous conseillons d’utiliser la fonction\net de ne garder que les chiffres et les Par exemple\nreplace() .\ngene <2480..>2707\nsera transformé en\n2480..2707\nEnfin, avec la méthode vous pourrez facilement récupérer les deux entiers de début et de fin de gène.\n.split()\nDans le même script , ajoutez la fonction qui prend en argument le contenu\ngenbank2fasta.py recherche_genes()\ndu fichier (sous la forme d’une liste de lignes) et qui renvoie la liste des gènes.\nChaque gène sera lui-même une liste contenant le numéro de la première base, le numéro de la dernière base et une\nchaîne de caractère pour un gène sens et pour un gène antisens.\n\"sens\" \"antisens\"\nTestez cette fonction avec le fichier GenBank et aﬀichez le nombre de gènes trouvés, ainsi que le\nNC_001133.gbk\nnombre de gènes sens et antisens.\n27.2.2.4 Extraction de la séquence nucléique du génome\nLa taille du génome est indiqué sur la première ligne d’un fichier GenBank. Trouvez la taille du génome stocké dans\nle fichier .\nNC_001133.gbk\nDans un fichier GenBank, la séquence du génome se trouve entre les lignes\nORIGIN\n12. https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html#BaseSpanB\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 353\nChapitre 27. Mini-projets 27.2. Accompagnement pas à pas\net\n//\nTrouvez dans le fichier la première et dernière ligne de la séquence du génome.\nNC_001133.gbk\nPour récupérer les lignes contenant la séquence, nous vous proposons d’utiliser un algorithme avec un drapeau\n(qui vaudra ou ). Voici l’algorithme proposé en pseudo-code :\nis_dnaseq True False\nis_dnaseq <- False\nLire chaque ligne du fichier gbk\nsi la ligne contient \"//\"\nis_dnaseq <- False\nsi is_dnaseq vaut True\naccumuler la séquence\nsi la ligne contient \"ORIGIN\"\nis_dnaseq <- True\nAu début ce drapeau aura la valeur . Ensuite, quand il se mettra à True, on pourra lire les lignes contenant la\nFalse\nséquence, puis quand il se remettra à False on arrêtera.\nUne fois la séquence récupérée, il suﬀira d’éliminer les chiffres, retours chariots et autres espaces (Conseil : calculer\nla longueur de la séquence et comparer la à celle indiquée dans le fichier gbk).\nToujours dans le même script , ajoutez la fonction qui prend en argument\ngenbank2fasta.py extrait_sequence()\nle contenu du fichier (sous la forme de liste de lignes) et qui renvoie la séquence nucléique du génome (dans une chaîne\nde caractères). La séquence ne devra pas contenir d’espaces, ni de chiffres ni de retours chariots.\nTestez cette fonction avec le fichier GenBank et aﬀichez le nombre de bases de la séquence extraite.\nNC_001133.gbk\nVérifiez que vous n’avez pas fait d’erreur en comparant la taille de la séquence extraite avec celle que vous avez trouvée\ndans le fichier GenBank.\n27.2.2.5 Construction d’une séquence complémentaire inverse\nToujours dans le même script, ajoutez la fonction qui prend en argument une séquence\nconstruit_comp_inverse()\nd’ADN sous forme de chaîne de caractères et qui renvoie la séquence complémentaire inverse (également sous la forme\nd’une chaîne de caractères).\nOn rappelle que construire la séquence complémentaire inverse d’une séquence d’ADN consiste à :\n•\nPrendre la séquence complémentaire. C’est-à-dire remplacer la base par la base , par , par et par .\na t t a c g g c\n•\nPrendre l’inverse. C’est-à-dire que la première base de la séquence complémentaire devient la dernière base et\nréciproquement, la dernière base devient la première.\nPour vous faciliter le travail, ne travaillez que sur des séquences en minuscule.\nTestez cette fonction avec les séquences , et .\natcg AATTCCGG gattaca\n27.2.2.6 Écriture d’un fichier FASTA\nToujours dans le même script, ajoutez la fonction qui prend en argument un nom de fichier (sous\necrit_fasta()\nforme de chaîne de caractères), un commentaire (sous forme de chaîne de caractères) et une séquence (sous forme de\nchaîne de caractères) et qui écrit un fichier FASTA. La séquence sera à écrire sur des lignes ne dépassant pas 80 caractères.\nPour rappel, un fichier FASTA suit le format suivant :\n>commentaire\nsequence sur une ligne de 80 caractères maxi\nsuite de la séquence .......................\nsuite de la séquence .......................\n...\nTestez cette fonction avec :\n•\nnom de fichier :\ntest.fasta\n•\ncommentaire :\nmon commentaire\n•\nséquence :\natcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatc\n354 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.2. Accompagnement pas à pas Chapitre 27. Mini-projets\n27.2.2.7 Extraction des gènes\nToujours dans le même script, ajoutez la fonction qui prend en argument la liste des gènes, la\nextrait_genes()\nséquence nucléotidique complète (sous forme d’une chaîne de caractères) et le nom de l’organisme (sous forme d’une\nchaîne de caractères) et qui pour chaque gène :\n•\nextrait la séquence du gène dans la séquence complète ;\n•\nprend la séquence complémentaire inverse (avec la fonction si le gène est antisens ;\nconstruit_comp_inverse()\n•\nenregistre le gène dans un fichier au format FASTA (avec la fonction ) ;\necrit_fasta()\n•\naﬀiche à l’écran le numéro du gène et le nom du fichier FASTA créé.\nLa première ligne des fichiers FASTA sera de la forme :\n>nom-organisme|numéro-du-gène|début|fin|sens ou antisens\nLe numéro du gène sera un numéro consécutif depuis le premier gène jusqu’au dernier. Il n’y aura pas de différence\nde numérotation entre les gènes sens et les gènes antisens.\nTestez cette fonction avec le fichier GenBank .\nNC_001133.gbk\n27.2.2.8 Assemblage du script final\nPour terminer, modifiez le script de façon à ce que le fichier GenBank à analyser (dans cet\ngenbank2fasta.py\nexemple ), soit entré comme argument du script.\nNC_001133.gbk\nVous aﬀicherez un message d’erreur si :\n•\nle script est utilisé sans argument,\ngenbank2fasta.py\n•\nle fichier fourni en argument n’existe pas.\nPour vous aider, n’hésitez pas à jeter un œil aux descriptions des modules sys et pathlib dans le chapitre 9 Modules.\nTestez votre script ainsi finalisé.\nBravo, si vous êtes arrivés jusqu’à cette étape.\n27.2.3 genbank2fasta (avec expressions régulières)\nCe projet consiste à écrire un convertisseur de fichier, du format GenBank au format FASTA. L’annexe A Quelques\nformats de données en biologie rappelle les caractéristiques de ces deux formats de fichiers.\nLe jeu de données avec lequel nous allons travailler est le fichier GenBank du chromosome I de la levure du boulanger\nSaccharomyces cerevisiae. Les indications pour le télécharger sont indiqués dans la description du projet.\nDans cette rubrique, nous allons réaliser ce projet avec des expressions régulières en utilisant le module re.\n27.2.3.1 Lecture du fichier\nCréez un script et créez la fonction qui prend en argument le nom du fichier et\ngenbank2fasta.py lit_fichier()\nqui renvoie le contenu du fichier sous forme d’une liste de lignes, chaque ligne étant elle-même une chaîne de caractères.\nTestez cette fonction avec le fichier GenBank et aﬀichez le nombre de lignes lues.\nNC_001133.gbk\n27.2.3.2 Extraction du nom de l’organisme\nDans le même script, ajoutez la fonction qui prend en argument le contenu du fichier\nextrait_organisme()\nprécédemment obtenu avec la fonction (sous la forme d’une liste de lignes) et qui renvoie le nom de\nlit_fichier()\nl’organisme. Utilisez de préférence une expression régulière.\nTestez cette fonction avec le fichier GenBank et aﬀichez le nom de l’organisme.\nNC_001133.gbk\n27.2.3.3 Recherche des gènes\nDans le fichier GenBank, les gènes sens sont notés de cette manière :\ngene 58..272\nou\ngene <2480..>2707\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 355\nChapitre 27. Mini-projets 27.2. Accompagnement pas à pas\net les gènes antisens de cette façon :\ngene complement(55979..56935)\nou\ngene complement(<13363..>13743)\nLes valeurs numériques séparées par indiquent la position du gène dans le génome (numéro de la première base,\n..\nnuméro de la dernière base).\nRemarque\nLe symbole indique un gène partiel sur l’extrémité 5’, c’est-à-dire que le codon START correspondant est incomplet.\n<\nRespectivement, le symbole désigne un gène partiel sur l’extrémité 3’, c’est-à-dire que le codon STOP correspondant\n>\n13\nest incomplet. Pour plus de détails, consultez la documentation du NCBI sur les délimitations des gènes .\nRepérez ces différents gènes dans le fichier . Construisez deux expressions régulières pour extraire du\nNC_001133.gbk\nfichier GenBank les gènes sens et les gènes antisens.\nModifiez ces expressions régulières pour que les numéros de la première et de la dernière base puissent être facilement\nextraits.\nDans le même script , ajoutez la fonction qui prend en argument le contenu\ngenbank2fasta.py recherche_genes()\ndu fichier (sous la forme d’une liste de lignes) et qui renvoie la liste des gènes.\nChaque gène sera lui-même une liste contenant le numéro de la première base, le numéro de la dernière base et une\nchaîne de caractère pour un gène sens et pour un gène antisens.\n\"sens\" \"antisens\"\nTestez cette fonction avec le fichier GenBank et aﬀichez le nombre de gènes trouvés, ainsi que le\nNC_001133.gbk\nnombre de gènes sens et antisens.\n27.2.3.4 Extraction de la séquence nucléique du génome\nLa taille du génome est indiqué sur la première ligne d’un fichier GenBank. Trouvez la taille du génome stocké dans\nle fichier .\nNC_001133.gbk\nDans un fichier GenBank, la séquence du génome se trouve entre les lignes\nORIGIN\net\n//\nTrouvez dans le fichier la première et dernière ligne de la séquence du génome.\nNC_001133.gbk\nConstruisez une expression régulière pour extraire du fichier GenBank les lignes correspondantes à la séquence du\ngénome.\nModifiez ces expressions régulières pour que la séquence puisse être facilement extraite.\nToujours dans le même script, ajoutez la fonction qui prend en argument le contenu du fichier\nextrait_sequence()\n(sous la forme de liste de lignes) et qui renvoie la séquence nucléique du génome (dans une chaîne de caractères). La\nséquence ne devra pas contenir d’espaces.\nTestez cette fonction avec le fichier GenBank et aﬀichez le nombre de bases de la séquence extraite.\nNC_001133.gbk\nVérifiez que vous n’avez pas fait d’erreur en comparant la taille de la séquence extraite avec celle que vous avez trouvée\ndans le fichier GenBank.\n27.2.3.5 Construction d’une séquence complémentaire inverse\nToujours dans le même script, ajoutez la fonction qui prend en argument une séquence\nconstruit_comp_inverse()\nd’ADN sous forme de chaîne de caractères et qui renvoie la séquence complémentaire inverse (également sous la forme\nd’une chaîne de caractères).\nOn rappelle que construire la séquence complémentaire inverse d’une séquence d’ADN consiste à :\n13. https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html#BaseSpanB\n356 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.2. Accompagnement pas à pas Chapitre 27. Mini-projets\n•\nPrendre la séquence complémentaire. C’est-à-dire à remplacer la base par la base , par , par et par .\na t t a c g g c\n•\nPrendre l’inverse. C’est-à-dire à que la première base de la séquence complémentaire devient la dernière base et\nréciproquement, la dernière base devient la première.\nPour vous faciliter le travail, ne travaillez que sur des séquences en minuscule.\nTestez cette fonction avec les séquences , et .\natcg AATTCCGG gattaca\n27.2.3.6 Écriture d’un fichier FASTA\nToujours dans le même script, ajoutez la fonction qui prend en argument un nom de fichier (sous\necrit_fasta()\nforme de chaîne de caractères), un commentaire (sous forme de chaîne de caractères) et une séquence (sous forme de\nchaîne de caractères) et qui écrit un fichier FASTA. La séquence sera à écrire sur des lignes ne dépassant pas 80 caractères.\nPour rappel, un fichier FASTA suit le format suivant :\n>commentaire\nsequence sur une ligne de 80 caractères maxi\nsuite de la séquence .......................\nsuite de la séquence .......................\n...\nTestez cette fonction avec :\n•\nnom de fichier :\ntest.fasta\n•\ncommentaire :\nmon commentaire\n•\nséquence :\natcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatc\n27.2.3.7 Extraction des gènes\nToujours dans le même script, ajoutez la fonction qui prend en argument la liste des gènes, la\nextrait_genes()\nséquence nucléotidique complète (sous forme d’une chaîne de caractères) et le nom de l’organisme (sous forme d’une\nchaîne de caractères) et qui pour chaque gène :\n•\nextrait la séquence du gène dans la séquence complète ;\n•\nprend la séquence complémentaire inverse (avec la fonction si le gène est antisens ;\nconstruit_comp_inverse()\n•\nenregistre le gène dans un fichier au format FASTA (avec la fonction ) ;\necrit_fasta()\n•\naﬀiche à l’écran le numéro du gène et le nom du fichier fasta créé.\nLa première ligne des fichiers FASTA sera de la forme :\n>nom-organisme|numéro-du-gène|début|fin|sens ou antisens\nLe numéro du gène sera un numéro consécutif depuis le premier gène jusqu’au dernier. Il n’y aura pas de différence\nde numérotation entre les gènes sens et les gènes antisens.\nTestez cette fonction avec le fichier GenBank .\nNC_001133.gbk\n27.2.3.8 Assemblage du script final\nPour terminer, modifiez le script de façon à ce que le fichier GenBank à analyser (dans cet\ngenbank2fasta.py\nexemple ), soit entré comme argument du script.\nNC_001133.gbk\nVous aﬀicherez un message d’erreur si :\n•\nle script est utilisé sans argument,\ngenbank2fasta.py\n•\nle fichier fourni en argument n’existe pas.\nPour vous aider, n’hésitez pas à jeter un œil aux descriptions des modules sys et pathlib dans le chapitre 9 sur les\nmodules.\nTestez votre script ainsi finalisé.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 357\nChapitre 27. Mini-projets 27.2. Accompagnement pas à pas\n27.2.4 Simulation d’un pendule\n14\nL’objectif de ce projet est de simuler un pendule simple en deux dimensions, puis de le visualiser à l’aide du module\ntkinter. Le projet peut s’avérer complexe. Tout d’abord, il y a l’aspect physique du projet. Nous allons faire ici tous\nles rappels de mécanique nécessaires à la réalisation du projet. Ensuite, il y a la partie tkinter qui n’est pas évidente\nau premier abord. Nous conseillons de bien séparer les deux parties. D’abord réaliser la simulation physique et vérifier\nqu’elle fonctionne (par exemple, en écrivant un fichier de sortie permettant cette vérification). Ensuite passer à la partie\ngraphique tkinter si et seulement si la première partie est fonctionnelle.\n27.2.4.1 Mécanique d’un pendule simple\nNous allons décrire ici ce dont nous avons besoin concernant la mécanique d’un pendule simple. Notamment, nous\nallons vous montrer comment dériver l’équation différentielle permettant de calculer la position du pendule à tout moment\n15\nen fonction des conditions initiales. Cette page est largement inspirée de la page Wikipedia en anglais . Dans la suite,\nune grandeur représentée en gras, par exemple P, représente un vecteur avec deux composantes dans le plan 2D (P ,P ).\nx y\nCette notation en gras est équivalente à la notation avec une flèche au dessus de la lettre. La même grandeur représentée\nen italique, par exemple P, représente le nombre scalaire correspondant. Ce nombre peut être positif ou négatif, et sa\nvaleur absolue vaut la norme du vecteur.\nUn pendule simple est représenté par une masse ponctuelle (la boule du pendule) reliée à un axe immobile par une\ntige rigide et sans masse. Le pendule simple est un système idéal. Ainsi, on néglige les effets de frottement et on considère\nle champ gravitationnel comme uniforme. La figure 27.2 montre un schéma du système ainsi qu’un bilan des forces\nagissant sur la masse. Les deux forces agissant sur la boule sont son poids P et la tension T due à la tige.\nLa figure 27.3 montre un schéma des différentes grandeurs caractérisant le pendule. La coordonnée naturelle pour\nθ\ndéfinir la position du pendule est l’angle . Nous verrons plus tard comment convertir cet angle en coordonnées car-\nθ\ntésiennes pour l’aﬀichage dans un canvas tkinter. Nous choisissons de fixer = 0 lorsque le pendule est à sa position\nd’équilibre. Il s’agit de la position où la boule est au plus bas. C’est une position à laquelle le pendule ne bougera pas\nθ\ns’il n’a pas une vitesse préexistante. Nous choisissons par ailleurs de considérer positif lorsque le pendule se balance\nà droite, et négatif de l’autre côté. g décrit l’accélération due à la gravité, avec P = mg, ou si on raisonne en scalaire\n= . Les deux vecteurs représentant les composantes tangentielle et orthogonale au mouvement du pendule de P sont\nP mg\nreprésentées sur le schéma (les annotations indiquent leur norme).\nSi on déplace le pendule de sa position d’équilibre, il sera mû par la force F résultant de la tension T et de son poids\nP (cf. plus bas). Comme le système est considéré comme parfait (pas de frottement, gravité uniforme, etc.), le pendule\nθ θ\nne s’arrêtera jamais. Si on le monte à = +20 deg et qu’on le lâche, le pendule redescendra en passant par = 0 deg,\nθ −\nremontera de l’autre côté à = 20 deg, puis continuera de la sorte indéfiniment, grâce à la conservation de l’énergie\ndans un système fermé (c’est-à-dire sans « fuite » d’énergie).\n16\nIci, on va tenter de simuler ce mouvement en appliquant les lois du mouvement de Newton et en résolvant les\néquations correspondantes numériquement. D’après la seconde loi de Newton, la force (F) agissant sur la boule est égale\nà sa masse (m) fois son accélération (a) :\nF = ma\nCette loi est exprimée ici dans le système de coordonnées cartésiennes (le plan à 2 dimensions). La force F et\nl’accélération a sont des vecteurs dont les composantes sont respectivement (F ,F ) et (a ,a ). La force F correspond\nx y x y\nà la somme vectorielle de T et P. La tige du pendule étant rigide, le mouvement de la boule est restreint sur le cercle\nde rayon égal à la longueur L de la tige (dessiné en pointillé). Ainsi, seule la composante tangentielle de l’accélération a\nsera prise en compte dans ce mouvement. Comment la calculer ? La force de tension T étant orthogonale au mouvement\nθ\ndu pendule, celle-ci n’aura pas d’effet. De même, la composante orthogonale mgcos due au poids P n’aura pas d’effet\nθ\nnon plus. Au final, on ne prendra en compte que la composante tangentielle due au poids, c’est-à-dire mgsin (cf. figure\n27.3). Au final, on peut écrire l’expression suivante en raisonnant sur les valeurs scalaires :\n− θ\nF = ma = mgsin\n14. https://fr.wikipedia.org/wiki/Pendule_simple\n15.\nhttps://en.wikipedia.org/wiki/Pendulum_(mathematics)\n16. https://fr.wikipedia.org/wiki/Lois_du_mouvement_de_Newton\n358 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.2. Accompagnement pas à pas Chapitre 27. Mini-projets\nFigure 27.2 – Bilan des forces dans un pendule simple.\n− θ\nLe signe dans cette formule est très important. Il indique que l’accélération s’oppose systématiquement à . Si le\nθ\npendule se balance vers la droite et que devient plus positif, l’accélération tendra toujours à faire revenir la boule dans\nθ\nl’autre sens vers sa position d’équilibre à = 0. On peut faire un raisonnement équivalent lorsque le pendule se balance\nθ\nvers la gauche et que devient plus négatif.\nθ\nSi on exprime l’accélération en fonction de , on trouve ce résultat qui peut sembler peu intuitif au premier abord :\n− θ\n=\na gsin\nLe mouvement du pendule ne dépend pas de sa masse !\nθ\nIdéalement, nous souhaiterions résoudre cette équation en l’exprimant en fonction de seulement. Cela est possible\nθ\nen reliant à la longueur effective de l’arc s parcourue par le pendule :\nθ\ns = L\nπ\nPour bien comprendre cette formule, souvenez-vous de la formule bien connue du cercle l = 2 r (où l est la circon-\nθ\nférence, et r le rayon) ! Elle relie la valeur de à la distance de l’arc entre la position actuelle de la boule et l’origine (à\nθ\n= 0). On peut donc exprimer la vitesse du pendule en dérivant s par rapport au temps t :\nθ\nds d\nv = = L\ndt dt\nOn peut aussi exprimer l’accélération a en dérivant l’arc s deux fois par rapport à t :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 359\nChapitre 27. Mini-projets 27.2. Accompagnement pas à pas\nFigure 27.3 – Caractérisation géométrique d’un pendule simple.\nθ\n2 2\nd s d\na = = L\n2 2\ndt dt\nA nouveau, cette dernière formule exprime l’accélération de la boule lorsque le mouvement de celle-ci est restreint sur\nle cercle pointillé. Si la tige n’était pas rigide, l’expression serait différente.\nSi on remplace a dans la formule ci-dessus, on trouve :\nθ\n2\nd\n− θ\nL = gsin\n2\ndt\nθ\nSoit en remaniant, on trouve l’équation différentielle en décrivant le mouvement du pendule :\n2θ\nd g\nθ\n+ sin = 0\n2\ndt L\nDans la section suivante, nous allons voir comment résoudre numériquement cette équation différentielle.\n27.2.4.2 Résolution de l’équation différentielle du pendule\n17\nIl existe de nombreuses méthodes numériques de résolution d’équations différentielles . L’objet ici n’est pas de\nfaire un rappel sur toutes ces méthodes ni de les comparer, mais juste d’expliquer une de ces méthodes fonctionnant\neﬀicacement pour simuler notre pendule.\n18\nNous allons utiliser la méthode semi-implicite d’Euler . Celle-ci est relativement intuitive à comprendre.\n17.\nhttps://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations\n18. https://en.wikipedia.org/wiki/Semi-implicit_Euler_method\n360 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.2. Accompagnement pas à pas Chapitre 27. Mini-projets\nCommençons d’abord par calculer l’accélération angulaire a au temps t en utilisant l’équation différentielle précé-\nθ\ndemment établie :\nθ\n2\nd g\n− θ\na (t) = (t) = sin (t)\nθ\n2\ndt L\nδ\nL’astuce sera de calculer ensuite la vitesse angulaire au pas suivant t + t grâce à la relation :\nθ\nd\nδ δ ≈ ×δ\nv (t + t) = (t + t) v (t)+a (t) t\nθ θ θ\ndt\nCette équation est ni plus ni moins qu’un remaniement de la définition de l’accélération, à savoir, la variation de\nδ θ δ\nvitesse par rapport à un temps. Cette vitesse v (t + t) permettra au final de calculer au temps t + t (c’est-à-dire ce\nθ\nque l’on cherche !) :\nθ δ ≈ θ δ ×δ\n(t + t) (t)+v (t + t) t\nθ\nDans une réalisation algorithmique, il suﬀira d’initialiser les variables de notre système puis de faire une boucle sur\nδ θ δ\nun nombre de pas de simulation. A chaque pas, on calculera a (t), puis v (t + t) et enfin (t + t) à l’aide des formules\nθ θ\nci-dessus.\nL’initialisation des variables pourra ressembler à cela :\nL <- 1 # longueur tige en m\ng <- 9.8 # accélération gravitationnelle en m/s^2\nt <- 0 # temps initial en s\ndt <- 0.05 # pas de temps en s\n# conditions initiales\ntheta <- pi / 4 # angle initial en rad\ndtheta <- 0 # vitesse angulaire initiale en rad/s\nafficher_position_pendule(t, theta) # afficher position de départ\nL’initialisation des valeurs de et est très importante, car elle détermine le comportement du pendule.\ntheta dtheta\nθ π\nNous avons choisi ici d’avoir une vitesse angulaire nulle et un angle de départ du pendule = / rad = deg. Le pas\n4 45\nest également très important, c’est lui qui déterminera l’erreur faite sur l’intégration de l’équation différentielle. Plus\ndt\nce pas est petit, plus on est précis, mais plus le calcul sera long. Ici, on choisit un pas de 0.05 s qui constitue un bon\ndt\ncompromis.\nÀ ce stade, vous avez tous les éléments pour tester votre pendule. Essayez de réaliser un petit programme python\nqui utilise les conditions initiales ci-dessus et simule le mouvement du pendule. À la fin de cette\npendule_basic.py\nrubrique, nous proposons une solution en langage algorithmique. Essayez dans un premier temps de le faire vous-même.\nθ\nÀ chaque pas, le programme écrira le temps et l’angle dans un fichier . Dans les équations,\nt\npendule_basic.dat\nθ\ndoit être exprimé en radian, mais nous vous conseillons de convertir cet angle en degré dans le fichier (plus facile à\ncomprendre pour un humain !). Une fois ce fichier généré, vous pourrez observer le graphe correspondant avec matplotlib\nen utilisant le code suivant :\n1 import matplotlib.pyplot as plt\n2\nimport numpy as np\n3\n4\n# La fonction np.genfromtxt() renvoie un array à 2 dim.\n5 array_data = np.genfromtxt(\"pendule_basic.dat\")\n6\n# col 0: t, col 1: theta\n7 t = array_data[:,0]\n8 theta = array_data[:,1]\n9\n10 # Figure.\n11\nfig, ax = plt.subplots(figsize=(8, 8))\n12 mini = min(theta) * 1.2\n13\nmaxi = max(theta) * 1.2\n14 ax.set_xlim(0, max(t))\n15\nax.set_ylim(mini, maxi)\n16 ax.set_xlabel(\"t (s)\")\n17\nax.set_ylabel(\"theta (deg)\")\n18 ax.plot(t, theta)\n19\nfig.savefig(\"pendule_basic.png\")\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 361\nChapitre 27. Mini-projets 27.2. Accompagnement pas à pas\nSi vous observez une sinusoïde, bravo, vous venez de réaliser votre première simulation de pendule ! Vous avez\nmaintenant le « squelette » de votre « moteur » de simulation. N’hésitez pas à vous amuser avec d’autres conditions\ninitiales. Ensuite vous pourrez passer à la rubrique suivante.\nSi vous avez bloqué dans l’écriture de la boucle, voici à quoi elle pourrait ressembler en langage algorithmique :\ntant qu'on n'arrête pas le pendule:\n# acc angulaire au tps t (en rad/s^2)\nd2theta <- -(g/L) * sin(theta)\n# v angulaire mise à jour de t -> t + dt\ndtheta <- dtheta + d2theta * dt\n# theta mis à jour de t -> t + dt\ntheta <- theta + dtheta * dt\n# t mis à jour\nt <- t + dt\n# mettre à jour l'affichage\nafficher_position_pendule(t, theta)\n27.2.4.3 Constructeur de l’application en tkinter\nNous allons maintenant construire l’application tkinter en vous guidant pas à pas. Il est bien sûr conseillé de relire le\nchapitre 25 sur Fenêtres graphiques et Tkinter (en ligne) avant de vous lancer dans cette partie.\nComme expliqué largement dans les chapitres 23 Avoir la classe avec les objets et 24 Avoir plus la classe avec les\nobjets (en ligne), nous allons construire l’application avec une classe. Le programme principal sera donc très allégé et se\ncontentera d’instancier l’application, puis de lancer le gestionnaire d’événements :\n1 if __name__ == \"__main__\":\n2\n\"\"\"Programme principal (instancie la classe principale, donne un\n3 titre et lance le gestionnaire d'événements)\n4\n\"\"\"\n5 app_pendule = AppliPendule()\n6\napp_pendule.title(\"Pendule\")\n7 app_pendule.mainloop()\nEnsuite, nous commençons par écrire le constructeur de la classe. Dans ce constructeur, nous aurons une section\ninitialisant toutes les variables utilisées pour simuler le pendule (voir rubrique précédente), puis, une autre partie générant\nles widgets et tous les éléments graphiques. Nous vous conseillons vivement de bien les séparer, et surtout de mettre\ndes commentaires pour pouvoir s’y retrouver. Voici un « squelette » pour vous aider :\n1 class AppliPendule(tk.Tk):\n2\ndef __init__(self):\n3 # Instanciation de la classe Tk.\n4\ntk.Tk.__init__(self)\n5 # Ici vous pouvez définir toutes les variables\n6\n# concernant la physique du pendule.\n7 self.theta = np.pi / 4 # valeur intiale theta\n8\nself.dtheta = 0 # vitesse angulaire initiale\n9 [...]\n10\nself.g = 9.8 # cst gravitationnelle en m/s^2\n11 [...]\n12 # Oci vous pouvez construire l'application graphique.\n13\nself.canv = tk.Canvas(self, bg='gray', height=400, width=400)\n14 # Création d'un boutton demarrer, arreter, quitter.\n15\n# Pensez à placer les widgets avec .pack()\n16 [...]\nLa figure 27.4 vous montre un aperçu de ce que l’on voudrait obtenir.\nθ θ\nPour le moment, vous pouvez oublier la réglette fixant la valeur initiale de , les labels aﬀichant la valeur de et v\nθ\nainsi que les points violets « laissés en route » par le pendule. De même, nous dessinerons le pivot, la boule et la tige\nplus tard. À ce stade, il est fondamental de tout de suite lancer votre application pour vérifier que les widgets sont bien\nplacés. N’oubliez pas, un code complexe se teste au fur et à mesure lors de son développement.\nConseil\n362 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.2. Accompagnement pas à pas Chapitre 27. Mini-projets\nFigure 27.4 – Application pendule.\nPour éviter un message d’erreur si toutes les méthodes n’existe pas encore, vous pouvez indiquer\ncommand=self.quit\npour chaque bouton (vous le changerez après).\n27.2.4.4 Créations des dessins dans le canvas\nLe pivot et la boule pourront être créés avec la méthode , la tige le sera avec la méthode\n.create_oval() .\n. Pensez à créer des variables pour la tige et la boule lors de l’instanciation car celles-ci bougeront par\ncreate_line()\nla suite.\nComment placer ces éléments dans le canvas ? Vous avez remarqué que lors de la création de ce dernier, nous avons\n×\nfixé une dimension de 400 400 pixels. Le pivot se trouve au centre, c’est-à-dire au point (200,200). Pour la tige et\nla boule, il sera nécessaire de connaître la position de la boule dans le repère du canvas. Or, pour l’instant, nous\nθ θ\ndéfinissons la position de la boule avec l’angle . Il va donc nous falloir convertir en coordonnées cartésiennes (x,y)\ndans le repère mathématique défini dans la figure 27.3, puis dans le repère du canvas (x ,y ) (cf. rubrique suivante).\nc c\nθ\nConversion de en coordonnées (x,y) Cette étape est relativement simple si on considère le pivot comme le centre du\nrepère. Avec les fonctions trigonométriques et , vous pourrez calculer la position de la boule (voir l’exercice\nsin() cos()\nsur la spirale dans le chapitre 7 Fichiers). Faites attention toutefois aux deux aspects suivants :\n•\nla trajectoire de la boule suit les coordonnées d’un cercle de rayon L (si on choisit L = 1 m, ce sera plus simple) ;\n•\nnous sommes décalés par rapport au cercle trigonométrique classique ; si on considère L = 1 m :\nθ −\n— quand = 0, on a le point (0, 1) (pendule en bas) ;\nθ π\n— quand = + / = deg, on a ( , ) (pendule à droite) ;\n2 90 1 0\nθ −π − −\n— quand = /2 = 90 deg, on a ( 1,0) (pendule à gauche) ;\nθ ±π ±\n— quand = = 180 deg, on a (0,1) (pendule en haut).\nθ\nLa figure 27.3 montre graphiquement les valeurs de .\nSi vous n’avez pas trouvé, voici la solution :\n1 self.x = np.sin(self.theta) * self.L\n2\nself.y = -np.cos(self.theta) * self.L\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 363\nChapitre 27. Mini-projets 27.2. Accompagnement pas à pas\nConversion des coordonnées (x,y) en (x ,y ) Il nous faut maintenant convertir les coordonnées naturelles mathéma-\nc c\ntiques du pendule (x,y) en coordonnées dans le canvas (x ,y ). Plusieurs choses sont importantes pour cela :\nc c\n•\nle centre du repère mathématique ( , ) a la coordonnée ( , ) dans le canvas ;\n0 0 200 200\n• →\nil faut choisir un facteur de conversion : par exemple, si on choisit L = 1 m, on peut proposer le facteur 1 m\n100 pixels ;\n•\nl’axe des ordonnées dans le canvas est inversé par rapport au repère mathématique.\nConseil\nDans votre classe, cela peut être une bonne idée d’écrire une méthode qui réalise cette conversion. Celle-ci pourrait\ns’appeler par exemple .\nmap_realcoor2canvas()\nSi vous n’avez pas trouvé, voici la solution :\n1\nself.conv_factor = 100\n2 self.x_c = self.x*self.conv_factor + 200\n3\nself.y_c = -self.y*self.conv_factor + 200\n27.2.4.5 Gestion des boutons\nIl reste maintenant à gérer les boutons permettant de démarrer / stopper le pendule. Pour cela il faudra créer trois\nméthodes dans notre classe :\n•\nLa méthode : met en mouvement le pendule ; si le pendule n’a jamais été en mouvement, il part de son\n.start()\npoint de départ ; si le pendule avait déjà été en mouvement, celui-ci repart d’où on l’avait arrêté (avec la vitesse\nqu’il avait à ce moment-là).\n•\nLa méthode : arrête le mouvement du pendule.\n.stop()\n•\nLa méthode : gère le mouvement du pendule (génère les coordonnées du pendule au pas suivant).\n.move()\nLe bouton « Démarrer » appellera la méthode , le bouton « Arrêter » appellera la méthode et\n.start() .stop()\nle bouton « Quitter » quittera l’application. Pour lier une action au clic d’un bouton, on se souvient qu’il faut donner à\nl’argument par mot-clé command une callback (c’est-à-dire le nom d’une fonction ou méthode sans les parenthèses) :\n•\nbtn1 = tk.Button(self, text=\"Quitter\", command=self.quit)\n•\nbtn2 = tk.Button(self, text=\"Demarrer\", command=self.start)\n•\nbtn3 = tk.Button(self, text=\"Arrêter\", command=self.stop)\nIci, et sont des méthodes que l’on doit créer, pré-existe lorsque la fenêtre\nself.start() self.stop() self.quit()\ntkinter est créée.\n19\nNous vous proposons ici une stratégie inspirée du livre de Gérard Swinnen . Créons d’abord un attribut d’instance\ndans le constructeur. Celui-ci va nous servir de « drapeau » pour définir le mouvement du pendule.\nself.is_moving\nIl contiendra un entier positif ou nul. Lorsque ce drapeau sera égal à 0, le pendule sera immobile. Lorsqu’il sera > 0, le\npendule sera en mouvement. Ainsi :\n•\nla méthode ajoutera 1 à . Si est égal à 1 alors la méthode\n.start() self.is_moving self.is_moving self.\nsera appelée ;\nmove()\n•\nla méthode mettra la valeur de à 0.\n.stop() self.is_moving\nPuisque ajoute 1 à , le premier clic sur le bouton « Démarrer » appellera la méthode\n.start() self.is_moving\ncar vaudra 1. Si l’utilisateur appuie une deuxième fois sur le bouton « Démarrer »,\n.move() self.is_moving self\nvaudra 2, mais n’appellera pas une deuxième fois ; cela sera vrai pour tout clic ultérieur de\n.is_moving .move()\nl’utilisateur sur ce bouton. Cette astuce évite des appels concurrents de la méthode .\n.move()\n27.2.4.6 Le coeur du programme : la méthode\n.move()\nIl nous reste maintenant à générer la méthode qui meut le pendule. Pour cela vous pouvez vous inspirer de\n.move()\nla rubrique Un canvas animé dans une classe du chapitre 25 Fenêtres graphiques et Tkinter (en ligne).\nδ\nCette méthode va réaliser un pas de simulation de t à t + t. Il faudra ainsi réaliser dans l’ordre :\n19. https://inforef.be/swi/python.htm\n364 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n27.3. Scripts de correction Chapitre 27. Mini-projets\n• θ δ\nCalculer la nouvelle valeur de ( ) au pas t + t comme nous l’avons fait précédemment avec la\nself.theta\nméthode semi-implicite d’Euler.\n• θ\nConvertir la nouvelle valeur de ( ) en coordonnées cartésiennes dans le repère du pendule (\nself.theta self.x\net ).\nself.y\n•\nConvertir ces coordonnées cartésiennes dans le repère du Canvas ( et ).\nself.x_c self.y_c\n•\nMettre à jour le dessin de la baballe et de la tige avec la méthode .\nself.canv.coords()\n•\nIncrémenter le pas de temps.\n•\nSi le drapeau est supérieur à 0, la méthode est rappelée après 20 millisecondes\nself.is_moving self.move()\n(Conseil : la méthode est votre amie).\n.after()\n27.2.4.7 Ressources complémentaires\nSi vous êtes arrivé jusqu’ici, bravo, vous pouvez maintenant admirer votre superbe pendule en mouvement :-) !\nVoici quelques indications si vous voulez aller un peu plus loin.\nSi vous souhaitez mettre une réglette pour modifier la position de départ du pendule, vous pouvez utiliser la classe\nθ\n. Si vous souhaitez aﬀicher la valeur de qui se met à jour au fur et à mesure, il faudra instancier un objet\ntk.Scale()\navec la classe . Cet objet devra être passé à l’argument lors de la création de ce Label\ntk.StringVar() textvariable\navec . Ensuite, vous pourrez mettre à jour le texte du Label avec la méthode\ntk.Label() self.instance_StringVar\n.\n.set()\nPour le fun, si vous souhaitez laisser une « trace » du passage du pendule avec des points colorés, vous pouvez utiliser\ntout simplement la méthode et créer une ligne d’un pixel de hauteur et de largeur pour\nself.canv.create_line()\ndessiner un point. Pour améliorer l’esthétique, vous pouvez faire en sorte que ces points changent de couleur aléatoirement\nà chaque arrêt / redémarrage du pendule."
  },
  {
    "title": "Scripts de correction",
    "content": "Voici les scripts corrigés pour les différents mini-projets.\nRemarque\n•\nPrenez le temps de chercher par vous-même avant de télécharger les scripts de correction.\n•\nNous proposons une correction. D’autres solutions sont possibles.\n• 20\nMots anglais dans le protéome humain : words_in_proteome.py\n•\n21\nGenbank2fasta (sans expression régulière) : genbank2fasta_sans_regex.py\n• 22\nGenbank2fasta (avec expressions régulières) : genbank2fasta_avec_regex.py\n•\n23\nSimulation d’un pendule version simple : tk_pendule.py\n• 24\nSimulation d’un pendule++ (avec réglette et aﬀichage se mettant à jour) : tk_pendule.py\n20. https://python.sdv.u-paris.fr/data-files/words_in_proteome.py\n21.\nhttps://python.sdv.u-paris.fr/data-files/genbank2fasta_sans_regex.py\n22. https://python.sdv.u-paris.fr/data-files/genbank2fasta_avec_regex.py\n23.\nhttps://python.sdv.u-paris.fr/data-files/tk_pendule_simple.py\n24. https://python.sdv.u-paris.fr/data-files/tk_pendule.py\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 365"
  },
  {
    "title": "A.1 FASTA",
    "content": "Le format FASTA est utilisé pour stocker une ou plusieurs séquences, d’ADN, d’ARN ou de protéines. Ces séquences\nsont classiquement représentées sous la forme :\n>en-tête\nséquence avec un nombre maximum de caractères par ligne\nséquence avec un nombre maximum de caractères par ligne\nséquence avec un nombre maximum de caractères par ligne\nséquence avec un nombre maximum de caractères par ligne\nséquence avec un nombre max\nLa première ligne débute par le caractère et contient une description de la séquence. On appelle souvent cette ligne\n>\n« ligne de description » ou « ligne de commentaire ».\nLes lignes suivantes contiennent la séquence à proprement dite, mais avec un nombre maximum fixe de caractères\npar ligne. Ce nombre maximum est généralement fixé à 60, 70 ou 80 caractères. Une séquence de plusieurs centaines de\nbases ou de résidus est donc répartie sur plusieurs lignes.\nUn fichier est dit multifasta lorsqu’il contient plusieurs séquences au format FASTA, les unes à la suite des autres.\nLes fichiers contenant une ou plusieurs séquences au format FASTA portent la plupart du temps l’extension\n.fasta\nmais on trouve également , , ou .\n.seq .fas .fna .faa\nA.1.1 Exemples\n1\nLa séquence protéique au format FASTA de l’insuline humaine , extraite de la base de données UniProt, est :\n>sp|P01308|INS_HUMAN Insulin OS=Homo sapiens OX=9606 GN=INS PE=1 SV=1\nMALWMRLLPLLALLALWGPDPAAAFVNQHLCGSHLVEALYLVCGERGFFYTPKTRREAED\nLQVGQVELGGGPGAGSLQPLALEGSLQKRGIVEQCCTSICSLYQLENYCN\nLa première ligne contient la description de la séquence (Insulina), le type de base de données (ici, sp qui signifie Swiss-\nProt), son identifiant (P01308) et son nom (INS_HUMAN) dans cette base de données, ainsi que d’autres informations\n(OS=Homo sapiens OX=9606 GN=INS PE=1 SV=1B).\nLes lignes suivantes contiennent la séquence sur des lignes ne dépassant pas, ici, 60 caractères. La séquence de\nl’insuline humaine est composée de 110 acides aminés, soit une ligne de 60 caractères et une seconde de 50 caractères.\n1. https://www.uniprot.org/uniprot/P01308\n366\nA.1. FASTA Annexe A. Quelques formats de données en biologie\nDéfinition\n2\nUniProt est une base de données de séquences de protéines. Ces séquences proviennent elles-mêmes de deux autres\nbases de données : Swiss-Prot (où les séquences sont annotées manuellement) et TrEMBL (où les séquences sont annotées\nautomatiquement).\n3\nVoici maintenant la séquence nucléique (ARN), au format FASTA, de l’insuline humaine , extraite de la base de\n4\ndonnées GenBank :\n>BT006808.1 Homo sapiens insulin mRNA, complete cds\nATGGCCCTGTGGATGCGCCTCCTGCCCCTGCTGGCGCTGCTGGCCCTCTGGGGACCTGACCCAGCCGCAG\nCCTTTGTGAACCAACACCTGTGCGGCTCACACCTGGTGGAAGCTCTCTACCTAGTGTGCGGGGAACGAGG\nCTTCTTCTACACACCCAAGACCCGCCGGGAGGCAGAGGACCTGCAGGTGGGGCAGGTGGAGCTGGGCGGG\nGGCCCTGGTGCAGGCAGCCTGCAGCCCTTGGCCCTGGAGGGGTCCCTGCAGAAGCGTGGCATTGTGGAAC\nAATGCTGTACCAGCATCTGCTCCCTCTACCAGCTGGAGAACTACTGCAACTAG\nOn retrouve sur la première ligne la description de la séquence (Homo sapiens insulin mRNA), ainsi que son identifiant\n(BT006808.1) dans la base de données GenBank.\nLes lignes suivantes contiennent les 333 bases de la séquence, réparties sur cinq lignes de 70 caractères maximum. Il\nest curieux de trouver la base T (thymine) dans une séquence d’ARN, qui ne devrait contenir normalement que les bases\nA, U, G et C. Ici, la représentation d’une séquence d’ARN avec les bases de l’ADN est une convention.\nPour terminer, voici trois séquences protéiques, au format FASTA, qui correspondent à l’insuline humaine (Homo\nsapiens), féline (Felis catus) et bovine (Bos taurus) :\n>sp|P01308|INS_HUMAN Insulin OS=Homo sapiens OX=9606 GN=INS PE=1 SV=1\nMALWMRLLPLLALLALWGPDPAAAFVNQHLCGSHLVEALYLVCGERGFFYTPKTRREAED\nLQVGQVELGGGPGAGSLQPLALEGSLQKRGIVEQCCTSICSLYQLENYCN\n>sp|P06306|INS_FELCA Insulin OS=Felis catus OX=9685 GN=INS PE=1 SV=2\nMAPWTRLLPLLALLSLWIPAPTRAFVNQHLCGSHLVEALYLVCGERGFFYTPKARREAED\nLQGKDAELGEAPGAGGLQPSALEAPLQKRGIVEQCCASVCSLYQLEHYCN\n>sp|P01317|INS_BOVIN Insulin OS=Bos taurus OX=9913 GN=INS PE=1 SV=2\nMALWTRLRPLLALLALWPPPPARAFVNQHLCGSHLVEALYLVCGERGFFYTPKARREVEG\nPQVGALELAGGPGAGGLEGPPQKRGIVEQCCASVCSLYQLENYCN\n5\nCes séquences proviennent de la base de données UniProt . Chaque séquence est délimitée par la ligne d’en-tête qui\ndébute par .\n>\nA.1.2 Manipulation avec Python\nÀ partir de l’exemple précédent des 3 séquences d’insuline, voici un exemple de code qui lit un fichier FASTA avec\nPython :\n1 prot_dict = {}\n2\nwith open(\"insulin.fasta\", \"r\") as fasta_file:\n3 prot_id = \"\"\n4\nfor line in fasta_file:\n5 if line.startswith(\">\"):\n6\nprot_id = line[1:].split()[0]\n7 prot_dict[prot_id] = \"\"\n8\nelse:\n9 prot_dict[prot_id] += line.strip()\n10 for id in prot_dict:\n11\nprint(id)\n12 print(prot_dict[id][:30])\nPour chaque séquence lue dans le fichier FASTA, on aﬀiche son identifiant et son nom, puis les 30 premiers résidus\nde sa séquence :\n2.\nhttps://www.uniprot.org/\n3. https://www.ncbi.nlm.nih.gov/nuccore/BT006808.1?report=fasta\n4.\nhttps://www.ncbi.nlm.nih.gov/nuccore/AY899304.1?report=genbank\n5. https://www.uniprot.org/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 367\nAnnexe A. Quelques formats de données en biologie A.2. GenBank\nsp|P06306|INS_FELCA\nMAPWTRLLPLLALLSLWIPAPTRAFVNQHL\nsp|P01317|INS_BOVIN\nMALWTRLRPLLALLALWPPPPARAFVNQHL\nsp|P01308|INS_HUMAN\nMALWMRLLPLLALLALWGPDPAAAFVNQHL\nNotez que les protéines sont stockées dans un dictionnaire ( ) où les clefs sont les identifiants et les valeurs\nprot_dict\nles séquences.\nOn peut faire la même chose avec le module Biopython :\n1 from Bio import SeqIO\n2 with open(\"insulin.fasta\", \"r\") as fasta_file:\n3\nfor record in SeqIO.parse(fasta_file, \"fasta\"):\n4 print(record.id)\n5\nprint(str(record.seq)[:30])\nCela produit le même résultat. L’utilisation de Biopython rend le code plus compacte car on utilise ici la fonction\nqui s’occupe de lire le fichier FASTA.\nSeqIO.parse()\nRemarque\nL’attribut renvoie l’identifiant d’une séquence, c’est-à-dire la première partie de l’entête, sans le caractère . Pour\n.id >\nobtenir l’entête complet (toujours sans le caractère ), il faut utiliser l’attribut .\n> .description"
  },
  {
    "title": "A.2 GenBank",
    "content": "GenBank est une banque de séquences nucléiques. Le format de fichier associé contient l’information nécessaire pour\ndécrire un gène ou une portion d’un génome. Les fichiers GenBank portent le plus souvent l’extension .\n.gbk\n6\nLe format GenBank est décrit de manière très complète sur le site du NCBI . En voici néanmoins les principaux\n7\néléments, avec l’exemple du gène qui code pour la trypsine chez l’Homme.\nA.2.1 L’en-tête\nLOCUS HUMTRPSGNA 800 bp mRNA linear PRI 14-JAN-1995\nDEFINITION Human pancreatic trypsin 1 (TRY1) mRNA, complete cds.\nACCESSION M22612\nVERSION M22612.1\nKEYWORDS trypsinogen.\nSOURCE Homo sapiens (human)\nORGANISM Homo sapiens\nEukaryota; Metazoa; Chordata; Craniata; Vertebrata; Euteleostomi;\nMammalia; Eutheria; Euarchontoglires; Primates; Haplorrhini;\nCatarrhini; Hominidae; Homo.\n[...]\n•\nLigne 1 ( ) : le nom du locus (HUMTRPSGNA), la taille du gène (800 paires de bases), le type de molécule\nLOCUS\n(ARN messager).\n•\nLigne 3 ( ) : l’identifiant de la séquence (M22612).\nACCESSION\n•\nLigne 4 ( ) : la version de la séquence (M22612.1). Le nombre qui est séparé de l’identifiant de la séquence\nVERSION\npar un point est incrémenté pour chaque nouvelle version de la fiche GenBank. Ici, .1 indique que nous en sommes\nà la première version.\n•\nLigne 6 ( ) : la provenance de la séquence (souvent l’organisme d’origine).\nSOURCE\n•\nLigne 7 ( ) : le nom scientifique de l’organisme, suivi de sa taxonomie (lignes 8 à 10).\nORGANISME\n6.\nhttps://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html\n7. https://www.ncbi.nlm.nih.gov/nuccore/M22612.1\n368 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nA.2. GenBank Annexe A. Quelques formats de données en biologie\nA.2.2 Les features\n[...]\nFEATURES Location/Qualifiers\nsource 1..800\n/organism=\"Homo sapiens\"\n/mol_type=\"mRNA\"\n/db_xref=\"taxon:9606\"\n/map=\"7q32-qter\"\n/tissue_type=\"pancreas\"\ngene 1..800\n/gene=\"TRY1\"\nCDS 7..750\n/gene=\"TRY1\"\n/codon_start=1\n/product=\"trypsinogen\"\n/protein_id=\"AAA61231.1\"\n/db_xref=\"GDB:G00-119-620\"\n/translation=\"MNPLLILTFVAAALAAPFDDDDKIVGGYNCEENSVPYQVSLNSG\nYHFCGGSLINEQWVVSAGHCYKSRIQVRLGEHNIEVLEGNEQFINAAKIIRHPQYDRK\nTLNNDIMLIKLSSRAVINARVSTISLPTAPPATGTKCLISGWGNTASSGADYPDELQC\nLDAPVLSQAKCEASYPGKITSNMFCVGFLEGGKDSCQGDSGGPVVCNGQLQGVVSWGD\nGCAQKNKPGVYTKVYNYVKWIKNTIAANS\"\nsig_peptide 7..51\n/gene=\"TRY1\"\n/note=\"G00-119-620\"\n[...]\n•\nLigne 9 ( ) : la délimitation du gène. Ici, de la base 1 à la base 800. Par ailleurs, la notation\ngene 1..800 <x..y\nindique que la séquence est partielle sur l’extrémité 5’. Réciproquement, indique que la séquence est partielle\nx..y>\nsur l’extrémité 3’. Enfin, pour les séquences d’ADN, la notation indique que le gène se trouve\ncomplement(x..y)\nde la base x à la base y, mais sur le brin complémentaire.\n•\nLigne 10 ( ) : le nom du gène.\n/gene=\"TRY1\"\n•\nLigne 11 ( ) : la délimitation de la séquence codante.\nCDS 7..750\n•\nLigne 14 ( ) : le nom de la protéine produite.\n/product=\"trypsinogen\"\n•\nLignes 17 à 20 ( ) : la séquence protéique issue de la traduction de la séquence\n/translation=\"MNPLLIL...\ncodante.\n•\nLigne 22 ( ) : la délimitation du peptide signal.\nsig_peptide 7..51\nA.2.3 La séquence\n[...]\nORIGIN\n1 accaccatga atccactcct gatccttacc tttgtggcag ctgctcttgc tgcccccttt\n61 gatgatgatg acaagatcgt tgggggctac aactgtgagg agaattctgt cccctaccag\n121 gtgtccctga attctggcta ccacttctgt ggtggctccc tcatcaacga acagtgggtg\n181 gtatcagcag gccactgcta caagtcccgc atccaggtga gactgggaga gcacaacatc\n241 gaagtcctgg aggggaatga gcagttcatc aatgcagcca agatcatccg ccacccccaa\n301 tacgacagga agactctgaa caatgacatc atgttaatca agctctcctc acgtgcagta\n361 atcaacgccc gcgtgtccac catctctctg cccaccgccc ctccagccac tggcacgaag\n421 tgcctcatct ctggctgggg caacactgcg agctctggcg ccgactaccc agacgagctg\n481 cagtgcctgg atgctcctgt gctgagccag gctaagtgtg aagcctccta ccctggaaag\n541 attaccagca acatgttctg tgtgggcttc cttgagggag gcaaggattc atgtcagggt\n601 gattctggtg gccctgtggt ctgcaatgga cagctccaag gagttgtctc ctggggtgat\n661 ggctgtgccc agaagaacaa gcctggagtc tacaccaagg tctacaacta cgtgaaatgg\n721 attaagaaca ccatagctgc caatagctaa agcccccagt atctcttcag tctctatacc\n781 aataaagtga ccctgttctc\n//\nLa séquence est contenue entre les balises (ligne 2) et (ligne 17).\nORIGIN //\nChaque ligne est composée d’une série d’espaces, puis du numéro du premier nucléotide de la ligne, puis d’au plus\n6 blocs de 10 nucléotides. Chaque bloc est précédé d’un espace. Par exemple, ligne 10, le premier nucléotide de la ligne\n( ) est le numéro 421 dans la séquence.\nt\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 369\nAnnexe A. Quelques formats de données en biologie A.3. PDB\nA.2.4 Manipulation avec Python\nÀ partir de l’exemple précédent, voici comment lire un fichier GenBank avec Python et le module Biopython :\n1\nfrom Bio import SeqIO\n2 with open(\"M22612.gbk\", \"r\") as gbk_file:\n3\nrecord = SeqIO.read(gbk_file, \"genbank\")\n4 print(record.id)\n5\nprint(record.description)\n6 print(record.seq[:60])\nPour la séquence lue dans le fichier GenBank, on aﬀiche son identifiant, sa description et les 60 premiers résidus :\nM22612.1\nHuman pancreatic trypsin 1 (TRY1) mRNA, complete cds.\nACCACCATGAATCCACTCCTGATCCTTACCTTTGTGGCAGCTGCTCTTGCTGCCCCCTTT\nIl est également possible de lire un fichier GenBank sans le module Biopython. Une activité dédiée est proposée dans\nle chapitre 27 Mini-projets (en ligne)."
  },
  {
    "title": "A.3 PDB",
    "content": "8\nLa Protein Data Bank (PDB) est une banque de données qui contient les structures de biomacromolécules (protéines,\nADN, ARN, virus…). Historiquement, le format de fichier qui y est associé est le PDB, dont une documentation détaillée\n9\nest disponible sur le site éponyme . Les extensions de fichier pour ce format de données sont et surtout .\n.ent .pdb\nUn fichier PDB est constitué de deux parties principales : l’en-tête et les coordonnées.\n•\nL’en-tête est lisible et utilisable par un être humain (comme par une machine).\n•\nÀ l’inverse, les coordonnées sont surtout utilisables par un programme pour calculer certaines propriétés de la struc-\nture ou simplement la représenter sur l’écran d’un ordinateur. Bien sûr, un utilisateur expérimenté peut parfaitement\njeter un œil à cette seconde partie.\n10\nExaminons ces deux parties avec la trypsine bovine .\nA.3.1 En-tête\nPour la trypsine bovine, l’en-tête compte 510 lignes. En voici quelques unes :\n8. https://www.rcsb.org/\n9.\nhttp://www.wwpdb.org/documentation/file-format-content/format33/v3.3.html\n10. https://www.rcsb.org/structure/2PTN\n370 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nA.3. PDB Annexe A. Quelques formats de données en biologie\nHEADER HYDROLASE (SERINE PROTEINASE) 26-OCT-81 2PTN\nTITLE ON THE DISORDERED ACTIVATION DOMAIN IN TRYPSINOGEN.\nTITLE 2 CHEMICAL LABELLING AND LOW-TEMPERATURE CRYSTALLOGRAPHY\nCOMPND MOL_ID: 1;\nCOMPND 2 MOLECULE: TRYPSIN;\nCOMPND 3 CHAIN: A;\n[...]\nSOURCE 2 ORGANISM_SCIENTIFIC: BOS TAURUS;\n[...]\nEXPDTA X-RAY DIFFRACTION\n[...]\nREMARK 2 RESOLUTION. 1.55 ANGSTROMS.\n[...]\nDBREF 2PTN A 16 245 UNP P00760 TRY1_BOVIN 21 243\nSEQRES 1 A 223 ILE VAL GLY GLY TYR THR CYS GLY ALA ASN THR VAL PRO\nSEQRES 2 A 223 TYR GLN VAL SER LEU ASN SER GLY TYR HIS PHE CYS GLY\nSEQRES 3 A 223 GLY SER LEU ILE ASN SER GLN TRP VAL VAL SER ALA ALA\nSEQRES 4 A 223 HIS CYS TYR LYS SER GLY ILE GLN VAL ARG LEU GLY GLU\n[...]\nHELIX 1 H1 SER A 164 ILE A 176 1SNGL ALPHA TURN,REST IRREG. 13\nHELIX 2 H2 LYS A 230 VAL A 235 5CONTIGUOUS WITH H3 6\nHELIX 3 H3 SER A 236 ASN A 245 1CONTIGUOUS WITH H2 10\nSHEET 1 A 7 TYR A 20 THR A 21 0\nSHEET 2 A 7 LYS A 156 PRO A 161 -1 N CYS A 157 O TYR A 20\n[...]\nSSBOND 1 CYS A 22 CYS A 157 1555 1555 2.04\nSSBOND 2 CYS A 42 CYS A 58 1555 1555 2.02\n[...]\n•\nLigne 1. Cette ligne contient :\nHEADER\n— le nom de la protéine : HYDROLASE (SERINE PROTEINASE),\n— la date de dépôt de cette structure dans la banque de données : 26 octobre 1981\n— et l’identifiant de la structure dans la PDB, on parle souvent de « code PDB » : 2PTN.\n•\nLigne 2. correspond au titre de l’article scientifique dans lequel a été publié cette structure.\nTITLE\n•\nLignes 4-6. indique que la trypsine est composée d’une seule chaîne peptidique, appelée ici .\nCOMPND A\n•\nLigne 8. indique le nom scientifique de l’organisme dont provient cette protéine (ici, le bœuf).\nSOURCE\n•\nLigne 10. précise la technique expérimentale employée pour déterminer cette structure. Ici, la cristallogra-\nEXPDTA\nphie aux rayons X. Mais on peut également trouver SOLUTION NMR pour de la résonance magnétique nucléaire\nen solution, ELECTRON MICROSCOPY pour de la microscopie électronique.\n•\nLigne 12. précise, dans le cas d’une détermination par cristallographie aux rayons X, la résolution\nREMARK 2\nobtenue, ici 1,55 Angströms.\n•\nLigne 14. indique les liens éventuels vers d’autres banques de données. Ici, l’identifiant correspondant à\nDBREF\n11\ncette protéine dans UniProt (UNP) est P00760 .\n•\nLigne 15-18. donnent à la séquence de la protéine. Les résidus sont représentés par leur code à trois\nSEQRES\nlettres.\n• α β\nLignes 20-22 et 23-24. et correspondent aux structures secondaires hélices et brin de cette\nHELIX SHEET\nα\nprotéine. Ici, H1 SER A 164 ILE A 176 indique qu’il y a une première hélice (H1), comprise entre les résidus\nSer164 et Ile176 de la chaîne A.\n•\nLignes 26-27. indique les ponts disulfures. Ici, entre les résidus Cys22 et Cys157 et entre les résidus Cys42\nSSBOND\net Cys58.\nA.3.2 Coordonnées\nAvec la même protéine, la partie coordonnées représente plus de 1 700 lignes. En voici quelques unes correspondantes\nau résidu leucine 99 :\n11. https://www.uniprot.org/uniprot/P00760\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 371\nAnnexe A. Quelques formats de données en biologie A.3. PDB\n[...]\nATOM 601 N LEU A 99 10.007 19.687 17.536 1.00 12.25 N\nATOM 602 CA LEU A 99 9.599 18.429 18.188 1.00 12.25 C\nATOM 603 C LEU A 99 10.565 17.281 17.914 1.00 12.25 C\nATOM 604 O LEU A 99 10.256 16.101 18.215 1.00 12.25 O\nATOM 605 CB LEU A 99 8.149 18.040 17.853 1.00 12.25 C\nATOM 606 CG LEU A 99 7.125 19.029 18.438 1.00 18.18 C\nATOM 607 CD1 LEU A 99 5.695 18.554 18.168 1.00 18.18 C\nATOM 608 CD2 LEU A 99 7.323 19.236 19.952 1.00 18.18 C\n[...]\nChaque ligne correspond à un atome et débute par ou . désigne un atome de la structure de la\nATOM HETATM ATOM\nbiomolécule. est utilisé pour les atomes qui ne sont pas une biomolécule, comme les ions ou les molécules d’eau.\nHETATM\nToutes les lignes de coordonnées ont sensiblement le même format. Par exemple, pour la première ligne :\n•\n(ou ).\nATOM HETATM\n•\n: le numéro de l’atome.\n601\n•\n: le nom de l’atome. Ici, un atome d’azote du squelette peptidique. La structure complète du résidu leucine est\nN\nreprésentée figure A.1.\n•\n: le résidu dont fait partie l’atome. Ici, une leucine.\nLEU\n•\n: le nom de la chaîne peptidique.\nA\n•\n: le numéro du résidu dans la protéine.\n99\n•\n: la coordonnée x de l’atome.\n10.007\n•\n: la coordonnée y de l’atome.\n19.687\n•\n: la coordonnée z de l’atome.\n17.536\n•\n: le facteur d’occupation, c’est-à-dire la probabilité de trouver l’atome à cette position dans l’espace en\n1.00\nmoyenne. Cette probabilité est inférieure à 1 lorsque, expérimentalement, on n’a pas pu déterminer avec une totale\ncertitude la position de l’atome. Par exemple, dans le cas d’un atome très mobile dans une structure, qui est\ndéterminé comme étant à deux positions possibles, chaque position aura alors la probabilité .\n0.50\n•\n: le facteur de température, qui est proportionnel à la mobilité de l’atome dans l’espace. Les atomes situés\n12.25\nen périphérie d’une structure sont souvent plus mobiles que ceux situés au coeur de la structure.\n•\n: l’élément chimique de l’atome. Ici, l’azote.\nN\nUne documentation plus complète des différents champs qui constituent une ligne de coordonnées atomiques se trouve\n12\nsur le site de la PDB .\nLes résidus sont ensuite décrits les uns après les autres, atome par atome. Voici par exemple les premiers résidus de\nla trypsine bovine :\n[...]\nATOM 1 N ILE A 16 -8.155 9.648 20.365 1.00 10.68 N\nATOM 2 CA ILE A 16 -8.150 8.766 19.179 1.00 10.68 C\nATOM 3 C ILE A 16 -9.405 9.018 18.348 1.00 10.68 C\nATOM 4 O ILE A 16 -10.533 8.888 18.870 1.00 10.68 O\nATOM 5 CB ILE A 16 -8.091 7.261 19.602 1.00 10.68 C\nATOM 6 CG1 ILE A 16 -6.898 6.882 20.508 1.00 7.42 C\nATOM 7 CG2 ILE A 16 -8.178 6.281 18.408 1.00 7.42 C\nATOM 8 CD1 ILE A 16 -5.555 6.893 19.773 1.00 7.42 C\nATOM 9 N VAL A 17 -9.224 9.305 17.090 1.00 9.63 N\nATOM 10 CA VAL A 17 -10.351 9.448 16.157 1.00 9.63 C\nATOM 11 C VAL A 17 -10.500 8.184 15.315 1.00 9.63 C\nATOM 12 O VAL A 17 -9.496 7.688 14.748 1.00 9.63 O\nATOM 13 CB VAL A 17 -10.123 10.665 15.222 1.00 9.63 C\nATOM 14 CG1 VAL A 17 -11.319 10.915 14.278 1.00 11.95 C\nATOM 15 CG2 VAL A 17 -9.737 11.970 15.970 1.00 11.95 C\n[...]\nVous remarquerez que le numéro du premier résidu est 16 et non pas 1. Cela s’explique par la technique expérimentale\nutilisée qui n’a pas permis de déterminer la structure des 15 premiers résidus.\nLa structure de la trypsine bovine n’est constituée que d’une seule chaîne peptidique (notée ). Lorsqu’une structure\nA\nest composée de plusieurs chaînes, comme dans le cas de la structure du récepteur GABAB 1 et 2 chez la drosophile\n12. http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html\n372 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nA.3. PDB Annexe A. Quelques formats de données en biologie\nFigure A.1 – Structure tridimensionnelle d’un résidu leucine. Les noms des atomes sont indiqués en noir.\n13\n(code PDB 5X9X ) :\n[...]\nATOM 762 HB1 ALA A 44 37.162 -2.955 2.220 1.00 0.00 H\nATOM 763 HB2 ALA A 44 38.306 -2.353 3.417 1.00 0.00 H\nATOM 764 HB3 ALA A 44 38.243 -1.621 1.814 1.00 0.00 H\nTER 765 ALA A 44\nATOM 766 N GLY B 95 -18.564 3.009 13.772 1.00 0.00 N\nATOM 767 CA GLY B 95 -19.166 3.646 12.621 1.00 0.00 C\nATOM 768 C GLY B 95 -20.207 2.755 11.976 1.00 0.00 C\n[...]\nLa première chaîne est notée et la seconde . La séparation entre les deux chaînes est marquée par la ligne :\nA B\nTER 765 ALA A 44\nDans un fichier PDB, chaque structure porte un nom de chaîne différent (par exemple : A B C‘, etc.).\n, ,\nEnfin, lorsque la structure est déterminée par RMN, il est possible que plusieurs structures soient présentes dans le\nmême fichier PDB. Toutes ces structures, ou « modèles », sont des solutions possibles du jeu de contraintes mesurées\nexpérimentalement en RMN. Voici un exemple, toujours pour la structure du récepteur GABAB 1 et 2 chez la drosophile :\n13. http://www.rcsb.org/structure/5X9X\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 373\nAnnexe A. Quelques formats de données en biologie A.3. PDB\n[...]\nMODEL 1\nATOM 1 N MET A 1 -27.283 -9.772 5.388 1.00 0.00 N\nATOM 2 CA MET A 1 -28.233 -8.680 5.682 1.00 0.00 C\n[...]\nATOM 1499 HG2 GLU B 139 36.113 -5.242 2.536 1.00 0.00 H\nATOM 1500 HG3 GLU B 139 37.475 -4.132 2.428 1.00 0.00 H\nTER 1501 GLU B 139\nENDMDL\nMODEL 2\nATOM 1 N MET A 1 -29.736 -10.759 4.394 1.00 0.00 N\nATOM 2 CA MET A 1 -28.372 -10.225 4.603 1.00 0.00 C\n[...]\nATOM 1499 HG2 GLU B 139 36.113 -5.242 2.536 1.00 0.00 H\nATOM 1500 HG3 GLU B 139 37.475 -4.132 2.428 1.00 0.00 H\nTER 1501 GLU B 139\nENDMDL\nMODEL 2\nATOM 1 N MET A 1 -29.736 -10.759 4.394 1.00 0.00 N\nATOM 2 CA MET A 1 -28.372 -10.225 4.603 1.00 0.00 C\n[...]\nChaque structure est encadrée par les lignes :\nMODEL n\net :\nENDMDL\noù n est le numéro du modèle. Pour la structure du récepteur GABAB 1 et 2, il y a 20 modèles de décrits dans le\nfichier PDB.\nA.3.3 Manipulation avec Python\nLe module Biopython peut également lire un fichier PDB.\nVoici comment charger la structure de la trypsine bovine :\n1 from Bio.PDB import PDBParser\n2 parser = PDBParser()\n3\nprot_id = \"2PTN\"\n4 prot_file = \"2PTN.pdb\"\n5\nstructure = parser.get_structure(prot_id, prot_file)\nRemarque\nLes fichiers PDB sont parfois (très) mal formatés. Si Biopython ne parvient pas à lire un tel fichier, remplacez alors\nla ligne 2 par . Soyez néanmoins très prudent quant aux résultats obtenus.\nparser = PDBParser(PERMISSIVE=1)\nAﬀichage du nom de la structure et de la technique expérimentale utilisée pour déterminer la structure :\n1 print(structure.header[\"head\"])\n2\nprint(structure.header[\"structure_method\"])\nce qui produit :\n1 hydrolase (serine proteinase)\n2\nx-ray diffraction\nExtraction des coordonnées de l’atome du résidu Ile16 et de l’atome du résidu Val17 :\nN CA\n374 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nA.3. PDB Annexe A. Quelques formats de données en biologie\n1\nmodel = structure[0]\n2 chain = model[\"A\"]\n3\nres1 = chain[16]\n4 res2 = chain[17]\n5\nprint(res1.resname, res1[\"N\"].coord)\n6 print(res2.resname, res2[\"CA\"].coord)\nce qui produit :\n1\nILE [ -8.15499973 9.64799976 20.36499977]\n2 VAL [-10.35099983 9.44799995 16.15699959]\nL’objet est un array de NumPy (voir le chapitre 20 Module NumPy). On peut alors obtenir\nres1[\"N\"].coord\nsimplement les coordonnées x, y et z d’un atome :\n1 print(res1[\"N\"].coord[0], res1[\"N\"].coord[1], res1[\"N\"].coord[2])\nce qui produit :\n1 -8.155 9.648 20.365\nRemarque\nBiopython utilise la hiérarchie suivante :\nstructure > model > chain > residue > atom\nmême lorsque la structure ne contient qu’un seul modèle. C’est d’ailleurs le cas ici, puisque la structure a été obtenue\npar cristallographie aux rayons X.\nα\nEnfin, pour aﬀicher les coordonnées des carbones (notés ) des 10 premiers résidus (à partir du résidu 16, car\nCA\nc’est le premier résidu dont on connaît la structure) :\n1\nres_start = 16\n2 model = structure[0]\n3\nchain = model[\"A\"]\n4 for i in range(10):\n5\nidx = res_start + i\n6 print(chain[idx].resname, idx, chain[idx][\"CA\"].coord)\navec pour résultat :\nILE 16 [ -8.14999962 8.76599979 19.17900085]\nVAL 17 [-10.35099983 9.44799995 16.15699959]\nGLY 18 [-12.02099991 6.63000011 14.25899982]\nGLY 19 [-10.90200043 3.89899993 16.68400002]\nTYR 20 [-12.65100002 1.44200003 19.01600075]\nTHR 21 [-13.01799965 0.93800002 22.76000023]\nCYS 22 [-10.02000046 -1.16299999 23.76000023]\nGLY 23 [-11.68299961 -2.86500001 26.7140007 ]\nALA 24 [-10.64799976 -2.62700009 30.36100006]\nASN 25 [ -6.96999979 -3.43700004 31.02000046]\nIl est aussi très intéressant (et formateur) d’écrire son propre parser de fichier PDB, c’est-à-dire un programme qui\nlit un fichier PDB (sans le module Biopython). Dans ce cas, la figure A.2 vous aidera à déterminer comment extraire les\ndifférentes informations d’une ligne de coordonnées ou .\nATOM HETATM\nExemple : pour extraire le nom du résidu, il faut isoler le contenu des colonnes 18 à 20 du fichier PDB, ce qui\ncorrespond aux index de 17 à 19 pour une chaîne de caractères en Python (soit la tranche de chaîne de caractères\n, car la première borne est incluse et la seconde exclue).\n[17:20]\nα\nPour lire le fichier PDB de la trypsine bovine ( ) et extraire (encore) les coordonnées des carbones des 10\n2PTN.pdb\npremiers résidus, nous pouvons utiliser le code suivant :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 375\nAnnexe A. Quelques formats de données en biologie A.4. Format XML, CSV et TSV\n1\nwith open(\"2PTN.pdb\", \"r\") as pdb_file:\n2 res_count = 0\n3\nfor line in pdb_file:\n4 if line.startswith(\"ATOM\"):\n5\natom_name = line[12:16].strip()\n6 res_name = line[17:20].strip()\n7 res_num = int(line[22:26])\n8\nif atom_name == \"CA\":\n9 res_count += 1\n10\nx = float(line[30:38])\n11 y = float(line[38:46])\n12\nz = float(line[46:54])\n13 print(res_name, res_num, x, y, z)\n14\nif res_count >= 10:\n15 break\nce qui donne :\nILE 16 -8.15 8.766 19.179\nVAL 17 -10.351 9.448 16.157\nGLY 18 -12.021 6.63 14.259\nGLY 19 -10.902 3.899 16.684\nTYR 20 -12.651 1.442 19.016\nTHR 21 -13.018 0.938 22.76\nCYS 22 -10.02 -1.163 23.76\nGLY 23 -11.683 -2.865 26.714\nALA 24 -10.648 -2.627 30.361\nASN 25 -6.97 -3.437 31.02\nRemarque\nPour extraire des valeurs numériques, comme des numéros de résidus ou des coordonnées atomiques, il ne faudra pas\noublier de les convertir en entiers ou en floats."
  },
  {
    "title": "A.4 Format XML, CSV et TSV",
    "content": "Les formats XML, CSV et TSV dont des formats de fichiers très largement utilisés en informatique. Ils sont également\ntrès utilisés en biologie. En voici quelques exemples :\nA.4.1 XML\nLe format XML est un format de fichier à balises qui permet de stocker quasiment n’importe quel type d’information\nde façon structurée et hiérarchisée. L’acronyme XML signifie Extensible Markup Language qui pourrait se traduire en\n14\nfrançais par « Langage de balisage extensible ». Les balises dont il est question servent à délimiter du contenu :\n<balise>contenu</balise>\nLa balise est une balise ouvrante. La balise est une balise fermante. Notez le caractère qui\n<balise> </balise> /\nmarque la différence entre une balise ouvrante et une balise fermante.\nIl existe également des balises vides, qui sont à la fois ouvrantes et fermantes :\n<balise />\nUne balise peut avoir certaines propriétés, appelées attributs, qui sont définies, dans la balise ouvrante. Par exemple :\n<balise propriété1=valeur1 propriété2=valeur2>contenu</balise>\nUn attribut est un couple nom et valeur (par exemple est un nom et est la valeur associée).\npropriété1 valeur1\nEnfin, les balises peuvent être imbriquées les unes dans les autres :\n14. https://fr.wikipedia.org/wiki/Extensible_Markup_Language\n376 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nA.4. Format XML, CSV et TSV Annexe A. Quelques formats de données en biologie\n<protein>\n<element>élément 1</element>\n<element>élément 2</element>\n<element>élément 3</element>\n</protein>\nDans cet exemple, nous avons trois balises qui sont contenues dans une balise .\nelement protein\n15 16\nVoici un autre exemple avec l’enzyme trypsine humaine (code P07477 ), telle qu’on peut la trouver décrite dans\nla base de données UniProt :\n<?xml version='1.0' encoding='UTF-8'?>\n<uniprot xmlns=\"http://uniprot.org/uniprot\" xmlns:xsi=[...]>\n<entry dataset=\"Swiss-Prot\" created=\"1988-04-01\" modified=\"2018-09-12\" [...]>\n<accession>P07477</accession>\n<accession>A1A509</accession>\n[...]\n<gene>\n<name type=\"primary\">PRSS1</name>\n<name type=\"synonym\">TRP1</name>\n<name type=\"synonym\">TRY1</name>\n</gene>\n[...]\n<sequence length=\"247\" mass=\"26558\" checksum=\"DD49A487B8062813\" [...]>\nMNPLLILTFVAAALAAPFDDDDKIVGGYNCEENSVPYQVSLNSGYHFCGGSLINEQWVVS\nAGHCYKSRIQVRLGEHNIEVLEGNEQFINAAKIIRHPQYDRKTLNNDIMLIKLSSRAVIN\nARVSTISLPTAPPATGTKCLISGWGNTASSGADYPDELQCLDAPVLSQAKCEASYPGKIT\nSNMFCVGFLEGGKDSCQGDSGGPVVCNGQLQGVVSWGDGCAQKNKPGVYTKVYNYVKWIK\nNTIAANS\n</sequence>\n</entry>\n[...]\n</uniprot>\n•\nLa ligne 1 indique que nous avons bien un fichier au format XML.\n•\nLa ligne 3 indique que nous avons une entrée UniProt. Il s’afit d’une balise ouvrante avec plusieurs attributs\n( , , etc.).\ndataset=\"Swiss-Prot\" created=\"1988-04-01\"\n•\nLes lignes 4 et 5 précisent les numéros d’accession dans la base de données UniProt qui font référence à cette\nmême protéine.\n•\nLes lignes 8-10 listent les quatre gènes correspondants à cette protéine. Le premier gène porte l’attribut\ntype\net indique qu’il s’agit du nom oﬀiciel du gène de la trypsine. L’attribut pour les\n=\"primary\" type=\"synonym\"\nautres gènes indique qu’il s’agit bien de noms synonymes pour le gène .\nPRSS1\n•\nLes lignes 13-18 contiennent la séquence de la trypsine. Dans les attributs de la balise , on retrouve,\n<sequence>\npar exemple, la taille de la protéine ( ).\nlength=\"247\"\nVoici un exemple de code Python pour manipuler le fichier XML de la trypsine humaine :\n1\nfrom lxml import etree\n2 import re\n3\n4 with open(\"P07477.xml\") as xml_file:\n5 xml_content = xml_file.read()\n6\n7 xml_content = re.sub(\"<uniprot [^>]+>\", \"<uniprot>\", xml_content)\n8\n9 root = etree.fromstring(xml_content.encode(\"utf-8\"))\n10\n11 for gene in root.xpath(\"/uniprot/entry/gene/name\"):\n12\nprint(f\"gene : {gene.text} ({gene.get('type')})\")\n13\n14\nsequence = root.xpath(\"/uniprot/entry/sequence\")[0]\n15 print(f\"sequence: {sequence.text.strip()}\")\n16\nprint(f\"length: {sequence.get('length')}\")\n•\nLigne 1. On utilise le sous-module du module lxml pour lire le fichier XML.\netree\n15.\nhttps://www.uniprot.org/uniprot/P07477\n16. https://www.uniprot.org/uniprot/P07477.xml\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 377\nAnnexe A. Quelques formats de données en biologie A.4. Format XML, CSV et TSV\n•\nLigne 2. On utilise le module d’expressions régulières re pour supprimer tous les attributs de la balise\nuniprot\n(ligne 7). Nous ne rentrerons pas dans les détails, mais ces attributs rendent plus complexe la lecture du fichier\nXML.\n•\nLigne 9. La variable contient le fichier XML prêt à être manipulé.\nroot\n•\nLigne 11. On recherche les noms des gènes (balises ) associés à la trypsine. Pour cela, on utilise\n<name></name>\nla méthode , avec comme argument l’enchaînement des différentes balises qui conduisent aux noms des\n.xpath()\ngènes.\n•\nLigne 12. Pour chaque nom de gène, on va aﬀicher son contenu ( ) et la valeur associée à l’attribut\ngene.text\navec la méthode .\ntype .get(\"type\")\n•\nLigne 14. On stocke dans la variable la balise associée à la séquence de la protéine. Comme\nsequence root.\nrenvoie un itérateur et qu’il n’y a qu’une seule balise séquence, on prend\nxpath(\"/uniprot/entry/sequence\")\nici le seul et unique élément .\nroot.xpath(\"/uniprot/entry/sequence\")[0]\n•\nLigne 15. On aﬀiche le contenu de la séquence , nettoyé d’éventuels retours chariots ou espaces\nsequence.text\n.\nsequence.text.strip()\n•\nLigne 16. On aﬀiche la taille de la séquence en récupérant la valeur de l’attribut (toujours de la balise\nlength\n).\n<sequence></sequence>\nLe résultat obtenu est le suivant :\ngene : PRSS1 (primary)\ngene : TRP1 (synonym)\ngene : TRY1 (synonym)\ngene : TRYP1 (synonym)\nsequence: MNPLLILTFVAAALAAPFDDDDKIVGGYNCEENSVPYQVSLNSGYHFCGGSLINEQWVVS\nAGHCYKSRIQVRLGEHNIEVLEGNEQFINAAKIIRHPQYDRKTLNNDIMLIKLSSRAVIN\nARVSTISLPTAPPATGTKCLISGWGNTASSGADYPDELQCLDAPVLSQAKCEASYPGKIT\nSNMFCVGFLEGGKDSCQGDSGGPVVCNGQLQGVVSWGDGCAQKNKPGVYTKVYNYVKWIK\nNTIAANS\nlength: 247\nA.4.2 CSV et TSV\nA.4.2.1 Définition des formats\nL’acronyme CSV signifie « Comma-Separated values », qu’on peut traduire littéralement par « valeurs séparées par\ndes virgules ». De façon similaire, TSV signifie « Tabulation-Separated Values », soit des « valeurs séparées par des\ntabulations ».\nCes deux formats sont utiles pour stocker des données structurées sous forme de tableau, comme vous pourriez l’avoir\ndans un tableur.\nÀ titre d’exemple, le tableau ci-dessous liste les structures associées à la transferrine, protéine présente dans le plasma\nsanguin et impliquée dans la régulation du fer. Ces données proviennent de la Protein Data Bank (PDB). Pour chaque\nprotéine (PDB ID) est indiqué le nom de l’organisme associé (Source), la date à laquelle cette structure a été déposée\ndans la PDB (Deposit Date), le nombre d’acides aminés de la protéine et sa masse moléculaire (MW).\nPDB ID Source Deposit Date Length MW\n1A8E Homo sapiens 1998-03-24 329 36408.40\n1A8F Homo sapiens 1998-03-25 329 36408.40\n1AIV Gallus gallus 1997-04-28 686 75929.00\n1AOV Anas platyrhynchos 1996-12-11 686 75731.80\n[…] […] […] […] […]\n17\nVoici maintenant l’équivalent en CSV :\n17. https://python.sdv.u-paris.fr/data-files/transferrin_report.csv\n378 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nA.4. Format XML, CSV et TSV Annexe A. Quelques formats de données en biologie\nPDB ID,Source,Deposit Date,Length,MW\n1A8E,Homo sapiens,1998-03-24,329,36408.40\n1A8F,Homo sapiens,1998-03-25,329,36408.40\n1AIV,Gallus gallus,1997-04-28,686,75929.00\n1AOV,Anas platyrhynchos,1996-12-11,686,75731.80\n[...]\nSur chaque ligne, les différentes valeurs sont séparées par une virgule. La première ligne contient le nom des colonnes\net est appelée ligne d’en-tête.\n18\nL’équivalent en TSV est :\nPDB ID Source Deposit Date Length MW\n1A8E Homo sapiens 1998-03-24 329 36408.40\n1A8F Homo sapiens 1998-03-25 329 36408.40\n1AIV Gallus gallus 1997-04-28 686 75929.00\n1AOV Anas platyrhynchos 1996-12-11 686 75731.80\n[...]\nSur chaque ligne, les différentes valeurs sont séparées par une tabulation.\nAttention\nLe caractère tabulation est un caractère invisible « élastique », c’est-à-dire qu’il a une largeur variable suivant l’éditeur\nde texte utilisé. Par exemple, dans la ligne d’en-tête, l’espace entre PDB ID et Source apparaît comme différent de\nl’espace entre Deposit Date et Length alors qu’il y a pourtant une seule tabulation à chaque fois.\nA.4.2.2 Lecture\nEn Python, le module csv de la bibliothèque standard est très pratique pour lire et écrire des fichiers au format CSV\n19\net TSV. Nous vous conseillons de lire la documentation très complète sur ce module .\nVoici un exemple :\n1\nimport csv\n2\n3\nwith open(\"transferrin_report.csv\") as f_in:\n4 f_reader = csv.DictReader(f_in)\n5\nfor row in f_reader:\n6 print(row[\"PDB ID\"], row[\"Deposit Date\"], row[\"Length\"])\n•\nLigne 1. Chargement du module csv.\n•\nLigne 3. Ouverture du fichier.\n•\nLigne 4. Utilisation du module csv pour lire le fichier CSV comme un dictionnaire (fonction ). La\nDictReader()\nligne d’en-tête est utilisée automatiquement pour définir les clés du dictionnaire.\n•\nLigne 5. Parcours de toutes les lignes du fichier CSV.\n•\nLigne 6. Aﬀichage des champs correspondants à PDB ID, Deposit Date, Length.\nLe résultat obtenu est :\n1A8E 1998-03-24 329\n1A8F 1998-03-25 329\n1AIV 1997-04-28 686\n1AOV 1996-12-11 686\n[...]\nIl suﬀit de modifier légèrement le script précédent pour lire un fichier TSV :\n18.\nhttps://python.sdv.u-paris.fr/data-files/transferrin_report.tsv\n19. https://docs.python.org/fr/3.7/library/csv.html\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 379\nAnnexe A. Quelques formats de données en biologie A.4. Format XML, CSV et TSV\n1\nimport csv\n2\n3\nwith open(\"transferrin_PDB_report.tsv\") as f_in:\n4 f_reader = csv.DictReader(f_in, delimiter=\"\\t\")\n5\nfor row in f_reader:\n6 print(row[\"PDB ID\"], row[\"Deposit Date\"], row[\"Length\"])\n•\nLigne 3. Modification du nom du fichier lu.\n•\nLigne 4. Utilisation de l’argument , qui indique que les champs sont séparés par des tabulations.\ndelimiter=\"\\t\"\nLe résultat obtenu est strictement identique au précédent.\nA.4.2.3 Écriture\nVoici un exemple d’écriture de fichier CSV :\n1 import csv\n2\n3 with open(\"test.csv\", \"w\") as f_out:\n4\nfields = [\"Name\", \"Quantity\"]\n5 f_writer = csv.DictWriter(f_out, fieldnames=fields)\n6\nf_writer.writeheader()\n7 f_writer.writerow({\"Name\": \"girafe\", \"Quantity\":5})\n8\nf_writer.writerow({\"Name\": \"tigre\", \"Quantity\":3})\n9 f_writer.writerow({\"Name\": \"singe\", \"Quantity\":8})\n•\nLigne 3. Ouverture du fichier en lecture.\ntest.csv\n•\nLigne 4. Définition du nom des colonnes (Name et Quantity).\n•\nLigne 5. Utilisation du module csv pour écrire un fichier CSV à partir d’un dictionnaire.\n•\nLigne 6. Écriture des noms des colonnes.\n•\nLigne 7-9. Écriture de trois lignes. Pour chaque ligne, un dictionnaire dont les clefs sont les noms des colonnes est\nfourni comme argument à la méthode .\n.writerow()\nLe contenu du fichier est alors :\ntest.csv\nName,Quantity\ngirafe,5\ntigre,3\nsinge,8\nDe façon très similaire, l’écriture d’un fichier TSV est réalisée avec le code suivant :\n1\nimport csv\n2\n3\nwith open(\"test.tsv\", \"w\") as f_out:\n4 fields = [\"Name\", \"Quantity\"]\n5\nf_writer = csv.DictWriter(f_out, fieldnames=fields, delimiter=\"\\t\")\n6 f_writer.writeheader()\n7\nf_writer.writerow({\"Name\": \"girafe\", \"Quantity\":5})\n8 f_writer.writerow({\"Name\": \"tigre\", \"Quantity\":3})\n9 f_writer.writerow({\"Name\": \"singe\", \"Quantity\":8})\n•\nLigne 3. Modification du nom du fichier en écriture.\n•\nLigne 5. Utilisation de l’argument , qui indique que les champs sont séparés par des tabulations.\ndelimiter=\"\\t\"\nLe contenu du fichier est :\ntest.tsv\nName Quantity\ngirafe 5\ntigre 3\nsinge 8\nVous êtes désormais capables de lire et écrire des fichiers aux formats CSV et TSV. Les codes que nous vous avons\nproposés ne sont que des exemples. À vous de poursuivre l’exploration du module csv.\nRemarque\n380 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nA.4. Format XML, CSV et TSV Annexe A. Quelques formats de données en biologie\nLe module pandas décrit dans le chapitre 22 Module Pandas est tout à fait capable de lire et écrire des fichiers CSV\net TSV. Nous vous conseillons de l’utiliser si vous analysez des données avec ces types de fichiers.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 381\nAnnexe A. Quelques formats de données en biologie A.4. Format XML, CSV et TSV\nFigure A.2 – Format PDB et les différents champs de coordonnées.\n382 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  },
  {
    "title": "Installation de Python",
    "content": "Attention\nLa procédure d’installation ci-dessous a été testée avec la version Miniconda\nLatest - Conda 24.5.0 Python\n.\n3.12.4 released Jun 26, 2024\nPython est déjà présent sous Linux ou Mac OS X et s’installe très facilement sous Windows. Toutefois, nous décri-\nvons dans cet ouvrage l’utilisation de modules supplémentaires qui sont très utiles en bioinformatique (NumPy, scipy,\nmatplotlib, pandas, Biopython), mais également les notebooks Jupyter.\nOn va donc utiliser un gestionnaire de paquets qui va installer ces modules supplémentaires. On souhaite également que\nce gestionnaire de paquets soit disponible pour Windows, Mac OS X et Linux. Fin 2018, il y a deux grandes alternatives :\n1\n1. Anaconda et Miniconda : Anaconda est une distribution complète de Python qui contient un gestionnaire de\npaquets très puissant nommé conda. Anaconda installe de très nombreux paquets et outils mais nécessite un espace\n2\ndisque de plusieurs gigaoctets. Miniconda est une version allégée d’Anaconda, donc plus rapide à installer et\noccupant peu d’espace sur le disque dur. Le gestionnaire de paquet conda est aussi présent dans Miniconda.\n3\n2. Pip : pip est le gestionnaire de paquets de Python et qui est systématiquement présent depuis la version 3.4."
  },
  {
    "title": "B.1 Que recommande-t-on pour l’installation de Python ?",
    "content": "Quel que soit le système d’exploitation, nous recommandons l’utilisation de Miniconda dont la procédure d’installation\nest détaillée ci-dessous pour Windows, Mac OS X et Linux. Le gestionnaire de paquets conda est très eﬀicace. Il gère la\nversion de Python et les paquets compatibles avec cette dernière de manière optimale.\nPar ailleurs, nous vous recommandons vivement la lecture de la rubrique sur les éditeurs de texte. Il est en effet\nfondamental d’utiliser un éditeur robuste et de savoir le configurer pour « pythonner » eﬀicacement.\nEnfin, dans tout ce qui suit, nous partons du principe que vous installerez Miniconda en tant qu’utilisateur, et non\npas en tant qu’administrateur. Autrement dit, vous n’aurez pas besoin de droits spéciaux pour pouvoir installer Miniconda\net les autres modules nécessaires. La procédure proposée a été testée avec succès sous Windows 10 et 11, Mac OS X,\nUbuntu 22.04 et 24.04).\n1. https://www.anaconda.com/\n2.\nhttps://conda.io/miniconda.html\n3. https://pip.pypa.io/en/stable/\n383\nAnnexe B. Installation de Python B.2. Installation de Python avec Miniconda\n4\nDepuis quelques années, Windows 10 (et 11) propose le WSL (Windows Subsystem for Linux). Le WSL permet de\nlancer un terminal Linux au sein de Windows et propose (quasiment) toutes les fonctionnalités disponibles sous un vrai\nsystème Linux. Nous ne détaillons par comment l’installer, mais vous pouvez vous référer à la page d’installation sur le site\n5\nde Microsoft . Si vous avez installé WSL sur votre ordinateur, nous vous recommandons de suivre la procédure ci-dessous\ncomme si vous étiez sous Linux (rubrique Installation de Python avec Miniconda pour Linux), plutôt que d’installer la\nversion Windows."
  },
  {
    "title": "B.2 Installation de Python avec Miniconda",
    "content": "6\nNous vous conseillons l’installation de la distribution Miniconda qui présente l’avantage d’installer Python et un\npuissant gestionnaire de paquets appelé conda. Dans toute la suite de cette annexe, l’indication avec le $ et un espace\ncomme suit :\n$\nsignifie l’invite d’un shell quel qu’il soit (PowerShell sous Windows, bash sous Mac OS X et Linux).\nB.2.1 Installation de Python avec Miniconda pour Linux\nDans un navigateur internet, ouvrez la page du site Miniconda puis\nhttps://conda.io/miniconda.html\ncliquez sur le lien Miniconda3 Linux 64-bit correspondant à Linuxet et Python 3.12.\nVous allez télécharger un fichier dont le nom ressemble à quelque chose du type :\n.\nMiniconda3-latest-Linux-x86_64.sh\nDans un shell, lancez l’installation de Miniconda avec la commande :\n$ bash Miniconda3-latest-Linux-x86_64.sh\nDans un premier temps, validez la lecture de la licence d’utilisation :\nWelcome to Miniconda3 py312_24.5.0-0\nIn order to continue the installation process, please review the license\nagreement.\nPlease, press ENTER to continue\n>>>\nComme demandé, appuyez sur la touche Entrée. Faites ensuite défiler la licence d’utilisation avec la touche Espace.\nTapez puis appuyez sur la touche Entrée pour valider :\nyes\nDo you accept the license terms? [yes|no]\n[no] >>> yes\nLe programme d’installation vous propose ensuite d’installer Miniconda dans le répertoire dans votre\nminiconda3\nrépertoire personnel. Par exemple, dans le répertoire si votre nom d’utilisateur est .\n/home/pierre/miniconda3 pierre\nValidez cette proposition en appuyant sur la touche Entrée :\nMiniconda3 will now be installed into this location:\n/home/pierre/miniconda3\n- Press ENTER to confirm the location\n- Press CTRL-C to abort the installation\n- Or specify a different location below\n[/home/pierre/miniconda3] >>>\nLe programme d’installation va alors installer Python et le gestionnaire de paquets conda.\nCette étape terminée, le programme d’installation vous propose d’initialiser conda pour que celui-ci soit accessible à\nchaque fois que vous ouvrez un shell. Nous vous conseillons d’accepter en tapant puis en appuyant sur la touche\nyes\nEntrée.\n4. https://fr.wikipedia.org/wiki/Windows_Subsystem_for_Linux\n5.\nhttps://learn.microsoft.com/fr-fr/windows/wsl/install\n6. https://conda.io/miniconda.html\n384 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.2. Installation de Python avec Miniconda Annexe B. Installation de Python\nDo you wish the installer to initialize Miniconda3\nby running conda init? [yes|no]\n[no] >>> yes\nL’installation de Miniconda est terminée. L’espace utilisé par Miniconda sur votre disque dur est d’environ 450 Mo.\nB.2.1.1 Test de l’interpréteur Python\nOuvrez un nouveau shell. Vous devriez voir dans votre invite la chaîne indiquant que l’environnement conda\n(base)\nde base est activé. À partir de maintenant, lorsque vous taperez la commande , c’est le Python 3 de Miniconda\npython\nqui sera lancé :\n$ python\nPython 3.12.4 | packaged by Anaconda, Inc. | (main, Jun 18 2024, 15:12:24) [GCC 11.2.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\nQuittez Python en tapant la commande puis appuyant sur la touche Entrée.\nexit()\nB.2.1.2 Test du gestionnaire de paquets conda\nDe retour dans le shell, testez si le gestionnaire de paquets conda est fonctionnel. Tapez la commande dans\nconda\nle shell, vous devriez avoir la sortie suivante :\n$ conda\nusage: conda [-h] [-v] [--no-plugins] [-V] COMMAND ...\nconda is a tool for managing and deploying applications, environments and packages.\noptions:\n-h, --help Show this help message and exit.\n[...]\nSi c’est bien le cas, bravo, conda et bien installé et vous pouvez passez à la suite (rendez-vous à la rubrique Installation\ndes modules supplémentaires) !\nB.2.1.3 Désinstallation de Miniconda\nSi vous souhaitez supprimer Miniconda, rien de plus simple, il suﬀit de suivre ces deux étapes :\nÉtape 1. Supprimer le répertoire de Miniconda. Par exemple pour l’utilisateur :\npierre\n$ rm -rf /home/pierre/miniconda3\nÉtape 2. Dans le fichier de configuration du shell Bash, supprimer les lignes comprises entre\n# >>> conda initialize >>>\net\n# <<< conda initialize <<<\nB.2.2 Installation de Python avec Miniconda pour Mac OS X\nDans un navigateur internet, ouvrez la page du site Miniconda puis\nhttps://conda.io/miniconda.html\ncliquez sur le lien Miniconda3 macOS Intel x86 64-bit bash correspondant à Mac OS X et Python 3.12.\nVous allez télécharger un fichier dont le nom ressemble à quelque chose du type :\n.\nMiniconda3-latest-MacOSX-x86_64.sh\nLe système d’exploitation Mac OS X étant basé sur Unix, la suite de la procédure est en tout point identique à la\nprocédure détaillée à la rubrique précédente pour Linux.\nDonc, lancez la commande :\n$ bash Miniconda3-latest-MacOSX-x86_64.sh\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 385\nAnnexe B. Installation de Python B.2. Installation de Python avec Miniconda\npuis suivez les mêmes instructions que dans la rubrique précédente (la seule petite subtilité est pour le chemin,\nchoisissez sous Mac au lieu de\n/User/votre_nom_utilisateur/miniconda3 /home/votre_nom_utilisateur/\nsous Linux).\nminiconda3\nB.2.3 Installation de Python avec Miniconda pour Windows 10 et 11\nDans cette rubrique, nous détaillons l’installation de Miniconda sous Windows.\nAttention\nNous partons du principe qu’aucune version d’Anaconda, Miniconda, ou encore de Python « classique » (obtenue sur\n7\nle site oﬀiciel de Python ) n’est installée sur votre ordinateur. Si tel est le cas, nous vous recommandons vivement de la\ndésinstaller pour éviter des conflits de version.\n•\nDans un navigateur internet, ouvrez la page du site Miniconda https://conda.io/miniconda.html puis\ncliquez sur le lien Miniconda3 Windows 64-bit correspondant à Windows et Python 3.12. Vous allez télécharger un\nfichier dont le nom ressemble à quelque chose du type : .\nMiniconda3-latest-Windows-x86_64.exe\n•\nUne fois téléchargé, double-cliquez sur ce fichier, cela lancera l’installateur de Miniconda :\nFigure B.1 – Installation Miniconda étape 1.\n•\nCliquez sur Next, vous arrivez alors sur l’écran suivant :\n•\nLisez la licence et (si vous êtes d’accord) cliquez sur I agree. Vous aurez ensuite :\n•\nGardez le choix de l’installation seulement pour vous (case cochée à Just me (recommended)), puis cliquez sur\nNext. Vous aurez ensuite :\n•\nL’installateur vous demande où installer Miniconda, nous vous recommandons de laisser le choix par défaut (res-\nsemblant à ). Cliquez sur Next, vous arriverez sur :\nC:\\Users\\votre_nom_utilisateur\\Miniconda3\n•\nGardez la case Register Anaconda as my default Python 3.12 cochée et ne cochez pas la case Add Anaconda to\nmy PATH environment variable. Vous pouvez garder la case Create Shortcuts cochée. Cliquez ensuite sur Install,\nl’installation se lance et durera quelques minutes :\n•\nÀ la fin, vous obtiendrez :\n•\nDécochez les cases Learn more about Anaconda Cloud et Learn how to get started with Anaconda et cliquez sur\nFinish. Miniconda est maintenant installé.\n7. https://www.python.org/downloads/\n386 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.2. Installation de Python avec Miniconda Annexe B. Installation de Python\nFigure B.2 – Installation Miniconda étape 2.\nFigure B.3 – Installation Miniconda étape 3.\nB.2.3.1 Initialisation de conda\nIl nous faut maintenant initialiser conda. Cette manipulation va permettre de le rendre visible dans n’importe quel\nshell Powershell.\nL’installateur a en principe ajouté des nouveaux raccourcis dans le Menu Démarrer contenant le mot :\nAnaconda\n•\n: pour lancer un shell Powershell (shell standard de Windows\nAnaconda Powershell Prompt (Miniconda3)\néquivalent du bash sous Linux) avec conda qui est activé correctement ;\n•\n: même chose mais avec le shell nommé cmd ; ce vieux shell est limité et nous\nAnaconda Prompt (Miniconda3)\nvous en déconseillons l’utilisation.\nNous allons maintenant initialiser conda « à la main ». Cliquez sur\nAnaconda Powershell Prompt (Miniconda3)\nqui va lancer un Powershell avec conda activé, puis tapez la commande :\nconda init\nLorsque vous presserez la touche Entrée vous obtiendrez une sortie de ce style :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 387\nAnnexe B. Installation de Python B.2. Installation de Python avec Miniconda\nFigure B.4 – Installation Miniconda étape 4.\nFigure B.5 – Installation Miniconda étape 5.\n$ conda init\nno change C:\\Users\\Pat\\miniconda3\\Scripts\\conda.exe\nno change C:\\Users\\Pat\\miniconda3\\Scripts\\conda-env.exe\nno change C:\\Users\\Pat\\miniconda3\\Scripts\\conda-script.py\nno change C:\\Users\\Pat\\miniconda3\\Scripts\\conda-env-script.py\nno change C:\\Users\\Pat\\miniconda3\\condabin\\conda.bat\nno change C:\\Users\\Pat\\miniconda3\\Library\\bin\\conda.bat\nno change C:\\Users\\Pat\\miniconda3\\condabin\\_conda_activate.bat\nno change C:\\Users\\Pat\\miniconda3\\condabin\\rename_tmp.bat\nno change C:\\Users\\Pat\\miniconda3\\condabin\\conda_auto_activate.bat\nno change C:\\Users\\Pat\\miniconda3\\condabin\\conda_hook.bat\nno change C:\\Users\\Pat\\miniconda3\\Scripts\\activate.bat\nno change C:\\Users\\Pat\\miniconda3\\condabin\\activate.bat\nno change C:\\Users\\Pat\\miniconda3\\condabin\\deactivate.bat\nmodified C:\\Users\\Pat\\miniconda3\\Scripts\\activate\nmodified C:\\Users\\Pat\\miniconda3\\Scripts\\deactivate\nmodified C:\\Users\\Pat\\miniconda3\\etc\\profile.d\\conda.sh\nmodified C:\\Users\\Pat\\miniconda3\\etc\\fish\\conf.d\\conda.fish\nno change C:\\Users\\Pat\\miniconda3\\shell\\condabin\\Conda.psm1\nmodified C:\\Users\\Pat\\miniconda3\\shell\\condabin\\conda-hook.ps1\nno change C:\\Users\\Pat\\miniconda3\\Lib\\site-packages\\xontrib\\conda.xsh\nmodified C:\\Users\\Pat\\miniconda3\\etc\\profile.d\\conda.csh\nmodified C:\\Users\\Pat\\Documents\\WindowsPowerShell\\profile.ps1\nmodified HKEY_CURRENT_USER\\Software\\Microsoft\\Command Processor\\AutoRun\n388 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\n==> For changes to take effect, close and re-open your current shell. <==\n$ conda init\nno change C:\\Users\\Pat\\Miniconda3\\Scripts\\conda.exe\nno change C:\\Users\\Pat\\Miniconda3\\Scripts\\conda-env.exe\nno change C:\\Users\\Pat\\Miniconda3\\Scripts\\conda-script.py\nB.2. Installation de Python avec Miniconda Annexe B. Installation de Python\nFigure B.6 – Installation Miniconda étape 6.\nFigure B.7 – Installation Miniconda étape 7.\nNotez que cette manipulation créera automatiquement un fichier\n.\nC:\\Users\\nom_utilisateur\\Documents\\WindowsPowerShell\\profile.ps1\nCe fichier sera exécuté à chaque lancement d’un Powershell (équivalent du sous bash) et fera en sorte que\n.bashrc\nconda soit bien activé.\nB.2.3.2 Test de l’interpréteur Python\nNous sommes maintenant prêts à tester l’interpréteur Python. En premier lieu, il faut lancer un shell PowerShell. Pour\ncela, cliquez sur le bouton Windows et tapez . Vous devriez voir apparaitre le menu suivant :\npowershell\nCliquez sur l’icône , cela va lancer un shell PowerShell avec un fond bleu (couleur que l’on\nWindows PowerShell\npeut bien sûr modifier en cliquant sur la petite icône représentant un terminal dans la barre de titre). En principe, l’invite\ndu shell doit ressembler à . La partie indique que conda a bien été activé suite à\n(base) PS C:\\Users\\Pat> (base)\nl’initialisation faite si dessus (plus exactement c’est son environnement de base qui est activé, mais ça ne nous importe\npas pour l’instant). Pour tester si Python est bien installé, il suﬀit alors de lancer l’interpréteur Python en tapant la\ncommande :\npython\nSi tout s’est bien passé, vous devriez avoir un aﬀichage de ce style :\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 389\nAnnexe B. Installation de Python B.2. Installation de Python avec Miniconda\nFigure B.8 – Menu Anaconda Powershell Prompt\nFigure B.9 – Initialisation de conda\nFigure B.10 – Menu pour lancer un PowerShell.\n(base) PS C:\\Users\\Pat> python\nPython 3.12.4 | packaged by Anaconda, Inc. | (main, Jun 18 2024, 15:03:56) [MSC v.1929 64 bit (AMD64)] on\nwin32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\nCela signifie que vous êtes bien dans l’interpréteur Python. À partir de là vous pouvez taper puis appuyer sur\nexit()\n390 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.2. Installation de Python avec Miniconda Annexe B. Installation de Python\nFigure B.11 – Lancement de l’interpréteur Python dans un PowerShell.\nla touche Entrée pour sortir de l’interpréteur Python.\nB.2.3.3 Test du gestionnaire de paquets conda\nUne fois revenu dans le shell, tapez la commande , vous devriez obtenir :\nconda\nusage: conda-script.py [-h] [-v] [--no-plugins] [-V] COMMAND ...\nconda is a tool for managing and deploying applications, environments and packages.\noptions:\n-h, --help Show this help message and exit.\n-v, --verbose Can be used multiple times. Once for detailed output, twice for INFO logging, thrice\nfor DEBUG\nlogging, four times for TRACE logging.\n--no-plugins Disable all plugins that are not built into conda.\n-V, --version Show the conda version number and exit.\n[...]\nSi c’est le cas, bravo, conda est bien installé et vous pouvez passez à la suite (rendez-vous à la rubrique Installation\ndes modules supplémentaires) !\nB.2.3.4 Désinstallation de Miniconda\nSi vous souhaitez désinstaller Miniconda, rien de plus simple. Dans le menu Windows, tapez Anaconda puis Désins-\ntaller. Cela vous emmènera dans le panneau de configuration. Faites alors un clic droit sur , puis\nMiniconda3 py312...\ncliquez sur Désinstaller. Cela devrait ouvrir la fenêtre suivante :\nCliquez sur Next. Vous aurez alors l’écran suivant :\nCliquez sur Uninstall, puis à l’écran suivant confirmez que vous souhaitez désintaller Miniconda :\nLe désinstallateur se lancera alors (cela peut prendre quelques minutes) :\nUne fois la désinstallation terminée, cliquez sur Next :\nPuis enfin sur Finish :\nÀ ce point, Miniconda est bien désinstallé. Il reste toutefois une dernière manipulation que l’installateur n’a pas\neffectué : il faut détruire à la main le fichier\nC:\\Users\\nom_utilisateur\\Documents\\WindowsPowerShell\\profile.ps1\n(bien sûr, remplacez par votre propre nom d’utilisateur). Si vous ne le faites pas, cela aﬀichera\nnom_utilisateur\nun message d’erreur à chaque fois que vous lancerez un Powershell.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 391\nAnnexe B. Installation de Python B.3. Utilisation de conda pour installer des modules complémentaires\nFigure B.12 – Désinstallation de Miniconda (étape 1).\nFigure B.13 – Désinstallation de Miniconda (étape 2)."
  },
  {
    "title": "B.3 Utilisation de conda pour installer des modules complémentaires",
    "content": "B.3.1 Installation des modules supplémentaires\nCette étape sera commune pour les trois systèmes d’exploitation. À nouveau, lancez un shell (c’est-à-dire PowerShell\nsous Windows ou un terminal pour Mac OS X ou Linux).\nDans le shell, tapez la ligne suivante puis appuyez sur la touche Entrée :\n$ conda install numpy pandas matplotlib scipy biopython jupyterlab\nCette commande va lancer l’installation des modules externes NumPy, pandas, matplotlib, scipy, Biopython et Jupyter\nlab. Ces modules vont être téléchargés depuis internet par conda, il faut bien sûr que votre connexion internent soit\nfonctionnelle. Au début, conda va déterminer les versions des paquets à télécharger en fonction de la version de Python\nainsi que d’autres paramètres (cela prend une à deux minutes). Cela devrait donner la sortie suivante :\n392 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.3. Utilisation de conda pour installer des modules complémentaires Annexe B. Installation de Python\nFigure B.14 – Désinstallation de Miniconda (étape 3).\nFigure B.15 – Désinstallation de Miniconda (étape 4).\nChannels:\n- defaults\nPlatform: linux-64\nCollecting package metadata (repodata.json): done\nSolving environment: done\n## Package Plan ##\nenvironment location: /home/fuchs/miniconda3\nadded / updated specs:\n- biopython\n- jupyterlab\n- matplotlib\n- numpy\n- pandas\n- scipy\nThe following packages will be downloaded:\npackage | build\n---------------------------|-----------------\nanyio-4.2.0 | py312h06a4308_0 238 KB\nargon2-cffi-21.3.0 | pyhd3eb1b0_0 15 KB\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 393\nargon2-cffi-bindings-21.2.0| py312h5eee18b_0 33 KB\nasttokens-2.0.5 | pyhd3eb1b0_0 20 KB\n[...]\nThe following NEW packages will be INSTALLED:\nanyio pkgs/main/linux-64::anyio-4.2.0-py312h06a4308_0\nargon2-cffi pkgs/main/noarch::argon2-cffi-21.3.0-pyhd3eb1b0_0\nargon2-cffi-bindi~ pkgs/main/linux-64::argon2-cffi-bindings-21.2.0-py312h5eee18b_0\nasttokens pkgs/main/noarch::asttokens-2.0.5-pyhd3eb1b0_0\n[...]\nProceed ([y]/n)?\nAnnexe B. Installation de Python B.3. Utilisation de conda pour installer des modules complémentaires\nFigure B.16 – Désinstallation de Miniconda (étape 5).\nFigure B.17 – Désinstallation de Miniconda (étape 6).\nUne fois que les versions des paquets ont été déterminées, conda vous demande confirmation avant de démarrer\nle téléchargement. Tapez puis appuyez sur la touche Entrée pour confirmer. S’en suit alors le téléchargement et\ny\nl’installation de tous les paquets (cela prendra quelques minutes) :\nUne fois que tout cela est terminé, vous récupérez la main dans le shell :\n[...]\nDownloading and Extracting Packages:\nmkl-2023.1.0 | 171.5 MB | #\n########################################################################################################################################################4\n| 92%\nPreparing transaction: done\nVerifying transaction: done\nExecuting transaction: done\n$\nB.3.2 Test des modules supplémentaires\nPour tester la bonne installation des modules, lancez l’interpréteur Python :\n$ python\n394 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.3. Utilisation de conda pour installer des modules complémentaires Annexe B. Installation de Python\nPuis tapez les lignes suivantes :\n1 import numpy\n2 import scipy\n3\nimport Bio\n4 import matplotlib\n5\nimport pandas\nVous devriez obtenir la sortie suivante :\n>>> import numpy\n>>> import scipy\n>>> import Bio\n>>> import matplotlib\n>>> import pandas\n>>>\nSi aucune erreur ne s’aﬀiche et que vous récupérez la main dans l’interpréteur, bravo, ces modules sont bien installés.\nQuittez l’interpréteur Python en tapant la commande puis en appuyant sur la touche Entrée.\nexit()\nVous êtes de nouveau dans le shell. Nous allons maintenant pouvoir tester Jupyter. Tapez dans le shell :\n$ jupyter lab\nCette commande devrait ouvrir votre navigateur internet par défaut et lancer Jupyter :\nFigure B.18 – Test de Jupyter : ouverture dans un navigateur.\nPour quitter Jupyter, allez dans le menu File puis sélectionnez Quit. Vous pourrez alors fermer l’onglet de Jupyter.\nPendant ces manipulations dans le navigateur, de nombreuses lignes ont été aﬀichées dans l’interpréteur :\n(base) PS C:\\Users\\Pat> jupyter lab\n[I 18:26:05.544 LabApp] JupyterLab extension loaded from C:\\Users\\Pat\\Miniconda3\\lib\\site-packages\\\njupyterlab\n[I 18:26:05.544 LabApp] JupyterLab application directory is C:\\Users\\Pat\\Miniconda3\\share\\jupyter\\lab\n[...]\n[I 18:27:20.645 LabApp] Interrupted...\n[I 18:27:32.986 LabApp] Shutting down 0 kernels\n(base) PS C:\\Users\\Pat>\nIl s’agit d’un comportement normal. Quand Jupyter est actif, vous n’avez plus la main dans l’interpréteur et tous ces\nmessages s’aﬀichent. Une fois que vous quittez Jupyter, vous devriez récupérer la main dans l’interpréteur. Si ce n’est\npas le cas, pressez deux fois la combinaison de touches Ctrl + C\nSi tous ces tests ont bien fonctionné, bravo, vous avez installé correctement Python avec Miniconda ainsi que tous\nles modules qui seront utilisés pour ce cours. Vous pouvez quitter le shell en tapant puis en appuyant sur la touche\nexit\nEntrée et aller faire une pause !\nB.3.3 Un mot sur pip pour installer des modules complémentaires\nConseil\nSi vous êtes débutant, vous pouvez sauter cette rubrique.\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 395\nAnnexe B. Installation de Python B.4. Choisir un bon éditeur de texte\n8\nComme indiqué au début de ce chapitre, pip est un gestionnaire de paquets pour Python et permet d’installer des\nmodules externes. Pip est également présent dans Miniconda, donc utilisable et parfaitement fonctionnel. Vous pouvez\nvous poser la question « Pourquoi utiliser le gestionnaire de paquets pip si le gestionnaire de paquets est déjà\nconda\nprésent ? ». La réponse est simple, certains modules ne sont présents que sur les dépôts pip. Si vous souhaitez les installer\nil faudra impérativement utiliser pip. Inversement, certains modules ne sont présents que dans les dépôts de conda.\nToutefois, pour les modules classiques (comme NumPy, scipy, etc), tout est gérable avec conda.\nSauf cas exceptionnel, nous vous conseillons l’utilisation de conda pour gérer l’installation de modules\nsupplémentaires.\nSi vous souhaitez installer un paquet qui n’est pas présent sur un dépôt conda avec pip, assurez vous d’abord que\nvotre environnement conda est bien activé (avec ou ). La\nconda activate conda activate nom_environnement\nsyntaxe est ensuite très simple :\n$ pip install nom_du_paquet\nSi votre environnement conda était bien activé lors de l’appel de cette commande, celle-ci aura installé votre paquet\ndans l’environnement conda. Tout est donc bien encapsulé dans l’environnement conda, et l’ajout de tous ces paquets\nne risque pas d’interférer avec le Python du système d’exploitation, rendant ainsi les choses bien « propres »."
  },
  {
    "title": "B.4 Choisir un bon éditeur de texte",
    "content": "La programmation nécessite d’écrire des lignes de code en utilisant un éditeur de texte. Le choix de cet éditeur\nest donc fondamental, celui-ci doit nous aider à repérer rapidement certaines zones du programme afin d’être eﬀicace.\nOutre les fonctions de manipulation / remplacement / recherche de texte, un bon éditeur doit absolument posséder la\ncoloration syntaxique (syntax highlighting en anglais). Celle-ci change la couleur et / ou la police de certaines zones\ndu code comme les mot-clés du langage, les zones entre guillemets, les commentaires, etc. Dans ce qui suit, nous vous\nmontrons des éditeurs faciles à prendre en main par les débutants pour Linux, Windows et Mac OS X.\nB.4.1 Installation et réglage de gedit sous Linux\nPour Linux, on vous recommande l’utilisation de l’éditeur de texte gedit qui a les avantages d’être simple à utiliser et\nprésent dans la plupart des distributions Linux.\nSi gedit n’est pas installé, vous pouvez l’installer avec la commande :\n$ sudo apt install -y gedit\nIl faudra entrer votre mot de passe utilisateur puis valider en appuyant sur la touche Entrée.\nPour lancer cet éditeur, tapez la commande dans un shell ou cherchez gedit dans le lanceur d’applications.\ngedit\nVous devriez obtenir une fenêtre similaire à celle-ci :\nOn configure ensuite gedit pour que l’appui sur la touche Tab corresponde à une indentation de 4 espaces, comme\nrecommandée par la PEP 8 (chapitre 15 Bonnes pratiques en programmation Python). Pour cela, cliquez sur l’icône en\nforme de 3 petites barres horizontales en haut à droite de la fenêtre de gedit, puis sélectionnez Préférences. Dans la\nnouvelle fenêtre qui s’ouvre, sélectionnez l’onglet Éditeur puis fixez la largeur des tabulations à 4 et cochez la case Insérer\ndes espaces au lieu des tabulations :\nSi vous le souhaitez, vous pouvez également cochez la case Activer l’indentation automatique qui indentera automati-\nquement votre code quand vous êtes dans un bloc d’instructions. Fermez la fenêtre de paramètres une fois la configuration\nterminée.\nB.4.2 Installation et réglage de Notepad++ sous Windows\n9\nSous Windows, nous vous recommandons l’excellent éditeur Notepad++ . Une fois cet éditeur installé, il est important\nde le régler correctement. En suivant le menu , , vous arriverez sur un panneau vous permettant\nParamètres Préférences\nde configurer Notepad++.\nEn premier on va configurer l’appui sur la touche Tab afin qu’il corresponde à une indentation de 4 espaces, comme\nrecommandé par la PEP 8 (chapitre 15 Bonnes pratiques en programmation Python). Dans la liste sur la gauche, cliquez\n8.\nhttps://pip.pypa.io/en/stable/\n9. https://notepad-plus-plus.org/download\n396 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.4. Choisir un bon éditeur de texte Annexe B. Installation de Python\nFigure B.19 – Éditeur de texte gedit.\nFigure B.20 – Configuration de gedit.\nsur , puis à droite dans le carré cochez la case en réglant sur 4 espaces\nLangage Tabulations Insérer des espaces\ncomme indiqué ci-dessous :\nEnsuite, il est important de faire en sorte que Notepad++ aﬀiche les numéros de ligne sur la gauche (très pratique\nlorsque l’interpréteur nous indique qu’il y a une erreur, par exemple, à la ligne 47). Toujours dans la fenêtre ,\nPréférences\ndans la liste sur la gauche cliquez sur , puis sur la droite cochez la case\nZones d'édition Afficher la numérotation\ncomme indiqué ici :\ndes lignes\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 397\nAnnexe B. Installation de Python B.4. Choisir un bon éditeur de texte\nFigure B.21 – Configuration de Notepad++ : indentation avec des espaces.\nFigure B.22 – Configuration de Notepad++ : numéro de ligne.\nB.4.3 Installation et réglage de TextWrangler/BBedit sous Mac OS X\n10\nSur les anciennes versions de Mac OS X (< 10.14), TextWrangler était un éditeur de texte simple, intuitif et\n11\neﬀicace. Toutefois son développement a été arrêté car il fonctionnait en 32-bits. Il a été remplacé par BBedit qui\npossède de nombreuses fonctionnalités supplémentaires mais qui doit en principe être acheté. Toutefois, ce dernier est\nutilisable gratuitement avec les mêmes fonctionnalités que TextWrangler, sans les nouvelles fonctionnalités étendues. Ne\npossédant pas de Mac, nous nous contentons ici de vous donner quelques liens utiles :\n•\n12\nLa page de téléchargement ;\n• 13\nLa page vers de nombreuses ressources utiles ;\n•\n14\nLe manuel d’utilisation (avec toutes les instructions pour son installation au chapitre 2) ;\n• 15\nUne page sur Stackoverflow qui vous montre comment faire en sorte que l’appui sur la touche Tab aﬀiche 4\nespaces plutôt qu’une tabulation.\n10.\nhttp://www.barebones.com/products/textwrangler/\n11. https://www.barebones.com/products/bbedit/\n12.\nhttp://www.barebones.com/products/bbedit/download.html\n13. https://www.barebones.com/support/bbedit/\n14.\nhttps://s3.amazonaws.com/BBSW-download/BBEdit_12.6.6_User_Manual.pdf\n15. https://stackoverflow.com/questions/5750361/auto-convert-tab-to-4-spaces-in-textwrangler\n398 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.5. Comment se mettre dans le bon répertoire dans le shell Annexe B. Installation de Python\nB.4.4 Pour aller plus loin\nJusque là, nous vous avons montré des éditeurs de texte simples qui sont, selon nous, idéaux pour apprendre un langage\nde programmation. Ainsi, on se concentre sur le langage Python plutôt que toutes les options de l’éditeur. Toutefois, pour\n16\nles utilisateurs plus avancés, nous vous conseillons des plateformes de développement ou IDE (integrated development\nenvironment) qui, au-delà de l’édition, permettent par exemple d’exécuter le code et de le debugger (c’est-à-dire, y\n17 18\nchasser les erreurs). On peut citer par exemple les IDE libres Visual Studio code et Spyder ."
  },
  {
    "title": "B.5 Comment se mettre dans le bon répertoire dans le shell",
    "content": "Pour apprendre Python, nous allons devoir écrire des scripts, les enregistrer dans un répertoire, puis les exécuter avec\nl’interpréteur Python. Il faut pour cela être capable d’ouvrir un shell et de se mettre dans le répertoire où se trouve ce\nscript.\nNotre livre n’est pas un cours d’Unix, mais il convient au moins de savoir se déplacer dans l’arborescence avant de\nlancer Python. Sous Linux et sous Mac il est donc fondamental de connaître les commandes Unix , , et la\ncd pwd ls\nsignification de (point point).\n..\nSous Linux, il existe une astuce très pratique. Si vous utilisez l’explorateur de fichiers Nautilus, quand vous êtes dans un\nrépertoire, faites un clic droit et choisissez dans le menu Ouvrir dans un terminal. Vous vous retrouverez automatiquement\ndans le bon répertoire (vous pouvez vous en assurer avec la commande Unix ).\npwd\nFigure B.23 – Lancement d’un terminal depuis un répertoire donné avec Nautilus).\nDe façon similaire sous Windows, il existe deux astuces très pratiques. Lorsqu’on utilise l’explorateur Windows et que\nl’on est dans un répertoire donné :\nFigure B.24 – Lancement d’un powershell depuis un répertoire donné (étape 1).\n16. https://fr.wikipedia.org/wiki/Environnement_de_d%C3%A9veloppement\n17.\nhttps://code.visualstudio.com/\n18. https://www.spyder-ide.org/\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 399\nAnnexe B. Installation de Python B.6. Python web et mobile\nIl est possible d’ouvrir un PowerShell directement dans ce répertoire :\nPremière astuce\nIl suﬀit de taper dans la barre qui indique le chemin :\npowershell\nFigure B.25 – Lancement d’un powershell depuis un répertoire donné (étape 2).\npuis on appuie sur entrée et le PowerShell se lance en étant directement dans le bon répertoire !\nDeuxième astuce\nEn pressant la touche Shift et en faisant un clic droit dans un endroit de l’explorateur qui ne contient pas de fichier\n(attention, ne pas faire de clic droit sur un fichier !). Vous verrez alors s’aﬀicher le menu contextuel suivant :\nCliquez sur Ouvrir la fenêtre PowerShell ici, à nouveau votre Powershell sera directement dans le bon répertoire !\nVérification\nLa figure suivante montre le PowerShell, ouvert de la première ou la deuxième façon, dans lequel nous avons lancé\nla commande qui aﬀiche le nom du répertoire courant (celui dans lequel on se trouve, dans notre exemple\nls D:\\PAT\\\n) ainsi que les fichiers s’y trouvant (ici il n’y a qu’un fichier : ). Ensuite nous avons lancé l’exécution de\nPython test.py\nce fichier en tapant .\ntest.py python test.py\nÀ votre tour !\nPour tester si vous avez bien compris, ouvrez votre éditeur favori, tapez les lignes suivantes puis enregistrez ce fichier\navec le nom dans le répertoire de votre choix.\ntest.py\n1\nimport tkinter as tk\n2\n3\nracine = tk.Tk()\n4 label = tk.Label(racine, text=\"J'adore Python !\")\n5 bouton = tk.Button(racine, text=\"Quitter\", command=racine.quit)\n6\nbouton[\"fg\"] = \"red\"\n7 label.pack()\n8\nbouton.pack()\n9 racine.mainloop()\n10\nprint(\"C'est fini !\")\nComme nous vous l’avons montré ci-dessus, ouvrez un shell et déplacez-vous dans le répertoire où se trouve .\ntest.py\nLancez le script avec l’interpréteur Python :\n$ python test.py\nSi vous avez fait les choses correctement, cela devrait aﬀicher une petite fenêtre avec un message « J’adore Python !\n» et un bouton Quitter."
  },
  {
    "title": "B.6 Python web et mobile",
    "content": "Si vous ne pouvez ou ne souhaitez pas installer Python sur votre ordinateur (quel dommage !), des solutions alternatives\ns’offrent à vous.\nDes sites internet vous proposent l’équivalent d’un interpréteur Python utilisable depuis votre navigateur web :\n• 19\nrepl.it ;\n•\n20\nTutorials Point ;\n19.\nhttps://repl.it/languages/python3\n20. https://www.tutorialspoint.com/execute_python3_online.php\n400 Cours de Python / Université Paris Cité / UFR Sciences du Vivant\nB.6. Python web et mobile Annexe B. Installation de Python\nFigure B.26 – Lancement d’un powershell depuis un répertoire donné (étape 2bis).\n• 21\net bien sur l’incontournable Python Tutor .\nDes applications mobiles vous permettent aussi de « pythonner » avec votre smartphone :\n• 22\nPydroid 3 pour Android ;\n21.\nhttp://pythontutor.com/visualize.html#mode=edit\n22. https://play.google.com/store/apps/details?id=ru.iiec.pydroid3\nCours de Python / Université Paris Cité / UFR Sciences du Vivant 401\nAnnexe B. Installation de Python B.6. Python web et mobile\nFigure B.27 – Lancement d’un powershell depuis un répertoire donné (étape 3).\n• 23\nPythonista 3 pour iOS (payant).\nSoyez néanmoins conscient que ces applications web ou mobiles peuvent être limitées, notamment sur leur capacité\nà installer des modules supplémentaires et à gérer les fichiers.\n23. https://itunes.apple.com/us/app/pythonista-3/id1085978097\n402 Cours de Python / Université Paris Cité / UFR Sciences du Vivant"
  }
]